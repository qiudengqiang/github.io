{"meta":{"title":"techbird blog","subtitle":"timeline of growth","description":"Hi，Welcome to the blog of a programmer.","author":"techbird","url":"https://blog.alphabethub.com","root":"/"},"pages":[{"title":"","date":"2021-04-29T11:14:31.991Z","updated":"2021-04-29T11:14:31.991Z","comments":false,"path":"/404.html","permalink":"https://blog.alphabethub.com/404.html","excerpt":"","text":""},{"title":"关于博主","date":"2016-04-23T02:15:17.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"about/index.html","permalink":"https://blog.alphabethub.com/about/index.html","excerpt":"","text":"简介Programmer&#123; name = \"dengqiangqiu\" gender = \"Male\" born = \"1994\" hobby = \"Read、Code、Run、Cook\" skills = \"Java、Python、iOS、Android\"&#125; 更多信息extention&#123; description = \" 欢迎来到我的站 :) 也许你在这里能读到的 只是中国千千万工科生中最普通的一员 在面对万千事物时 所能写下的茫然和转化 只想多年以后 读起年青时写下的憋足文字时 是别样的思绪万千 只因这里真实的记录了我的生活，我的成长... \"&#125;"},{"title":"tags","date":"2018-04-26T14:44:22.000Z","updated":"2021-04-29T11:14:32.295Z","comments":false,"path":"tags/index.html","permalink":"https://blog.alphabethub.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL调优的流程","slug":"sql-optimize-procedure","date":"2021-04-28T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2021/04/28/sql-optimize-procedure/","link":"","permalink":"https://blog.alphabethub.com/2021/04/28/sql-optimize-procedure/","excerpt":"","text":"SQL调优无论在实际工作中还是在面试过程中都是考查的重点，在文章中我将从慢查询分析和索引两个角度来介绍SQL调优的一点思路。 慢查询分析SQL优化并不是漫无目的一条条去 explain SQL语句，需要具备针对性，所以我们只需要对执行时间超出我们预期的SQL进行针对的调整，那么慢查询分析日志就是帮我们快速定位超预期执行时间的SQL的一个有力工具。 打开慢查询分析日志开关打开慢查询分析日志的开关的两种方式：1.修改配置文件，2.设置参数。我们下面使用设置参数的方式来演示： 登入MySQL(略) 查看慢查询日志分析文件的配置信息： show variables like 'slow_query%'; 得到如下的配置信息： +---------------------+-------------------------------------------------+| Variable_name | Value |+---------------------+-------------------------------------------------+| slow_query_log | OFF || slow_query_log_file | /usr/local/mysql/data/TechBird-Macbook-slow.log |+---------------------+-------------------------------------------------+2 rows in set (0.00 sec) 把slow_query_log 的值 OFF 设置为 ON，即打开慢查询分析日志记录。记录的日志文件会保存在slow_query_log_file 的 Value 所指向的路径文件中，如果需要也可以对其进行修改。 set global slow_query_log = 'ON'; 更改慢查询分析的默认时间MySQL默认是的时间是 10 sec，显然时间太长了，我们可以修改这个参数为自己的心里预期时间： 查看默认时间配置： show variables like 'long_query%'; 得到如下的配置信息： +-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.00 sec) 修改默认的时间（单位：秒），一般在项目中可以设置为0.1秒，即100毫秒。为了演示方便下面将其设置为1秒： set global long_query_time = 1; 修改完所有参数之后要quit;重新登入数据库才能保证已设置的参数生效。 构造一个慢的SQL测试语句select sleep(3); 查看慢查询分析的日志文件温馨提示：在查看慢查询分析文件之前要quit; MySQL。 通过查看慢查询分析的日志文件，我们可以了解项目中哪些SQL超出了我们设置的预期执行时间，然后针对其进行优化： tail &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;TechBird-Macbook-slow.log 日志如下： # Time: 2021-04-01T06:59:15.149853Z# User@Host: root[root] @ localhost [] Id: 419# Query_time: 3.005275 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0SET timestamp=1617260355;select sleep(3); 通过查看日志，可以准确的定位出是这条select sleep(3);执行超出了预期时间，从而利用下文所介绍的方法针对其进行优化。 索引我们已经定位出了执行超出预期时间的SQL语句，一般来说可以使用explain工具对其进行分析定位问题，总结起来就是如下几点： 理解 MySQL InnoDB 的索引原理 掌握 MySQL 执行计划的方法 掌握导致索引失效的常见情况 掌握实际工作中常用的建立高效索引的技巧（如前缀索引、建立覆盖索引等） 在这之前我们需要先介绍一下索引相关的概念和知识。 相关概念在实际应用中，InnoDB 是 MySQL 建表时默认的存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。 在创建表时，InnoDB 存储引擎默认使用表的主键作为主键索引，该主键索引就是聚簇索引（Clustered Index），如果表没有定义主键，InnoDB 就自己产生一个隐藏的 6 个字节的主键 ID 值作为主键索引，而创建的主键索引默认使用的是 B+Tree 索引。 索引分类：普通索引、唯一索引、全文索引、空间索引 在MySQL的官方文档中，create [option] index语法中，[option]就是用来修饰索引。 缺省代表普通索引 unique代表唯一索引 fulltext代表全文索引，全文索引目前通常采用ElasticSearch来实现，而不是在数据库内部来做 spatial代表空间索引，而空间索引在一些老的MySQL版本中是不支持的，一般用于存储一些地址坐标数据 存储方式：B-Tree、Hash InnoDB支持B-Tree，不支持Hash InnoDB 选择 B+Tree 当默认的索引数据结构 数据存储有序（最左前缀与此息息相关） 每个叶子节点到根的距离相同 依赖列数：单列索引、组合索引 数据分布：聚簇索引、二级（辅助）索引 所谓聚簇索引就是指实际的数据行直接存到了叶子节点当中，而主键索引是聚簇索引的一个通常的形式。 通过主键查询数据，不需要回表，直接就可以得到数据行，效率较高。 非聚簇（主键）索引（辅助索引），叶子节点保存的不是最终的数据行，而只是一个主键值，需要通过主键值再去主键（聚簇）索引里查询最终叶子节点的数据行。因此需要走两次索引，是索引的索引，所以称为二级索引或辅助索引。这个过程叫回表。 回表情况：覆盖索引 当一个索引包含（覆盖）了需要查询的字段值时，称其为覆盖索引 只有select、where中出现的列被索引覆盖的情况才是覆盖索引 此时如果使用 explain 分析可以看到 Extra 的值为Using index colums: a b c d eindex(a,b,c)select a,b,c from T where a=\"\" and b=\"\"; 最左前缀(Leftmost Prefixing)table T,index(a,b,c)-- 全值匹配select * from T where a='' and b='' and c=''; -- YESselect * from T where c='' and b='' and a=''; -- YES-- 匹配左前缀select * from T where a=''; -- YESselect * from T where b=''; -- NO-- 匹配列前缀select * from T where a like 'x%'; -- YESselect * from T where a like '%x'; -- NOselect * from T where b like 'x%'; -- NO-- 匹配范围值select * from T where a between '' and ''; -- YESselect * from T where b between '' and ''; -- NO-- 全值匹配 + 范围值匹配select * from T where a='' and b between '' and ''; -- YESselect * from T where b='' and c between '' and ''; -- NOselect * from T where a between '' and '' and b=''; -- NO 执行计划(explain)了解完上面的概念之后，我们来介绍一下在实际工作中如何查看索引的执行计划。 我这里有一张存储用户信息的演示表 tab_user： create table `tab_user`( `uid` int(11) not null, `username` varchar(255) default null, `password` varchar(255) default null, `name` varchar(255) default null, primary key (`uid`) using btree, key 'index_name' ('name'), key 'index_uid_name' ('uid','name')); 表中包含了主键索引、name 字段上的普通索引，以及 uid 和 name 两个字段的联合索引。现在我们来看一条简单查询语句的执行计划： explain select uid,name from tab_user where uid='1'; 对于执行计划，参数有 possible_keys 字段表示可能用到的索引，key 字段表示实际用的索引，key_len 表示索引的长度，rows 表示扫描的数据行数，filtered表示覆盖率%。Extra表示额外的信息说明。 这其中需要重点关注type字段，表示数据扫描类型，也就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为（考虑到查询效率问题，全表扫描和全索引扫描要尽量避免）： ALL（全表扫描）； index（全索引扫描）； range（索引范围扫描）； ref（非唯一索引扫描）； eq_ref（唯一索引扫描）； const（结果只有一条的主键或唯一索引扫描）。 总的来说，执行计划是研发工程师分析索引详情必会的技能（很多大厂公司招聘 JD 上写着“SQL 语句调优” ），所以你在面试时也要知道执行计划核心参数的含义，如 type。在回答时，也要以重点参数为切入点，再扩展到其他参数，然后再说自己是怎么做 SQL 优化工作的（讲个故事）。 索引失效的常见情况在工作中，我们经常会碰到 SQL 语句不适用已有索引的情况，来看一个索引失效的例子： select * from tab_user where name like '%z' 这条带有 like 查询的 SQL 语句，没有用到 tab_user 表中的 index_name 索引。 我们结合普通索引的B+Tree结构来分析一下索引失效的原因：当MySQL优化器根据name like ‘%z’这个条件，到索引index_name的B+Tree结构上去查询评估时，发现当前节点的左右子节点的值都有可能符合’%z’这个条件，于是优化器判定当前索引需要扫描整个索引，而且还要回表查询，不如直接全表扫描。 当然还有其他类似的索引失效的情况： 索引列上做了表达式计算、函数、隐式类型转换操作，这些情况下索引失效是因为查询过程需要扫描整个索引并回表，代价高于直接全表扫描； like匹配使用了左模糊查询（’%abc’）或左右模糊查询（’%abc%’）； 字符串不加引号导致隐式类型转换； 被使用的索引字段不是联合索引的最左字段 总结：如果MySQL查询优化器预估走索引的代价比全表扫描的代价还要大，则不走对应的索引，直接扫描全表。如果走索引比全表扫描代价小，则使用索引。 常见优化索引的方法 前缀索引优化 前缀索引就是用某个字段中，字符串的前几个字符建立索引；使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。 但是前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。 覆盖索引优化 覆盖索引是指 SQL 中 query 的所有字段，在索引 B+ Tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。 假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？ 我们可以建立一个组合索引，即商品ID、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。所以，使用覆盖索引的好处很明显，即不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。 联合索引 联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。 建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。 区分度就是某个字段 column 不同值的个数除以表的总行数，比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。 小结 参考资料https://mp.weixin.qq.com/s/xaJg28qXCAC4XR2mTm4xUg","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.alphabethub.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.alphabethub.com/tags/MySQL/"}]},{"title":"Java Lambda 表达式详解","slug":"java-lambda","date":"2021-02-24T11:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2021/02/24/java-lambda/","link":"","permalink":"https://blog.alphabethub.com/2021/02/24/java-lambda/","excerpt":"","text":"Lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。 语法表达式形式：参数，箭头(-&gt;)，以及一个表达式。例如： (String first, String second) -&gt; first.length() - second.length() 如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显示的return语句。例如： （String first, String second）-&gt; &#123; if(first.length() &lt; second.length()) return -1; else if(first.length() &gt; second.length()) return 1; else return 0;&#125; 即使lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样： () -&gt; &#123;for (int i = 100; i &gt;= 0; i—) System.out.println(i);&#125; 如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如: Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); 在这里，编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器。 如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号： ActionListener listener = event -&gt; System.out.println(“test”); 无须指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。例如： (String first, String second) -&gt; first.length() - second.length() 可以在需要int类型结果的上下文中使用。 注释：如果lambda表达式只在某些分支返回一个值，而另外一些分支不返回值，这是不合法的。例如： (int x) -&gt; &#123; if (x &gt;= 0) return 1; &#125;//不合法 函数式接口对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口成为函数式接口（functional interface）。例如： Arrays.sort(words,(first, second) -&gt; first.length() - second.length()); 在底层，Arrays.sort 方法会接受实现了Comparator的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。 注释：最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lamda表达式可以传递到函数式接口。实际上在Java中，对lambda表达式所能做的也只是转换为函数式接口，Java设计者没有为Java语言增加函数类型（在其他程序设计语言中，可以声明函数类型的变量）。不能把lambda表达式赋值给类型为Object的变量，因为Object不是函数式接口。 java.util.function 包中定义了很多非常通用的函数式接口。例如： Predicate： public interface Predicate&lt;T&gt; &#123; boolean test(T t); //additional default and static methods&#125; ArrayList类中有一个removeIf方法，它的参数就是一个Predicate。这个接口专门用来传递lambda表达式。例如，下面的语句将从一个数组列表中删除所有的null值： list.removeIf(e -&gt; e == null); Supplier： public interface Supplier&lt;T&gt; &#123; T get();&#125; 供应者（supplier）没有参数，调用时会生成一个T类型的值。供应者用于实现懒计算：例如： LocalDate hireDay = Objects.requireNonNullOrElse(day, new LocalDate(1970,1,1)); 这不是最优的，我们与day很少为null，所以希望只在必要时才构造默认的LocalDate，通过使用供应者，我们就能延迟这个计算： LocalDate hireDay = Objects.requireNonNullOrElseGet(day, () -&gt; new LocalDate(1970,1,1)); requireNonNullOrElseGet 方法只在需要值时才调用供应者。 方法引用有时，lambda表达式涉及一个方法。例如： var timer = new Timer(1000, event -&gt; System.out.println(event)); 但是，如果直接把println方法传递到Timer构造器就更好了。具体做法如下： var timer = new Timer(1000,System.out::println); 表达式System.out::println是一个方法引用（method reference），他只是编译器生成一个函数式接口的实例，覆盖整个接口的抽象方法来调用给定的方法。在这个例子中，会生成一个 ActionListener，它的 actionPerformed(ActionEvent e) 方法要调用 System.out.println(e)。 注释：类似于lambda表达式，方法引用也不是一个对象。不过，为一个类型为函数式接口的变量赋值时会生成一个对象。 再来看一个例子，假设想对字符串进行排序，而不考虑字母的大小写，可以传递以下方法表达式： Arrays.sort(strings,String::compareToIgnoreCase) 小结：要用::运算符分割方法与对象或者类名。主要有3种情况： object::instanceMethod Class::instanceMethod Class::staticMethod 在第1种情况下，方法引用等价于向方法传递参数的lambda表达式。对于System.out::println，对象是 System.out，所以方法表达式等价于 x -&gt; System.out.println(x)。 对于第2种情况，第1个参数会成为方法的隐式参数。例如，String::compareToIgnoreCase 等同于(x, y) -&gt; x.compareToIgnoreCase(y)。 在第3种情况下，所有参数都会传递到静态方法：Math::pow等价于(x, y) -&gt; Math.pow(x, y) 注：只有当lambda表达式的体只调用一个方法而不做其他操作时，才能把lambda表达式重写为方法引用。考虑以下表达式： s -&gt; s.length == 0 这里有一个方法调用。但是还是有一个比较，所以这里不能使用方法引用。 构造器引用构造器引用与方法引用很类似，只不过方法名为new。例如，Person::new 是 Person 构造器的一个引用。 可以用数组类型简历构造器引用。例如，int[]::new是一个构造器引用，他有一个参数：即数组的长度。这等价于lambda表达式x -&gt; new int[x]。 Java有一个限制，无法构造泛型类型T的数组。但是利用数组构造器可以克服这个限制，例如： Person[] people = stream.toArray(Person[]::new); toArray方法调用这个构造器来得到一个有正确类型的数组。然后填充并返回这个数组。 变量作用域lambda 表达式有3个部分： 一个代码块； 参数； 自由变量的值，这里指非参数而且不在代码中定义的变量 lambda表达式中访问外围方法或者类中的变量。lambda表达式中捕获的变量必须实际上是事实最终变量（effectively final），事实最终变量是指，这个变量初始化之后就不会再为它赋新值。在下面例子中，text总是指示同一个String对象，所以捕获这个变量是合法的。 public static void repeatMessage(String text)&#123; ActionListener listener = event -&gt; &#123; System.out.println(text); &#125;&#125; 在lambda表达式中，只能引用值不会改变的变量（因为，如果在lambda表达式中更改变量，并发执行多个动作是就会不安全），下面这种做法是不合法的： public static void countDown(int start)&#123; ActionListener listener = event -&gt; &#123; start--; //ERROR：Can’t mutate captured variable System.out.println(start); &#125;&#125; 如果在lambda表达式中引用一个变量，而这个变量可能在外部改变，这也是不合法的。例如： public static void repeat(String text, int count)&#123; for(int i = 1; i &lt;= count; i++)&#123; ActionListener listener = event -&gt; &#123; //i的值会改变，因此不能捕获i System.out.println(String.valueOf(i) + text); &#125; &#125;&#125; 注： lambda表达式的体与嵌套块有相同的作用域。所以这里同样适用命名冲突和遮蔽的有关规则。在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数 public class Application&#123; public void init()&#123; ActionListener listener = event -&gt; &#123; System.out.println(this.toString()); &#125; &#125;&#125; 表达式this.toString()会调用Application对象的toString方法，而不是ActionListener实例的方法。 处理lambda表达式如何编写方法处理lambda表达式?，使用lambda表达式的重点是延迟执行 需要选择一个合适的函数式接口 可以选择自定义函数式接口，建议使用@FunctionalInterface注解标记这个接口，这样如果无意中增加了另一个抽象方法，编译器就会产生一个错误消息 再谈ComparatorComparator接口包含很多方便的静态方法来创建比较器，这些方法可以用于lambda表达式或方法引用。 参考资料Core Java Volume I — Fundamentals (Eleventh Edition)","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"},{"name":"lambda","slug":"lambda","permalink":"https://blog.alphabethub.com/tags/lambda/"}]},{"title":"财商启蒙 - 读《富爸爸穷爸爸》","slug":"read-fbbqbb","date":"2021-01-31T11:55:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2021/01/31/read-fbbqbb/","link":"","permalink":"https://blog.alphabethub.com/2021/01/31/read-fbbqbb/","excerpt":"","text":"引言这是一本被认为是财商启蒙的畅销书，作者罗伯特·清崎是一位日裔美国人。对于其书中所陈述的自己的成功，在网络上有一定的争议；其中具有代表性的是，在2012年有新闻报道《富爸爸穷爸爸》的作者拥有的一家公司申请破产。但之后又被澄清说只是公司破产而并非个人破产。无论作者怎样，读完这本书之后，我觉得书中还是有几个观点值得思考和学习。 财商作者认为人们一定要学习财务知识，要真正认识到资产和负债的区别，用正确的态度来对待金钱。展开来讲就是从长远来看，重要的不是赚了多少钱，而是有多少钱留下；而资产是以最低限度的劳动把钱放进我们口袋的东西，负债是把钱从我们口袋里拿走的东西；钱的作用是解决问题，解决问题本身很重要，而工作只是面对长期问题的一种暂时的解决办法。建议人们要关注自己的事业，把事业的重心放到资产项而不是收入项。那么第一笔资产的积累怎么获得？针对成年人切实可行的办法就是，把支出保持在低水平并勤劳的工作会有助于打下稳固的资产基础。 什么是财商（财务知识）? 会计（财务知识，也就是解读数字的能力以及评估一项生意的优势和劣势） 投资（钱生钱的科学和策略） 了解市场（供给与需求的科学以及市场条件） 法律（减税优惠和在诉讼中获得保护） 资产和负债（这张图片很清晰的表达了作者不断提到的思想） 首先支付自己「首先支付自己」就是首先不能陷入债务之中。遵循一下两个法则： 1．不要让自己背上数额过大的债务包袱。保持低支出。首先建立资产项，然后再用资产项购买大房子或豪车。 2．当你资金短缺时，让压力去发挥作用，不要动用你的储蓄或投资。利用压力激发你的理财天赋，想出新的赚钱方法，然后支付你的账单。这样不但能让你赚到钱，还能提高你的财商。 利用金钱的力量作者认为在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被“宰割”的对象。真正的投资者在市场上涨和下跌时都能赚钱。而实现财务自由和获得巨大财富的关键取决于一个人将劳动性收入转化成被动收入或投资组合收入的能力。正如美国最富有的投资者沃伦·巴菲特说的「风险来自于你不知道自己在做什么」，如果非常清楚自己在做的事情，那么投资就不具有风险，这是投资的常识。 行动我从作者认为的唤醒投资天赋的10个步骤，选出来几条目前自己认可的观点。 寻找让自己致富的精神力量 首先投资学习（多听，多学习。以长远的眼光来看待财富，不要存有一夜暴富的念头。在投资股票或房地产之前，请先投资你最重要的资产——头脑。） 不要听贫穷的人或胆小的人话 辩证双刃的听取两极的言论 养成自律的消费习惯（能否自律是将富人、穷人和中产阶级区分开的首要因素） 压力就是动力（不要随便动用储蓄） 学会选择并利用专业人士（好建议的力量） 学会和职位比自己高的人一起工作（许多中层管理人员一直停留在中层，就是因为他们只知道如何与职位低于自己的人一起工作，却不善于和比自己职位高的人一起工作。） 慎重的选择朋友（每个人的成功和失败都有其可取之处） 小结上天赐予我们每个人两样伟大的礼物：思想和时间。你可以运用这两件礼物去做你愿意做的事情。这是一个可以转变如何正确积累财富的启蒙好书，推荐给大家。","categories":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/categories/Readed/"}],"tags":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"2020 年度终结","slug":"daily-2021-0103","date":"2021-01-02T06:44:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2021/01/02/daily-2021-0103/","link":"","permalink":"https://blog.alphabethub.com/2021/01/02/daily-2021-0103/","excerpt":"","text":"FLAGOF2021 回忆的动人之处就在于可以重新选择，可以将那些毫无关系的往事重新组合起来，从而获得了全新的过去。余华 回顾2020年的立下的 flag 觉得完成度还是非常高，比如跑步double了，英语打卡几乎全年满卡(2020/01/25开始)，论文虽然经历了两次拒稿，但还是写出来了，剩下的只需要修改完善即可。那么，新的一年到来的时候就需要插上新的 flag，无论去年的完成了多少。2020年的 flag 带来了许多收获，明白了即使微小的坚持可能会带来意想不到的结果。比如 CET-6 不经意的就考过了。2020年花了比较多的精力在算法上，所以决定2021年给自己添加一个 LeetCode of Flag 并将它保持下去 。 2020我的阅读书单 芳华 - 严歌苓 如何攻读博士学位 - 冯长根 白鹿原 - 陈忠实 MySQL 必知必会 - [英] Ben Forta / 刘晓霞、钟鸣 邓小平时代 - [美] 傅高义 / 冯克利 一个人的村庄 - 刘亮程 当我跑步时我谈些什么 - [日] 村上春树 / 施小炜 在细雨中呼喊 - 余华 黄金时代 - 王小波 豆瓣给我的 2020 的读书总结是：「这一年中有6个月与书籍为伴，喜欢在午后阅读，通常喜欢读文学类。」相比 2019 年，今年留在阅读上的时间非常少，大多都是疫情在家隔离期间读完，返校后便没有什么进展了。于是，2020年立下的读书 flag 惨遭打脸。既然立多了，那2021年就少一些，12本，相当于每月读一本书；但需要把读书的口味暂时性的迁移到「理财」和「技术」类。因为作为一个年轻的社会主义战士，当下我更需要这些可以刺刀见红的武器。白岩松有句话说：「那些以前读过的书，虽然很多时候记不起书里的内容，可是它并不会白读，它已经成为了你血液中的一部分，时时刻刻影响你的三观。」 我认为一定程度上，这只是一句鸡汤，实操性的书是需要记录和实践的。比如投资和编程。所以，2021年把自己的阅读量定的少一些，但每一本书都写一篇读书笔记。 运动 “疼痛无法避免，磨难却可以选择”，每当我长跑的时候，脑海里就反复出现这句话。村上春树 疫情在家隔离期间体重飙升至80kg，于是从5月18日返校开始，重新开始跑步。2020年是跑量最多的一年（1003km）。其中跑了2个半马，参加了太原线下半程马拉松，最好的成绩进了2小时。于是体重回到了70kg。起起伏伏的一年就算过去了。 理财作为一名在读学生，并没有什么钱。但是人一定不是因为有了钱才开始理财的，所以理财的种子需要提早播种，有人说学理财最快的方式就是拿一些钱投进去，亏钱了，慢慢就学会了。于是今年我开始买基金，了解了什么是定投。给自己规划了一些必看的理财书籍，希望2021年投资方面能够在知识和实践上都有所获，并写在此处记录。 一些重要的小事2020.01.14 - 2020年我26岁了。 2020.06.22 - 灯火阑珊，找到了我的soulmate 2020.09.10 - 拿到了驾照 2020.10.01 - 带她回家见了爸妈 2020.11.04 - 六级顺利通过，签了实习离校协议 扇贝打卡天数-体重-每月跑量 展望2021对于2021年，除了飘扬的flag要兑现，还希望能获得一份满意的实习经历、能够在秋招中有满意的斩获、小论文能够顺利投中、完成投资和储蓄计划；以及保持身体健康。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"Linux Common Sense","slug":"linux-common-sense","date":"2020-11-21T14:51:51.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2020/11/21/linux-common-sense/","link":"","permalink":"https://blog.alphabethub.com/2020/11/21/linux-common-sense/","excerpt":"","text":"linux 的发展史 Unix Minix Linux linux 的版本 内核版本 发行版本：redhat、ubuntu、centos linux 下常用的目录结构 /：根目录 ~：用户的家目录 .：当前目录 /home ：系统默认的用户home目录，存放普通用户相关文件 /root：管理员的home目录，存放root用户相关文件 /bin：存放linux常用命令的目录，如ls、vi、cat等 /sbin：需要一定权限才可以使用该目录下的命令 /etc：存放系统配置相关文件 /tmp：存放用户或正在执行的程序临时存放文件的目录 /usr：安装一个软件的默认目录，相当于windows下的program files /var：存放经常变化的文件，如网络连接的sock文件、日志等 /boot：存放引导系统启动的相关文件 /proc：这是虚拟目录，不占磁盘空间。是系统内存的映射，访问这个目录来获取系统相关信息 /mnt：默认挂在光驱和软驱的目录 /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备 /srv：service的缩写。该目录提供一些服务启动之后需要读取的数据 /sys：linux 2.6内核之后一个变化，该目录下安装了一个2.6之后出现的新文件系统 /del：类似于windows的设备管理器，把所有的硬件以文件的形式存储 /media：用于临时挂载被的文件系统 /opt：用于存放主机额外的软件，如oracle数据库就可以放在该目录下 终端命令格式command [-opitons] [parameter] 说明： command：命令名 [-option]：选项，可用来对命令进行控制和细化，也可省略 [parameter]：传递给命令的参数，可以是0个、1个或多个 []：代表可选 查阅命令的帮助信息 command --help：显示command命令的帮助信息 man command：查阅command命令的使用手册 使用man命令时的操作键： space，显示下一页 enter，一次滚动手册页的一行 b，回滚一页 f，前滚一屏 q，退出 /word，搜索word字符串 常见的linux命令 ssh username@ip -p port：链接远程服务器命令 exit：退出登录 ls：查看当前文件下的内容 ll：ls -l的简写 -a：a=all，显示指定文件下所有子目录与文件，包括隐藏文件 -l：l=list，以列表形式显示详细信息 -h：h=humanity，配合-l以人性化的方式展示文件大小 pwd：查看当前所在文件夹 touch [文件名]：新建文件 touch file1 file2 ...：创建多个文件 mkdir [目录名]：创建目录 mkdir -p dir1/dir2/dir3：递归创建目录 rm [文件名]：删除指定的文件名 rmdir/rm -r：删除文件夹 -r：recursion，表示删除目录 -f：force，强制 -i：interactive，以交互的方式删除 mv：移动、重命名 mv 1.txt 2.txt -f：强制移动，如有覆盖会给出提示 -i：交互式操作，如覆盖目标之前提示 -v：展示移动进度 cp：文件或者目录的复制 cp 1.txt 2.txt -a：保持文件原有属性 -f：覆盖已经存在的目标文件而不提示 -i：交互式复制，在覆盖目标文件之前提示 -r：目标文件必须为目录。会拷贝该目录下所有子目录和文件 -v：展示拷贝进度 find：查找指定目录下的文件 一般格式：find 路径 -name 文件名 find . -name test.sh：查找当前目录下名为test.sh的文件 find . name &#39;*.sh&#39;：查找当前目录下所有以.sh后缀结尾的文件 grep：文本搜索 一般格式：grep [-options] &#39;搜索内容&#39; 文件名 eg：grep &#39;a&#39; 1.txt -v：显示不包含匹配文本的所有行，即取反 -n：显示匹配行及行号 -i：忽略大小写 搜索内容支持正则表达式 ^a：表示以a开头。eg：grep -n &#39;^a&#39; a.txt b$：表示以b结尾。eg：grep -n &#39;b$&#39; a.txt [a-z]：范围中的一个。eg：grep -n [a-z][a-z][a-z].txt b.txt tar：归档管理 一般格式：tar [参数] 打包文件名 文件 打包 ：tar cvf 包名.tar 文件名 解包 ：tar xvf 包名.tar -C 路径 -c：生成档案文件，创建打包文件 -v：列出归档解档的详细过程，显示进度 -f：指定档案文件名称 -t：列出档案中包含的文件 -x：解开档案文件 -z ：归档压缩。调用gzip的压缩功能，先打包后压缩。默认后缀名为 file.tar.gz 打包：tar cvzf 压缩包包名 文件1 文件2 ... 解包：tar zxvf 包名 -C 路径 注意：tar 命令[参数]前面可以使用-，也可以省略 gzip：文件压缩解压，用gzip压缩tar打包后的文件扩展名一般用xxx.tar.gz gzip [选项] 被压缩文件 -d：解压 -r：压缩所有子目录 chmod：修改文件权限 一个文件创建完成后，默认会有三个组：属主，属组，其他。每个组默认会有三个权限属主owner，属组group，其他otherrwx， rwx， rwx 字母法：chmod u/g/o/a +/-/= rwx filename u：user，表示文件的所有者 g：group，用户组 o：other，其他 a：all，以上三者皆是 +：增加权限 -：撤销权限 =：设定权限 r：read，读取权限 w：write，写入权限 x：excute，执行权限 数字法：chmod 751 filename r：读取权限，数字代号为4 w：写入权限，数字代号为2 x：执行权限，数字代号为1 -：不具有任何权限，数字代号为0 eg：chmod u=rwx,g=rx,o=r filename 等同于 chmod u=7,g=6,o=1 filename -R：递归所有目录加上相同权限，如chmod 777 test/ -R 递归test目录下所有文件加777权限 who：用于查看当前所有登录系统的用户信息 -q或--count：只显示用户的登录账号和登录用户的数量 -u或--heading：显示列标题 which：查看命令所在位置，例如which pwd passwd：修改用户登录密码 clear：清屏 shutdown：关机 reboot：重启 more：分屏展示 more text.txt q：退出 space：下一页 h：获取帮助 cat：查看并合并文件内容 cat file1 file2 ...：合并多个文件查看 软连接 / 硬链接 命令格式：ln [-s] 源文件 链接文件 ln -s a.txt a_sl：软连接，相当于win下面的快捷方式 尽量使用绝对路径 当源文件大小改变时，链接文件不受影响 链接文件几乎不占用磁盘空间 当源文件删除，链接文件失效 软连接可以链接目录 ln b.txt b_sl：硬链接 只能链接普通文件，不能链接目录 链接文件几乎与源文件占用空间一致 当源文件删除时候，链接文件不受影响 重定向 ls &gt; test.txt：讲查询结果重定向输出到文件中，若文件不存在则创建。若存在则覆盖 &gt;：输出重定向为覆盖 &gt;&gt;：输出重定向为追加至文件的尾部 cd [目录名]：切换文件夹 cd .：进入当前路径 cd ..：返回上一级目录 cd /：返回根目录 cd ~：返回home目录 cd -：进入上次所在的目录 通配符 * ：表示所有字符 ?：只代表任意一个字符 [a-z]：表示a-z中任意一个字符 \\：反斜杠，转义字符 head &amp; trail head -n filename：查看文件的前n行 trail -n filename：查看文件的后n行 trail -f filename：动态查看文件的内容 查看进程和端口号 进程：ps aux |grep *** a：all u：user 端口号：netstat -tnulpa | grep *** t：tcp n：no u：user l：listen p：port a：all scp 命令 跨系统复制文件 scp -r 源文件路径 用户名@远程ip地址:目标路径 top 命令top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器 使用格式 top [-] [d] [p] [q] [c] [C] [S] [s] [n] 参数说明 d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 p 通过指定监控进程ID来仅仅监控某个进程的状态。 q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 S 指定累计模式 s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i 使top不显示任何闲置或者僵死进程。 c 显示整个命令行而不只是显示命令名 常用操作 top //每隔5秒显式所有进程的资源占用情况 top -d 2 //每隔2秒显式所有进程的资源占用情况 top -c //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名) top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况 top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数Reference [1] https://zh.wikipedia.org/wiki/Linux","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.alphabethub.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.alphabethub.com/tags/Linux/"}]},{"title":"写在2019的边上","slug":"daily-2020-0102","date":"2020-01-02T06:44:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2020/01/02/daily-2020-0102/","link":"","permalink":"https://blog.alphabethub.com/2020/01/02/daily-2020-0102/","excerpt":"","text":"写在2019的边上 只有初恋般的热情和宗教般的意志，人才有可能成就某种事业。路遥 2020年是将会是一个新的十年，前些天从票圈看到20世纪的20年代中国文坛的一些大师，有冰心，鲁迅、郭沫若、老舍、沈从文、巴金、矛盾等。嗯，这个20年代将会发生什么呢？我可以亲身经历并作为一个记录者。把时钟拨回10年之前2010年，那时候我刚刚读高二，没有看过外面的世界，活动半径基本是以家和学校为原点。我试图跳进记忆的洪流去寻找一些重要的时刻，但完全想不起当时光照进2010年的时候，我都在做些什么？有什么念念不忘的事？喜欢哪个女生？只能解释为年纪大了才对时间的流逝更有感触吧。若要说回20年前的2000年，我6岁，从时间的刻度上推算我应该在山西省一个自然村的小学开始了这漫长的求学生涯，那时到是有些许记忆，不过也大多是一些记忆碎片的拼凑。我觉得人生应该就是这样，若没有日复一日的记录，十年已经是一个很长的维度。你无法想起一些具体的事，只能寄思绪于时间的形色中，然后感叹岁月如此变迁，然后好好活着。感慨完毕，说点正事。 2019我的阅读书单 许三观卖血记 - 余华 大江东去（共三部）- 阿耐 白说 - 白岩松 1984 - 乔治·奥维尔 北京折叠 - 郝景芳 曾国藩家书 - 陈书凯 一生中最高兴的一天 - 路遥 路遥传（重新开启平凡的世界）- 厚夫 黄叶在秋风中飘落 - 路遥 你怎么也想不到 - 路遥 奇特的一生 - 格拉宁 / 侯焕闳 / 唐其慈 黑客与画家 - Paul Graham / 阮一峰译 边城 - 沈从文 月亮与六便士 - 威廉·萨默塞特·毛姆 / 徐淳刚译 乌合之众 - 勒庞 / 冯克利译 异类 - 马尔科姆·格拉德威尔 / 季丽娜译 最好的告别 - 阿图·葛文德 了不起的盖茨比 - 菲茨杰拉德 自在独行 - 贾平凹 青春 - 韩寒 Lonely Planet 孤独星球：山西（2014年版） 世界简史 - 赫伯特·乔治·威尔斯 如何阅读一本书 - 莫提默·J. 艾德勒 小王子 - 圣埃克苏佩里 围城 - 钱锺书 小岛经济学 - 彼得·希夫、安德鲁·希夫 走到人生边上 - 杨绛 2019年对我来说是收获的一年。考研结束之后，我给自己未来一年立的几个小小的flag，大致可以概括为多读点书，多锻炼身体，保持积极向上和进取的心态。这一年相比往年读的不多也不少，27本，大多数可以用来读书的时间还是都随着生活的硝烟飘散。2018年我跑了425公里，其中有两个半马。如果要为2019没有跑完 500km 找一个说服自己的理由的话（那就是跑步的时间都去游泳了吧？。体重从回到学校时候的80kg减到70kg左右，对于净身高181的我还可以了。英文单词打卡超额完成了100天(嗯，来年就立个300天的flag吧？)，要继续保持，因为没有功利的坚持是很难得的事情呀。 运动从2019/4/10回到学校后，体育运动搞的还不错，虽然跑步的flag打脸了，但是学会了蛙泳，自由泳，平均下来每周至少能光临两次游泳馆。还有羽毛球，篮球。基本每天都是要搞点才是能放心爬上床的。作为一命研究僧，不仅要把学术科研搞好，腰间盘也是不能凸出来的。要继续保持。 朋友2019年身边又有几个朋友结婚了，尤其作为伴郎去四川参加了桥老师的婚礼，发现一个问题是如果结婚晚的话，就要找不到好朋友做伴郎了。但人各有志，少年四方。不着急，慢慢来，先完善自己。离开北京之前，跟桥老师喝了大酒。在杭州和远哥喝了大酒。在潍坊和济南没和群哥喝成，有些遗憾。天各一方之后，若想常和好朋友坐在一个桌前把酒喝够，面红耳赤追忆往事与畅想未来，实在是一件奢侈的事情。更多时候的心事都要自己与自己说，这让我更加怀念冬天和夏天的西三旗。也有好的事情，比如开学后也遇到了几个志趣相投的伙伴，虽然年龄都比我小，但时间往前推一些，那些分开的朋友他们也从来不曾嫌我年龄小不是吗？2019年最后一天的晚上我给大家录了新年愿望，我在自己的新年愿望里说：“希望我们十年后还能在一起”。但我又何尝不知道人总是会分开的，而且还会越分越远呢。 学术2019 年的我的学术成果为零。希望 2020 不在这么丢人的写在自己的年终总结里。 如果要说这一年最大的收获是什么，那应该得是收到了心心念念的硕士录取通知书。去了灵隐还愿，去了潍坊访师，和317的兄弟在济南相聚。所以离开了北京，离开这座待了五年半的城市。去北京那年我19岁，鲜衣怒马，烈焰繁花。离开的时候25岁，漂泊五载，终觅心海。王小波曾在《万寿寺》的结尾里写到，人只拥有此生此世是不够的，他还应该拥有诗意的人生。 2020/01/02 太原","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"Maven 使用快速入门","slug":"java-maven-base","date":"2019-08-15T02:02:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/08/15/java-maven-base/","link":"","permalink":"https://blog.alphabethub.com/2019/08/15/java-maven-base/","excerpt":"","text":"概念Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven是跨平台的项目管理工具，主要服务于基于Java平台的项目构建，依赖管理和项目信息管理，方便jar包的管理且不需要上传至代码托管服务器。类似于iOS平台的 cocoapods 和 android 平台的 gradle。 安装 Maven for mac下载 Maven从 Maven 官方地址：http://maven.apache.org/download.cgi 下载最新版本 apache-maven-3.6.1-bin.tar.gz。bin:存放了 maven 的命令，比如我们前面用到的 mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包 将 Maven 添加到环境变量Maven 下载完毕后，解压到环境变量集合的位置，将其解压在 /usr/local/maven 目录下。然后在终端中，执行如下命令 open ~/.bash_profile 打开.bash_profile后，在里面添加如下的 maven 配置： # Maven configexport M3_HOME=/usr/local/maven/apache-maven-3.6.1export PATH=$M3_HOME/bin:$PATH 保存并关闭文件，然后执行以下命令使最新的环境变量生效： source ~/.bash_profile 测试 Maven 是否安装成功echo $M3_HOMEecho $PATH 若输出结果是类似以下的值则表明配置没有问题 /usr/local/maven/maven3.3.9/usr/local/maven/maven3.3.9/bin:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin:/Users/qiudengqiang/.nvm/versions/node/v9.11.1/bin:/usr/local/opt/openssl/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/Users/qiudengqiang/.rvm/bin::/usr/local/mysql/bin 接下来用maven 的命令查看 maven 版本，鉴定Maven 环境是否安装成功。 mvn -version 成功时输入以下日志 Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-05T03:00:29+08:00)Maven home: /usr/local/maven/apache-maven-3.6.1Java version: 1.8.0_66, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_66.jdk/Contents/Home/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: \"mac os x\", version: \"10.14.4\", arch: \"x86_64\", family: \"mac\" 至此，maven for mac 环境就配置好了。 Maven 仓库maven 的工作需要从仓库下载一些 jar 包，假如本地的项目 A、项目 B 等都会通过 maven 软件从远程仓库(可以理解为互联网上的仓库)下载 jar 包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 本地仓库本地仓库 :用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包， 优先从本地仓库查找仓库默认的目录在用户目录下：/Users/qiudengqiang/.m2/repository 远程仓库远程仓库:如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。 远程仓库可以在互联网内也可以在公司的局域网内 中央仓库在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 配置仓库路径在与bin同级目录的conf/settings.xml &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;&#x2F;.m2&#x2F;repository &lt;localRepository&gt;&#x2F;path&#x2F;to&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt; --&gt; 在终端中输入: mvn help:system maven默认会从上面的服务器(中央仓库) 下载 jar包到本地。 修改 settings.xml在mirrors中添加下面的内容，使用阿里云服务器下载jar包，因为国外的下载太慢了，把国外的注释不用 &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- 阿里云maven--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; Maven 项目结构ProjectName |-src | |-main | | |-java —— 存放项目的.java文件 | | |-resources —— 存放项目资源文件，如spring, hibernate配置文件 | |-test | |-java ——存放所有测试.java文件，如JUnit测试类 | |-resources —— 测试资源文件 |-target —— 目标文件输出位置例如.class、.jar、.war文件 |-pom.xml ——maven项目核心配置文件 「注」：如果是普通的 java 项目，那么就没有 webapp 目录。 Maven常用命令mvn compile完成编译操作执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。 mvn clean执行完毕后，会将target目录删除。 mvn test完成单元测试操作执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件） mvn package完成打包操作执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war（可以在配置文件中制定目标格式） mvn install执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用 mvn 组合命令mvn clean compilemvn clean testmvn clean packagemvn clean install Maven 的核心概念在平面几何中坐标（x,y）可以标识平面中唯一的一点。在maven中坐标就是为了定位一个唯一确定的jar包。我们需要找一个用来唯一标识一个构建的统一规范，拥有了统一规范，就可以把查找工作交给机器，Maven坐标主要组成(GAV) 确定一个jar在互联网位置。groupId：定义当前Maven组织名称artifactId：定义实际项目名称version：定义当前项目的当前版本 坐标的查找访问http://www.mvnrepository.com或者http://search.maven.org/网站假设搜索所spring core,如图然后点击sping,接点选择所需要的版本，就能看到所需要的jar包了 依赖管理scope 依赖范围 其中依赖范围scope 用来控制依赖和编译，测试，运行的 classpath 的关系. 主要的是三种依赖关系如下： compile ： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效 test ：测试依赖范围。只对于测试classpath有效 provided ：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api runtime :运行时提供。例如:jdbc驱动 依赖传递直接依赖和间接依赖test2 依赖 test1，test3依赖test2test2 直接依赖 test1，test3间接依赖test1当第二依赖的范围是compile的时候，依赖可以传递当第二直接依赖的范围是test的时候，依赖不会传递provided和runtime一般很少用 依赖冲突假如test1使用junit4.10依赖,并且scope是compile,那test2,test3都可以使用test1的junit4.10，因为传递下来了假如test2使用junit4.9依赖，那test3会使用【就近的一个依赖】，也就是使用junit4.9 可选依赖&lt;optional&gt; true/false&lt;optional&gt; 是否可选，也可以理解为是否向下传递。在依赖中添加optional选项决定此依赖是否向下传递，如果是true则不传递，如果是false就传递，默认为false 排除依赖exclusions可用于排除依赖,注意exclusions是写在dependency中 生命周期Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤。生命周期可以理解为构建工程的步骤。 在Maven中有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：Clean Lifecycle： 在进行真正的构建之前进行一些清理工作。Default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle： 生成项目报告，站点，发布站点。 Clean生命周期：清理项目pre-clean 执行一些需要在clean之前完成的工作clean 移除所有上一次构建生成的文件post-clean 执行一些需要在clean之后立刻完成的工作 也就是说，mvn clean 等同于 mvn pre-clean clean如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。 Default生命周期：构造项目Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段 validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR 。 pre-integration-test integration-test post-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享 运行任何一个阶段的时候，它前面的所有阶段都会被运行这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包，安装到本地仓库此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。 Maven 工程的运行进入 maven 工程目录(当前目录有 pom.xml 文件)，运行 tomcat:run 命令。根据上边的提示信息，通过浏览器访问:http://localhost:8080/maven-helloworld/ Maven 的概念模型 项目对象模型 (Project Object Model)一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、 插件目标等。 依赖管理系统(Dependency Management System)通过maven的依赖管理对项目所依赖的jar 包进行统一管理。比如:项目依赖 junit4.9，通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9，如下所示是 junit4.9 的依赖定义: &lt;!-- 依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围:单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一个项目生命周期(Project Lifecycle)使用 maven 完成项目的构建，项目构建包括:清理、编译、测试、部署等过程，maven 将这些过程规范为一个生命周期，如下所示是生命周期的各个阶段:maven 通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行 mvn compile 执行编译、执行 mvn clean 执行清理。 一组标准集合maven 将整个项目管理过程定义一组标准，比如:通过 maven 构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal)maven 管理项目生命周期过程都是基于插件完成的。 IDEA 开发 Maven 项目在通常在开发的环境中，我们都会使用流行的工具来开发项目。 IDEA 的 Maven 配置 IDEA 中创建一个 Maven 的 web 工程打开 idea，选择创建一个新工程，选择 idea 提供好的 maven 的 web 工程模板点击 Next 填写项目信息点击 Next，此处不做改动。点击 Next 选择项目所在目录点击 Finish 后开始创建工程，耐心等待，直到出现如下界面。手动添加 src/main/java 目录，如下图右键 main 文件夹-New-Directory,创建一个新的文件夹命名为 java点击 OK 后，在新的文件夹 java 上右键 Make Directory as Sources Root 创建一个 Servletsrc/java/main 创建了一个 Servlet，但报错要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet 的坐标，从而 导入它的 jar 在 pom.xml 文件添加坐标直接打开 hello_maven 工程的 pom.xml 文件，再添加坐标 添加 jar 包的坐标时，还可以指定这个 jar 包将来的作用范围。每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如:入门程序的 坐标定义如下: &lt;!--项目名称，定义为组织名+项目名，类似包名--&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;!-- 模块名称 --&gt; &lt;artifactId&gt;hello_maven&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging &gt; :打包类型 jar:执行 package 会打成 jar 包 war:执行 package 会打成 war 包pom :用于 maven 工程的继承，通常父工程设置为 pom 依赖范围A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括: compile:编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。provided:provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用， provided依 赖在编译和测试时需要，在运行时不需要，比如:servlet api 被 tomcat 容器提供。runtime:runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如:jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。test:test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如:junit。由于运行时不需要所以 test 范围依赖不会被打包。system:system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system 依赖不推荐使用。 在 maven-web 工程中测试各个 scop。 测试总结 默认引入 的 jar 包 ——- compile 【默认范围 可以不写】(编译、测试、运行 都有效 ) servlet-api 、jsp-api ——- provided (编译、测试 有效， 运行时无效 防止和 tomcat 下 jar 冲突)  jdbc 驱动 jar 包 —- runtime (测试、运行 有效 ) junit —– test (测试有效)依赖范围由强到弱的顺序是:compile&gt;provided&gt;runtime&gt;test 设置 JDK 编译版本本教程使用 jdk1.8，需要设置编译版本为 1.8，这里需要使用 maven 的插件来设置:在 pom.xml 中加入: &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 添加 tomcat7 插件在 pom 文件中添加如下内容此时点击 idea 最右侧 Maven Projects， 就可以看到我们新添加的 tomcat7 插件双击 tomcat7 插件下 tomcat7:run 命令直接运行项目也可以直接点击如图按钮，手动输入 tomc7:run 命令运行项目点击后弹出如下图窗口 Maven 工程运行调试端口占用处理重新执行 tomcat:run 命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误: 断点调试点击如图所示选项在弹出框中点击如图加号按钮找到 maven 选项在弹出窗口中填写如下信息完成后先 Apply 再 OK 结束配置后，可以在主界面找到我们刚才配置的操作名称。如上图红框选中的两个按钮，左侧是正常启动，右侧是 debug 启动。 pom 文件描述pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下: &lt;project &gt; :文件的根节点 .&lt;modelversion &gt; : pom.xml 使用的对象模型版本&lt;groupId &gt; :项目名称，一般写项目的域名&lt;artifactId &gt; :模块名称，子项目名或模块名称&lt;version &gt; :产品的版本号 .&lt;packaging &gt; :打包类型，一般有 jar、war、pom 等&lt;name &gt; :项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; :项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; :项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; :项目构建配置，配置编译、运行插件等。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"},{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"Maven","slug":"Maven","permalink":"https://blog.alphabethub.com/tags/Maven/"}]},{"title":"Redis 使用快速入门","slug":"web-redis-base","date":"2019-08-13T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/08/13/web-redis-base/","link":"","permalink":"https://blog.alphabethub.com/2019/08/13/web-redis-base/","excerpt":"","text":"概念redis是一款高性能的NOSQL系列的非关系型数据库 什么是NOSQLNoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL和关系型数据库比较 优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 小结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 什么是RedisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求，读的速度是110000次/s，写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset redis的应用场景• 缓存（数据查询、短连接、新闻内容、商品内容等等）• 聊天室的在线好友列表• 任务队列。（秒杀、抢购、12306等等）• 应用排行榜• 网站访问统计• 数据过期处理（可以精确到毫秒• 分布式集群架构中的session分离 下载安装官网：https://redis.io/download中文网：http://www.redis.net.cn/mac os下配置redis参考 操作 进入redis安装目录cd /usr/local/Cellar/redis/5.0.5/bin redis配置文件目录cd /usr/local/etc/redis.conf 启动redis服务redis-server 关闭redis服务control+c 或者 找到redis对应的pid服务 kill -9 Pid 杀死服务进程即可 可以在终端窗口使用 redis-cli 来操作redis服务 命令操作redis的数据结构：redis存储的是：key,value 格式的数据，其中key都是字符串，value有5种不同的数据结构value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string存储set key value 127.0.0.1:6379&gt; set username zhangsanOK 获取get key 127.0.0.1:6379&gt; get username\"zhangsan\" 删除del key 127.0.0.1:6379&gt; del age(integer) 1 哈希类型 hash存储hset key field value 127.0.0.1:6379&gt; hset myhash username lisi(integer) 1127.0.0.1:6379&gt; hset myhash password 123(integer) 1 获取 hget key field: 获取指定的field对应的值127.0.0.1:6379&gt; hget myhash username\"lisi\" hgetall key：获取所有的field和value127.0.0.1:6379&gt; hgetall myhash1) \"username\"2) \"lisi\"3) \"password\"4) \"123\" 删除hdel key field 127.0.0.1:6379&gt; hdel myhash username(integer) 1 列表类型 list可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加 lpush key value: 将元素加入列表左表 rpush key value: 将元素加入列表右边127.0.0.1:6379&gt; lpush myList a(integer) 1127.0.0.1:6379&gt; lpush myList b(integer) 2127.0.0.1:6379&gt; rpush myList c(integer) 3 获取 lrange key start end ：范围获取127.0.0.1:6379&gt; lrange myList 0 -11) \"b\"2) \"a\"3) \"c\" 删除 lpop key ： 删除列表最左边的元素，并将元素返回 rpop key ： 删除列表最右边的元素，并将元素返回 集合类型 set不允许重复元素 存储sadd key value 127.0.0.1:6379&gt; sadd myset a(integer) 1127.0.0.1:6379&gt; sadd myset a(integer) 0 获取smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset1) \"a\" 删除srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a(integer) 1 有序集合类型 sortedset不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan(integer) 1127.0.0.1:6379&gt; zadd mysort 50 lisi(integer) 1127.0.0.1:6379&gt; zadd mysort 80 wangwu(integer) 1 获取zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -11) \"lisi\"2) \"zhangsan\"3) \"wangwu\"127.0.0.1:6379&gt; zrange mysort 0 -1 withscores1) \"zhangsan\"2) \"60\"3) \"wangwu\"4) \"80\"5) \"lisi\"6) \"500\" 删除zrem key value 127.0.0.1:6379&gt; zrem mysort lisi(integer) 1 通用命令 keys * : 查询所有的键 type key : 获取键对应的value的类型 del key : 删除指定的key value 持久化机制redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB默认方式，不需要进行配置，默认就使用这种机制；在一定的间隔时间中，检测key的变化情况，然后持久化数据 1.打开/usr/local/etc 编辑redis.conf文件 # after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器并制定配置文件redis-server /usr/local/etc/redis.confAOF日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据打开/usr/local/etc 编辑redis.conf文件appendonly no（关闭aof） --&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 使用Java操作redisJedis: 一款java操作redis数据库的工具.使用步骤 下载jedis的jar包 使用//1. 获取连接Jedis jedis = new Jedis(\"localhost\",6379);//2. 操作jedis.set(\"username\",\"zhangsan\");//3. 关闭连接jedis.close(); Jedis操作各种redis中的数据结构字符串类型 stringset/get //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作//存储jedis.set(\"username\",\"zhangsan\");//获取String username = jedis.get(\"username\");System.out.println(username);//可以使用setex()方法存储可以指定过期时间的 key valuejedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对//3. 关闭连接jedis.close(); 哈希类型 hash map格式hset/hget/hgetAll //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作// 存储hashjedis.hset(\"user\",\"name\",\"lisi\");jedis.hset(\"user\",\"age\",\"23\");jedis.hset(\"user\",\"gender\",\"female\");// 获取hashString name = jedis.hget(\"user\", \"name\");System.out.println(name);// 获取hash的所有map中的数据Map&lt;String, String&gt; user = jedis.hgetAll(\"user\");// keysetSet&lt;String&gt; keySet = user.keySet();for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + \":\" + value);&#125;//3. 关闭连接jedis.close(); 列表类型 listlinkedlist格式。支持重复元素lpush / rpushlpop / rpoplrange start end: 范围获取 //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作// list 存储jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存// list 范围获取List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1);System.out.println(mylist);// list 弹出String element1 = jedis.lpop(\"mylist\");//cSystem.out.println(element1);String element2 = jedis.rpop(\"mylist\");//cSystem.out.println(element2);// list 范围获取List&lt;String&gt; mylist2 = jedis.lrange(\"mylist\", 0, -1);System.out.println(mylist2);//3. 关闭连接jedis.close(); 集合类型 set不允许重复元素saddsmembers:获取所有元素 //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作// set 存储jedis.sadd(\"myset\",\"java\",\"php\",\"c++\");// set 获取Set&lt;String&gt; myset = jedis.smembers(\"myset\");System.out.println(myset);//3. 关闭连接jedis.close(); 有序集合类型 sortedset不允许重复元素，且元素有顺序zaddzrange //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作// sortedset 存储jedis.zadd(\"mysortedset\",3,\"亚瑟\");jedis.zadd(\"mysortedset\",30,\"后裔\");jedis.zadd(\"mysortedset\",55,\"孙悟空\");// sortedset 获取Set&lt;String&gt; mysortedset = jedis.zrange(\"mysortedset\", 0, -1);System.out.println(mysortedset);//3. 关闭连接jedis.close(); Jedis连接池 JedisPool使用 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);//1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,\"localhost\",6379);//2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set(\"hehe\",\"heihei\");//4. 关闭 归还到连接池中jedis.close(); 连接池工具类public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 小结 「注意」：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行增删改的相关操作，需要将redis缓存数据清空，再次存入 在service层对应的增删改方法中，将redis数据删除。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://blog.alphabethub.com/categories/DataBase/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.alphabethub.com/tags/Redis/"},{"name":"DataBase","slug":"DataBase","permalink":"https://blog.alphabethub.com/tags/DataBase/"}]},{"title":"jQuery & Ajax 快速入门","slug":"web-jquery-ajax-base","date":"2019-08-12T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/08/12/web-jquery-ajax-base/","link":"","permalink":"https://blog.alphabethub.com/2019/08/12/web-jquery-ajax-base/","excerpt":"","text":"jQueryjQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 JavaScript 回顾JavaScript核心 — JavaScript 语言的核心，定义了语言中基本语法DOM — Document Object Model 文档对象模型 w3cBOM — Broswer Object Model 浏览器对象模型 jQuery 基础快速入门 下载JQuery目前jQuery有三个大版本：1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）jquery-xxx.js 与 jquery-xxx.min.js区别：1. jquery-xxx.js：开发版本。给程序员使用，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 引入jQuery直接将 jQuery 核心 js 文件加入到工程，一般放置在 web 应用的非 WEB-INF 文件夹，在 html 页面中使用以下代码引入就可以在这个页面中使用 jQuery 了。&lt;script src=\"jquery.js文件所在的位置\"/&gt; 使用var div1 = $(\"#div1\");alert(div1.html()); 选择器基础选择器 #id 用法:$(&quot;#myDiv&quot;) ; 返回值 : 单个元素的组成的集合 说明: 这个就是直接选择 html 中的id=&quot;myDiv&quot; Element 用法: $(&quot;div&quot;) ; 返回值 : 集合元素 说明: element 的英文翻译过来是「元素」，所以 element 其实就是 html 已经定义的标签元素，例如 div， input， a等等 class 用法: $(&quot;.myClass&quot;) ; 返回值 : 集合元素 说明: 这个标签是直接选择 html 代码中class=&quot;myClass&quot;的元素或元素组（因为在同一html页面中class是可以存在多个同样值的） * 用法: $(&quot;*&quot;) ; 返回值 : 集合元素 说明: 匹配所有元素，多用于结合上下文来搜索 selector1, selector2, selectorN 用法: $(&quot;div,span,p.myClass&quot;); 返回值 : 集合元素 说明: 将每一个选择器匹配到的元素合并后一起返回。可以指定任意多个选择器， 并将匹配到的元素合并到一个结果内。其中p.myClass是表示匹配元素 层次选择器 ancestor descendant 用法: $(&quot;form input&quot;) ; 返回值 : 集合元素 说明: 在给定的祖先元素下匹配所有后代元素。这个要和下面的parent &gt; child区分开. parent &gt; child 用法: $(&quot;form &gt; input&quot;) ; 返回值 : 集合元素 说明: 在给定的父元素下匹配所有子元素。注意:要区分好后代元素与子元素 prev + next 用法: $(&quot;label + input&quot;) ; 返回值 : 集合元素 说明: 匹配所有紧接在 prev 元素后的 next 元素 prev ~ siblings 用法: $(&quot;form ~ input&quot;) ; 返回值 : 集合元素 说明: 匹配 prev 元素之后的所有 siblings 元素。 注意: 是匹配之后的元素，不包含该元素在内，并且 siblings 匹配的是和 prev 同辈的元素，其后辈元素不被匹配。 基本操作 事件绑定 //1.获取b1按钮$(\"#b1\").click(function()&#123; alert(\"abc\");&#125;); 入口函数 //以下方法等同于window.onload$(function () &#123;&#125;); [注意]：window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 样式控制：css方法// $(\"#div1\").css(\"background-color\",\"red\");$(\"#div1\").css(\"backgroundColor\",\"pink\"); 过滤器基础过滤器 :first 用法: $(&quot;tr:first&quot;) ; 返回值: 单个元素的组成的集合 说明: 匹配找到的第一个元素 :last 用法: $(&quot;tr:last&quot;); 返回值 集合元素 说明: 匹配找到的最后一个元素，与 :first 相对应 :not(selector) 用法: $(&quot;input:not(:checked)&quot;); 返回值: 集合元素 说明: 去除所有与给定选择器匹配的元素。有点类似于「非」，意思是没有被选中的 input (当 input 的type=&quot;checkbox&quot;). :even 用法: $(&quot;tr:even&quot;) ; 返回值: 集合元素 说明: 匹配所有索引值为偶数的元素，从 0 开始计数。js的数组都是从0开始计数的。例如要选择table中的行，因为是从0开始计数，所以 table 中的第一个 tr 就为偶数0. :odd用法: $(&quot;tr:odd&quot;); 返回值 : 集合元素说明: 匹配所有索引值为奇数的元素，和:even对应，从 0 开始计数. :eq(index) 用法: $(&quot;tr:eq(0)&quot;) ; 返回值: 集合元素 说明: 匹配一个给定索引值的元素.eq(0)就是获取第一个 tr 元素。括号里面的是索引值，不是元素排列数 :gt(index) 用法: $(&quot;tr:gt(0)&quot;); 返回值 : 集合元素 说明: 匹配所有大于给定索引值的元素. :lt(index) 用法: $(&quot;tr:lt(2)&quot;) ; 返回值 : 集合元素 说明: 匹配所有小于给定索引值的元素. :header(固定写法) 用法: $(&quot;:header&quot;).css(&quot;background&quot;， “#EEE&quot;); 返回值 : 集合元素 说明: 获得标题（h1~h6）元素，固定写法 :animated(固定写法) ; 返回值 : 集合元素说明: 匹配所有正在执行动画效果的元素 内容过滤器 :contains(text) 用法: $(&quot;div:contains(&#39;John&#39;)&quot;) ; 返回值 : 集合元素 说明: 匹配包含给定文本的元素。这个选择器比较有用，当我们要选择的不是dom标签元素时，它就派上了用场了，它的作用是查找被标签「围」起来的文本内容是否符合指定的内容 :empty 用法: $(&quot;td:empty&quot;) ; 返回值 : 集合元素 说明: 匹配所有不包含子元素或者文本的空元素 :has(selector) 用法: $(&quot;div:has(p)&quot;).addClass(&quot;test&quot;) ; 返回值 : 集合元素 说明: 匹配含有选择器所匹配的元素的元素。这个解释需要好好琢磨，但是一旦看了使用的例子就完全清楚了，就是给所有包含 p 元素的 div标签加上class=&quot;test&quot; :parent 用法:$(&quot;td:parent&quot;) ; 返回值 : 集合元素 说明: 匹配含有子元素或者文本的元素。注意:这里是:parent，可不是.parent。与上面的:empty形成反义 可见度过滤器 :hidden 用法: $(&quot;tr:hidden&quot;) ; 返回值 : 集合元素 说明: 匹配所有的不可见元素，input 元素的 type 属性为 hidden 的话也会被匹配到；意思是 CSS 中display:none和input type=&quot;hidden&quot;的都会被匹配到。同样，要彻底分清楚冒号:点号.和逗号，的区别 :visible 用法: $(&quot;tr:visible&quot;); 返回值 : 集合元素 说明: 匹配所有的可见元素 属性过滤器 [attribute] 用法: $(&quot;div[id]&quot;) ; 返回值 : 集合元素 说明: 匹配包含给定属性的元素。例如：选取所有带 id 属性的 div 标签 [attribute=value] 用法: $(&quot;input[name=&#39;newsletter&#39;]“).attr(&quot;checked&quot;， true); ; 返回值 : 集合元素 说明: 匹配给定的属性是某个特定值的元素。例如：选取所有 name 属性是 newsletter 的 input 元素. [attribute!=value] 用法: $(&quot;input[name!=&#39;newsletter&#39;]&quot;).attr(&quot;checked&quot;， true); ; 返回值 : 集合元素 说明: 匹配所有不含有指定的属性，或者属性不等于特定值的元素。此选择器等价于:not([attr=value])，要匹配含有特定属性但不等于特定值的元素，请使用[attr]:not([attr=value])。之前看到的 :not 派上了用场 [attribute^=value] 用法: $(&quot;input[name^=&#39;news&#39;]&quot;) ; 返回值 : 集合元素 说明: 匹配给定的属性是以某些值开始的元素 [attribute$=value] 用法: $(&quot;input[name$=&#39;letter&#39;]&quot;) ; 返回值 : 集合元素 说明: 匹配给定的属性是以某些值结尾的元素 [attribute*=value] 用法: $(&quot;input[name*=&#39;man&#39;]&quot;) ; 返回值 : 集合元素 说明: 匹配给定的属性是以包含某些值的元素 [attributeFilter1][attributeFilter2][attributeFilterN] 用法: $(&quot;input[id][name$=&#39;man&#39;]&quot;) ; 返回值 : 集合元素 说明: 复合属性选择器，需要同时满足多个条件时使用；又是一个组合，这种情况实际使用的时候很常用。这个例子中选择的是所有含有 id 属性，并且它的 name 属性是以 man 结尾的元素。 子元素过滤器 :nth-child(index/even/odd/equation) 用法: $(&quot;ul li:nth-child(2)&quot;) 返回值 : 集合元素 说明: 匹配其父元素下的第N个子或奇偶元素。这个选择器和之前说的基础过滤(Basic Filters)中的 eq() 有些类似，不同的地方就是：前者是从 0 开始，后者是从 1 开始。 :first-child 用法: $(&quot;ul li:first-child&quot;); 返回值 : 集合元素 说明: 匹配第一个子元素；:first 只匹配一个元素，而此选择符将为每个父元素匹配一个子元素，这里需要特别的记忆下区别 :last-child 用法: $(&quot;ul li:last-child&quot;) ; 返回值 : 集合元素 说明: 匹配最后一个子元素；:last只匹配一个元素，而此选择符将为每个父元素匹配一个子元素 :only-child 用法: $(&quot;ul li:only-child&quot;) ; 返回值 : 集合元素 说明: 如果某个元素是父元素中唯一的子元素，那将会被匹配；如果父元素中含有其他元素，那将不会被匹配；意思就是:只有一个子元素的才会被匹配 表单对象属性过滤器 :enabled 用法: $(&quot;input:enabled&quot;) ; 返回值 : 集合元素 说明: 匹配所有可用元素；意思是查找所有input中不带有disabled=&quot;disabled&quot;的input；不为disabled，当然就为enabled :disabled 用法: $(&quot;input:disabled&quot;) ; 返回值 : 集合元素 说明: 匹配所有不可用元素。与上面的那个是相对应的 :checked 用法: $(&quot;input:checked&quot;) ; 返回值 : 集合元素 说明: 匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option) :selected 用法: $(&quot;select option:selected&quot;) ; 返回值 : 集合元素 说明: 匹配所有选中的option元素 表单过滤器 :input 用法:$(&quot;:input&quot;) ; 返回值 : 集合元素 说明:匹配所有 input， textarea， select 和 button 元素 :text 用法: $(&quot;:text&quot;) ; 返回值 : 集合元素 说明: 匹配所有的单行文本框 :password 用法: $(&quot;:password&quot;) ; 返回值 : 集合元素 说明: 匹配所有密码框 :radio 用法: $(&quot;:radio&quot;) ; 返回值 : 集合元素 说明: 匹配所有单选按钮 :checkbox 用法: $(&quot;:checkbox&quot;) ; 返回值 : 集合元素 说明: 匹配所有复选框 :submit 用法: $(&quot;:submit&quot;) ; 返回值 : 集合元素 说明: 匹配所有提交按钮 DOM 操作外部插入after(content) :在每个匹配的元素之后插入内容before(content):在每个匹配的元素之前插入内容insertAfter(content):把所有匹配的元素插入到另一个、指定的元素元素集合的后面insertBefore(content) :把所有匹配的元素插入到另一个、指定的元素元素集合的前面 内部插入append(content) :向每个匹配的元素的内部的结尾处追加内容appendTo(content) :将每个匹配的元素追加到指定的元素中的内部结尾处prepend(content):向每个匹配的元素的内部的开始处插入内容prependTo(content) :将每个匹配的元素插入到指定的元素内部的开始处 查找节点选择器/过滤器 可以实现查找节点attr(&quot;name&quot;)attr(&quot;name&quot;，&quot;value&quot;)removeAttr(&quot;name&quot;) 创建节点使用 jQuery 的工厂函数 $():$(html); 会根据传入的 html 标记字符串创建一个 DOM 对象， 并把这个 DOM 对象包装成一个 jQuery 对象返回 删除节点remove(): 从 DOM 中删除所有匹配的元素， 传入的参数用于根据 jQuery 表达式来筛选元素；当某个节点用 remove() 方法删除后， 该节点所包含的所有后代节点将被同时删，这个方法的返回值是一个指向已被删除的节点的引用empty(): 清空节点 – 清空元素中的所有后代节点(不包含属性节点) 内容操作 html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 val()： 获取/设置元素的value属性值 属性操作 通用属性操作 attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 [注意]：attr 和 prop 区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 toggleClass(&quot;one&quot;): 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在 class=”one”，则添加 css():获取css样式 JQuery对象和JS对象区别与转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用的。 两者相互转换 jq – &gt; js : jq对象[索引] 或者 jq对象.get(索引) js – &gt; jq : $(js对象) jQuery 高级动画三种方式显示和隐藏元素动画 默认显示和隐藏方式 show([speed,[easing],[fn]]) 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历 javascript的遍历方式for(初始化值;循环结束条件;步长) jquery的遍历方式 jq对象.each(callback)1. 语法： jquery对象.each(function(index,element)&#123;&#125;); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of jquery 3.0 版本之后提供的方式for(元素对象 of 容器对象) 事件绑定 jquery标准的绑定方式jq对象.事件方法(回调函数)；注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定jq对象.on(&quot;事件名称&quot;,回调函数)jq对象.off(&quot;事件名称&quot;) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：togglejq对象.toggle(fn1,fn2...) 当单击jq对象对应的组件后，会执行fn1；第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除，jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; 插件增强JQuery的功能，实现方式如下： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) $.extend(object) 增强JQeury对象自身的功能 $/jQuery Ajax AJAX 即“Asynchronous JavaScript and XML”（异步JavaScript和XML)，AJAX 并非缩写词，而是由Jesse James Gaiiett创造的名词，是指一种创建交互式网页应用的网页开发技术。WEB2.0 概述使用javascript向服务器提出请求并处理响应而不阻塞用户，核心对象 XMLHTTPRequest。通过这个对象，JavaScript 可在不重载页面的情况与Web服务器交换数据。AJAX 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。AJAX 可使因特网应用程序更小、更快、更友好。 XMLHttpRequest 对象初始化为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： //创建XMLHttpRequest对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(\"Msxml2.XMLHTTP\"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp;&#125; XMLHttpRequest对象方法 服务器端向客户端进行响应(注册监听)xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200||xhr.status==304)&#123; var data = xhr.responseText; &#125; &#125;&#125; readyState： 属性表示Ajax请求的当前状态。它的值用数字代表。 0 代表未初始化。 还没有调用 open 方法 1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用 2 代表已加载完毕。send 已被调用。请求已经开始 3 代表交互中。服务器正在发送响应 4 代表完成。响应发送完毕 xhr.status： 常用状态码及其含义： 404 没找到页面(not found) 403 禁止访问(forbidden) 500 内部服务器出错(internal service error) 200 一切正常(ok) 304 没有被修改(not modified)（服务器返回304状态，表示源文件没有被修改) xhr.responseText： 服务器发回的响应结果，字符串xhr.responseXML： 服务器返回的响应结果，XML对象 客户端与服务器端建立连接使用的是 XMLHttpRequest 对象的 open(method, url, asynch)方法 method：请求类型，类似 “GET”或”POST”的字符串。 url：路径字符串，指向你所请求的服务器上的那个文件。可以是绝对路径或相对路径。 asynch：表示请求是否要异步传输，默认值为true(异步)。xhr.open(\"GET\",\"../testServlet?timeStamp=\"+new Date().getTime()+\"&amp;c=19\",true); 客户端向服务器端发送请求使用的是 XMLHttpRequest 对象的send()方法 如果请求类型是GET方式的话，使用send()方法发送请求数据，服务器端接收不到 该步骤不能被省略，只能写成xhr.send(null); GET方式xhr.send(null); POST方式如果请求类型是POST的话，需要设置请求首部信息 xhr.setRequestHeader(\"Content-Type\",\"application/json\");xhr.send(\"a=7&amp;b=8\"); jQuery实现Ajax$.ajax() 语法：$.ajax({键值对});//使用$.ajax()发送异步请求$.ajax(&#123; url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(\"出错啦...\") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式&#125;); $.get() 语法：$.get(url, [data], [callback], [type]) 参数：* url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 $.post() 语法：$.post(url, [data], [callback], [type]) 参数：* url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/categories/Web/"}],"tags":[{"name":"Web，jQuery，Ajax","slug":"Web，jQuery，Ajax","permalink":"https://blog.alphabethub.com/tags/Web%EF%BC%8CjQuery%EF%BC%8CAjax/"}]},{"title":"JSP/EL/JSTL 快速入门","slug":"web-jsp-el-jstl-base","date":"2019-07-08T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/07/08/web-jsp-el-jstl-base/","link":"","permalink":"https://blog.alphabethub.com/2019/07/08/web-jsp-el-jstl-base/","excerpt":"","text":"JSPJSP(JavaServer Pages) 是一种动态页面技术，它实现了Html语法中的java扩展（以 &lt;%, %&gt;形式）。JSP 与 Servlet 一样，是在服务器端执行的。通常返回给客户端的就是一个 HTML 文本，因此客户端只要有浏览器就能浏览。 指令作用用于配置 JSP 页面，导入资源文件 格式&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2%&gt; 分类 page：用于标识和配置 JSP 页面 contentType：类似于response.setContentType()，用于设置响应体的mime类型及字符集，设置当前 JSP 页面编码 import：导入包 errorPage：当前页面发生异常后，会跳转到指定的错误页面，例如 404 等 isErrorPage：标识当前是否是错误页面，参数：true（可以使用内置对象 exception），页面默认值是 false session：用于指定当前页面是否可以使用session pageEncoding：解决乱码问题(在低级工具中声明) include：包含页面，导入其他页面资源文件：&lt;%@ include file=”index.jsp”%&gt; taglib：用于导入第三方资源&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot;%&gt; 其中prefix支持自定义 其他指令 JSP脚本表达式 ： &lt;%= java表达式 %&gt; JSP脚本片断 ： &lt;% 任意多的java语句 %&gt; JSP声明 ： &lt;%! java代码 %&gt; 注释html注释`&lt;!-- --&gt;`:只能注释 html 代码片段jsp注释推荐使用：&lt;%-- --%&gt;：可以注释所有 内置对象 在jsp页面中不需要创建，直接使用的对象, 一共有9个：变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 详解 out相当于response.getWriter()获取到的输入流，内置单独的缓冲区[ buffer=”none | 8kb | sizekb” ] out隐式对象所使用的缓冲区的大小[ autoFlush=”true | false” ] out隐式对象是否自动刷新缓冲区，默认为true，不需要更改 pageContext代表当前 JSP 的运行环境生命周期: 随着 JSP 页面打开而创建,随着关闭而销毁.用处: 在整个 JSP 页面中共享数据 可以作为入口对象获取其他八大隐示对象的引用 getException getPage getRequest getRespons getServletConfig getServletContext 方法返回 application 隐式对象 getSession getOut ___返回的都是本类型的隐示对象 首先是一个域对象，作为入口操作四大作用域中的数据 ServletContext(application域) &gt; Session(session域) &gt; request(request域) &gt;pageContext(page域)//用来操作page域中的属性public void setAttribute(java.lang.String?name,java.lang.Object?value)public java.lang.Object?getAttribute(java.lang.String?name)public void?removeAttribute(java.lang.String?name)//用来操作四大作用域中任意域中的属性public void setAttribute(java.lang.String?name, java.lang.Object?value,int?scope)public java.lang.Object?getAttribute(java.lang.String?name,int?scope)public void?removeAttribute(java.lang.String?name,int?scope)PageContext.APPLICATION_SCOPEPageContext.SESSION_SCOPEPageContext.REQUEST_SCOPEPageContext.PAGE_SCOPE 小结： 四大作用域什么时候用: 如果一个数据只在当前jsp页面中使用，存入page域。 如果一个数据，在Servlet中处理好后，请求转发到其他serlvet或jsp使用此数据，放入request域。 如果一个数据，我当前要用，过一会我自己还要用。存入session。 如果一个数据，我当前要用，过一会其他人也要用。存入application域。 findAttribute: (此方法用来查找各个域中的属性) 从最小的域开始向最大的域搜索(page,request,session,application),找到就则返回该值,找完四大作用域找不到则返回null 提交了快捷方法,实现请求转发和请求包含pageContext.forward(&quot;&quot;); pageContext.include(&quot;&quot;); ELEL(Expression Language) 表达式语言,用于获取数据、执行运算、操作web中隐含对象、调用java函数 语法${标识符}EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从 page 、 request 、 session 、application 四个域 中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意：不是null，而是空字符串）。「经验」：只要标识符中没有逻辑错误，语法错误，就不会报错，${a}的结果是个“”字符串。 运算符 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为 null 或者长度是否为 0 ${empty list}:判断字符串、集合、数组对象是否为 null 或者长度为 0 ${not empty str}:表示判断字符串、集合、数组对象是否不为 null 并且 长度 &gt; 0 获取值EL 表达式只能从域对象中获取值 语法 ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） [举例]：在request域中存储了name=zhangsan [获取]：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List 集合、Map 集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的 getter 方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[&quot;key名称&quot;]} 调用java方法 调用的方法必须是静态方法 在开发中一般是直接使用(taglib)指令导入相关的包,j2ee5.0以上已经内置 隐式对象EL 表达式中有11个内置对象：不需要定义直接在 EL 中可以直接使用 「注意」 只能用来获取集合数组中的数据不能用来遍历 只能用来获取数据不能用来设置数据 小结getParameter 和 getAttribute 区别 ？=====================================================getParameter 获得 HTTP中请求参数的值 getAttribute 获得服务器端各种数据范围的值 request.getAttribute 获得request数据范围的值 值在服务器端通过 request.setAttribute 保存的 getParameter 获得客户端提交的数据，getAttribute 服务器内部传递的数据 getParameter() 与 getParamValues() 的区别 ?=====================================================param 、paramValues 用户获得请求参数的值${param.name} ==== request.getParameter(“name”);${paramValues.name} ===== request.getParameterValues(“name”); getHeader() 与 getHeaderValues() 区别 ?=====================================================header、headerValues 获得请求头信息的数据${header[&quot;user-agent&quot;]} ========== request.getHeader(“user-agent”);${headerValues[&quot;user-agent&quot;]} ============= request.getHeaders(“user-agent”); cookie=====================================================用来在开发中快速获得 cookie 的值 ——- 是一个Map&lt;String,Cookie&gt; //保持的value是对象${cookie.name.value} 获得指定名称的cookie的value值 initParam=====================================================用来快速读取 ServletContext 的全局初始化参数${initParam.name} ===================== getServletContext().getInitParameter(“name”); 配置全局参数 最常使用=====================================================cookie ———– ${cookie.name.value} 这里 name 是 cookie 的 name 值pageContext ————- ${pageContext.request.contextPath} ==== pageContext.getRequest().getContextPath() 返回 /virtual-directory &lt;!-- 编写一个链接 --&gt;&lt;a href=\"/virtual-directory/el/1.jsp\"&gt;link&lt;/a&gt;&lt;!-- 使用EL 获得工程名 --&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/el/1.jsp\"&gt;link&lt;/a&gt; 快速获得ip ： ${pageContext.request.remoteAddr}注册信息的回调 ： ${param.username} ，因为提交的信息还保存在request里 注意JSP 默认支持 EL 表达式的。如果要忽略 EL 表达式则使用以下方法： JSP 中 page 指令中：isELIgnored=&quot;true&quot;忽略当前jsp页面中所有的 EL 表达式 \\${表达式} ：忽略当前这个el表达式 JSTLJSTL (JavaServer Pages Tag Library) 是 JSP 标准标签库，是由 Apache 组织提供的开源的免费的 JSP &lt;标签&gt;，用于简化和替换 JSP 页面上的Java 代码 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot;%&gt; 使用标签 常用标签&lt;c:out&gt; 标签用于输出一段文本内容到pageContext对象当前保存的out对象中。 &lt;c:set&gt;标签用于把某一个对象存在指定的域范围内，或者设置 Web 域中的 java.util.Map 类型的属性对象或 JavaBean 类型的属性对象的属性。 &lt;c:remove&gt;标签用于删除各种 Web 域中的属性 &lt;c:catch&gt;标签用于捕获嵌套在标签体中的内容抛出的异常，其语法格式如下： &lt;c:catch [var=\"varName\"]&gt;nested actions&lt;/c:catch&gt; &lt;c:if test=“”&gt; 标签可以构造简单的if-then结构的条件表达式 &lt;c:if test=\"条件,可以写el表达式\"&gt;&lt;/c:if&gt; &lt;c:choose&gt; 标签用于指定多个条件选择的组合边界，它必须与&lt;c:when&gt;和&lt;c:otherwise&gt;标签一起使用。 使用&lt;c:choose&gt;，&lt;c:when&gt;和&lt;c:otherwise&gt;三个标签，可以构造类似 if-else if-else 的复杂条件判断结构。 &lt;c:forEach&gt; 标签用于对一个集合对象中的元素进行循环迭代操作，或者按指定的次数重复迭代执行标签体中的内容。语法格式如下： //类似于java中的fori&lt;c:forEach begin=\"1\" end=\"length\" var=\"i\"&gt;&lt;/c:forEach&gt;//类似于java中的foreach&lt;c:forEach items=\"strs\" var=\"str\" varStatus=\"s\"&gt;&lt;/c:forEach&gt; &lt;c:forTokens&gt;用来浏览一字符串中所有的成员，其成员是由定义符号所分隔的 &lt;c:param&gt;标签 在JSP页面进行URL的相关操作时，经常要在 URL 地址后面附加一些参数。 &lt;c:param&gt;标签可以嵌套在&lt;c:import&gt;、&lt;c:url&gt;或&lt;c:redirect&gt;标签内，为这些标签所使用的URL地址附加参数。 &lt;c:import&gt; 标签,实现 include 操作 &lt;c:url&gt; 标签用于在 JSP 页面中构造一个 URL 地址，其主要目的是实现 URL 重写。URL 重写就是将会话标识号以参数形式附加在 URL 地址后面 &lt;c:redirect&gt; 标签用于实现请求重定向","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"JSP","slug":"JSP","permalink":"https://blog.alphabethub.com/tags/JSP/"},{"name":"EL","slug":"EL","permalink":"https://blog.alphabethub.com/tags/EL/"},{"name":"JSTL","slug":"JSTL","permalink":"https://blog.alphabethub.com/tags/JSTL/"}]},{"title":"Cookie & Session 基础","slug":"web-cookie-session","date":"2019-07-02T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/07/02/web-cookie-session/","link":"","permalink":"https://blog.alphabethub.com/2019/07/02/web-cookie-session/","excerpt":"","text":"会话技术为了实现某一个需求，浏览器和服务器之间会产生多次的请求和响应；从打开浏览器访问服务器开始，到访问服务器结束关闭浏览器，之间的多次请求和响应称为：「浏览器和服务器之间的一次会话」「一次会话」：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能在一次会话的范围内的多次请求间，共享数据 方式 客户端会话技术：Cookie 服务器端会话技术：Session CookieCookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据(可以叫做浏览器缓存） 概念客户端会话技术，将数据保存到客户端 快速入门 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理基于响应头set-cookie和请求头cookie实现 方法 new cookie(“key”,”value”); setPath(path); setMaxAge(time); response.addCookie(cookie); 删除cookie的时候只需要覆盖同路径，同名，只要存活时间(serMaxAge(0))设置为0就可以 一次可不可以发送多个cookie?可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置 cookie 的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将 path 设置为/ 不同的 tomcat 服务器间 cookie 共享问题？ setDomain(String path)：如果设置一级域名相同，那么多个服务器之间 cookie 可以共享 setDomain(&quot;.baidu.com&quot;)：那么tieba.baidu.com和news.baidu.com中 cookie 可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用 cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 eg： 记住上一次访问时间 Session服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 获取HttpSession对象：HttpSession session = request.getSession(); 使用HttpSession对象：Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 生命周期 调用request.getSession();方法时开始创建 默认是30分钟用户无操作自动销毁 可以手动销毁 三种销毁Session对象情况 不正常关闭服务(正常关闭服务器Session信息会被序列化到硬盘中 保存tomcat/work目录) session 对象调用invalidate() 手动销毁Session对象 session 默认失效时间 30分钟（连续不使用Session对象时间）//选择性配置修改，在tomcat/conf/web.xml 配置&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 实现原理Session的实现是依赖于Cookie的 细节当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个？ 默认情况下，不是同一个。 如果需要相同，则可以创建 Cookie,键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。Cookie c = new Cookie(\"JSESSIONID\",session.getId());c.setMaxAge(60*60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 解决浏览器禁止cookie的情况 (了解即可)浏览器无法保存cookie中jsession id ，无法完成Session追踪，通过程序重写URL(携带session的URL) 小结：session与Cookie的区别 session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"Cookie","slug":"Cookie","permalink":"https://blog.alphabethub.com/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://blog.alphabethub.com/tags/Session/"}]},{"title":"JavaScript 快速入门","slug":"web-javascript-base","date":"2019-06-08T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/06/08/web-javascript-base/","link":"","permalink":"https://blog.alphabethub.com/2019/06/08/web-javascript-base/","excerpt":"","text":"JavaScript概念：运行在客户端浏览器中的一门客户端脚本语言。每一个浏览器都有 JavaScript 的解析引擎，不需要编译，直接就可以被浏览器解析执行。功能：可以来增强用户和 html 页面的交互过程，可以来控制 html 元素，让页面有一些动态的效果，增强用户的体验。 JavaScript 发展史 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C- - ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出jscript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 「注」：JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) ECMAScript客户端脚本语言的标准 基本语法与 html 结合方式 内部js： 定义&lt;script&gt; 标签体内容就是js代码 外部js： 定义&lt;script&gt; 通过src属性引入外部的js文件 注意： &lt;script&gt; 可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 &lt;script&gt; 可以定义多个。 注释 单行注释：//注释内容 多行注释：/*注释内容*/ 数据类型 原始数据类型(基本数据类型)：number：数字。 整数/小数/ NaN (not a number 一个不是数字的数字类型)string：字符串。 字符串 “abc” “a” ‘abc’boolean： true 和 falsenull：一个对象为空的占位符undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为 undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java 语言是强类型语言，而 JavaScript 是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法：var 变量名 = 初始化值; typeof 运算符：获取变量的类型。 注：null运算后得到的是object 运算符 一元运算符：只有一个运算数的运算符，++，-- ， +(正号) ++ --： 自增(自减) +(-)：正负号 注意：在 js 中，如果运算数不是运算符所要求的类型，那么 js 引擎会自动的将运算数进行类型转换 算数运算符：+ - * / % … 赋值运算符：= += -+ … 比较运算符：&gt; &lt; &gt;= &lt;= == ===(全等于) 类型相同：按照字典顺序直接比较。按位逐一比较，直到得出大小为止。 类型不同：先进行类型转换，再比较 ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回 false 逻辑运算符：&amp;&amp; || ! 三元运算符：表达式? 值1 : 值2; var a = 3;var b = 4;var c = a &gt; b ? 1 : 0; 其他类型转 number： string 转 number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean 转 number：true转为1，false转为0 其他类型转 boolean： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined：都是false 对象：所有对象都为true 流程控制语句 if…else… switch：在java中，switch语句可以接受的数据类型： byte int shor char。在js中,switch语句可以接受任意的原始数据类型switch(变量)： case 值： 「注」：Java Switch中：枚举(1.5) ,String(1.7) while do…while for js特殊语法 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 变量的定义使用var关键字，也可以不使用 用： 定义的变量是局部变量 不用：定义的变量是全局变量(不建议) 练习：99乘法表&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td&#123; border： 1px solid; &#125; &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) &#123; document.write(\"&lt;tr&gt;\"); for (var j = 1; j &lt;=i ; j++) &#123; document.write(\"&lt;td&gt;\"); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); &#125; /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); &#125; //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 基本对象Function函数(方法)对象 创建： //第一种方式 var fun = new Function(形式参数列表,方法体); //不建议使用 //第二种方式 function 方法名称(形式参数列表)&#123; 方法体 &#125; //第三种方式 var 方法名 = function(形式参数列表)&#123; 方法体&#125; 属性： length： 代表形参的个数 特点： 方法定义是，形参的类型不用写,返回值类型也不写。 方法是一个对象，如果定义名称相同的方法，会覆盖 在js中，方法的调用只与方法的名称有关，和参数列表无关 在方法声明中有一个隐藏的内置对象（数组）：arguments，封装所有的实际参数 调用： 方法名称(实际参数列表); Array数组对象 创建：var arr = new Array(元素列表);var arr = new Array(默认长度);var arr = [元素列表]; 方法 join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push()：向数组的末尾添加一个或更多元素，并返回新的长度。 属性 length：数组的长度 特点：js中，数组元素的类型是可变的,长度是可变的。 BooleanDate日期对象 创建： var date = new Date(); 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime()：获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 Math数学对象 创建：Math对象不用创建，直接使用。 Math.方法名(); 方法：random()：返回 0 ~ 1 之间的随机数。 含0不含1ceil(x)：对数进行上舍入。floor(x)：对数进行下舍入。round(x)：把数四舍五入为最接近的整数。 属性： PI , … NumberStringRegExp 正则表达式，定义字符串的组成规则。 单个字符：[] 如： [a] [ab] [a-zA-Z0-9_] 特殊符号代表特殊含义的单个字符： \\d：单个数字字符 [0-9] \\w：单个单词字符[a-zA-Z0-9_] 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}：表示 m&lt;= 数量 &lt;= n* m如果缺省： {,n}：最多n次 * n如果缺省：{m,} 最少m次 开始结束符号 ^：开始 $：结束 正则对象： 创建//第一种方式var reg = new RegExp(\"正则表达式\");//第二种方式var reg = /正则表达式/; 方法test(参数)：验证指定的字符串是否符合正则定义的规范 Global 特点：全局对象，这个 Global 中封装的方法不需要对象就可以直接调用。 方法名(); 方法： encodeURI()：url编码 decodeURI()：url解码 encodeURIComponent()：url编码,编码的字符更多 decodeURIComponent()：url解码 parseInt()：将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN()：判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部为false eval()：将 JavaScript 字符串，并把它作为脚本代码来执行。 URL编码：XXXX = %E4%BX%A2%Ea%95%BA%E5%92%AD%E3%A2%A3 事件概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件点击事件 onclick ：单击事件 ondblclick ：双击事件eg：通过 js 获取元素对象，指定事件属性，设置一个函数&lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun()&#123; alert('被点击'); &#125; function fun2()&#123; alert('被点击2'); &#125; //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt;&lt;/body&gt; 焦点事件 onblur ：失去焦点 onfocus ：元素获得焦点。 加载事件 onload ：一张页面或一幅图像完成加载。 鼠标事件 onmousedown 鼠标按钮被按下。 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件 onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选择和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件 onsubmit 确认按钮被点击。 onreset 重置按钮被点击。 BOM概念Browser Object Model 浏览器对象模型，将浏览器的各个组成部分封装成对象。 组成 Window ：窗口对象 Navigator ：浏览器对象 Screen ：显示器屏幕对象 History ：历史记录对象 Location ：地址栏对象 Window 创建：直接可以window.方法名()，window 关键字可省略 方法 与弹出框有关的方法：alert() 显示带有一段消息和一个确认按钮的警告框。confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框，有返回值prompt() 显示可提示用户输入的对话框。返回值：获取用户输入的值 与打开关闭有关的方法：close() 关闭浏览器窗口。谁调用我 ，我关谁open() 打开一个新的浏览器窗口，返回新的Window对象 与定时器有关的方式setTimeout() 在指定的毫秒数后调用函数或计算表达式。参数： 1. js代码或者方法对象 2. 毫秒值返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval() 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象： history location Navigator Screen 获取DOM对象 document 特点Window 对象不需要创建可以直接使用 window 使用。 window.方法名();window 引用可以省略。 方法名(); Location 创建(获取) window.location location 方法：reload() 重新加载当前文档。刷新 属性href 设置或返回完整的 URL。 History 创建(获取) window.history history 方法back() 加载 history 列表中的前一个 URL。forward() 加载 history 列表中的下一个 URL。go(参数) 加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性 length 返回当前窗口历史列表中的 URL 数量。 ScreenNavigatorDOM概念Document Object Model 文档对象模型，将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行 CRUD 的动态操作。 DOM分类W3C DOM 标准被分为 3 个不同的部分 核心 DOM针对任何结构化文档的标准模型 Document：文档对象 创建(获取)：在html dom 模型中可以使用 window 对象来获取 window.document document 方法： 获取 Element 对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName()：根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName()： 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() Element：元素对象 获取/创建：通过 document 来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象Node节点对象是其他5个的父对象。 特点：所有 dom 对象都可以被认为是一个节点 方法： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild() ：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode 返回节点的父节点。 Attribute：属性对象Text：文本对象Comment:注释对象HTML DOM针对 HTML 文档的标准模型 标签体的设置和获取： innerHTML 使用 html 元素对象的属性 控制元素样式 使用元素的 style 属性来设置//修改样式方式1div1.style.border = \"1px solid red\";div1.style.width = \"200px\";//font-size--&gt; fontSizediv1.style.fontSize = \"20px\"; 提前定义好类选择器的样式，通过元素的 className 属性来设置其class属性值。 XML DOM 针对 XML 文档的标准模型 小结js语法的使用基本类似java，只需在使用时随手查阅文档即可。要把握好 DOM 和 BOM 的区别，DOM管理浏览器的内容对象，BOM管理浏览器的控件对象。而 BOM 控制(获取) DOM。","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.alphabethub.com/tags/JavaScript/"}]},{"title":"游泳手记","slug":"daily-2019-0601","date":"2019-06-01T11:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2019/06/01/daily-2019-0601/","link":"","permalink":"https://blog.alphabethub.com/2019/06/01/daily-2019-0601/","excerpt":"","text":"蛙泳漂手臂放在耳朵后面伸直，自然向前漂 滑行手臂伸直，脑袋钻进水里，双脚向后蹬墙，感受水中滑行。 蹬腿四个动作： 收双腿并拢，向后往屁股方向收，注意脚腕用力 翻把双腿分开，用力保持收的姿势和脚腕 蹬夹用力向后蹬腿的同时夹拢双腿 换气3个动作：慢慢抬头的过程中就开始用嘴巴出气，出水后发出啪的一声，然后大力用嘴巴吸气，再次进入水中 蹬腿换气结合换气，低头后蹬腿，然后滑行2-3秒。重复以上 划手+换气+蹬腿手分开至双肩宽或比肩稍宽，用小臂向下划水同时慢慢抬头换气，小臂划至胸口位置时收小臂从中心位置向前探出同时低头1秒在进行蹬腿，蹬腿后漂2-3秒再重复以上 蹬腿口诀边收边分满收腿，向外翻脚对准水，向后弧形蹬夹腿，两腿伸直漂一会儿 概括划手腿不动，收手又收腿，先伸胳膊后蹬腿，手腿伸直漂一会儿简称：划收伸蹬 踩水抬头扶板蛙泳腿双手扶着浮板的前端，抬头(下巴露出水面即可)蹬腿(收翻等夹)，直到可以蹬25m 深水抱浮板手抱紧浮板在胸前，腿部姿势像是坐小板凳，腿置于上身的前面蹬蛙泳腿，保持下巴在水面上 浅水抬头蛙泳下巴露出水面，手和脚(收翻蹬)，重复做蛙泳的动作前进 潜水头朝下，身体呈倒栽的姿势，使用蛙泳的姿势潜行。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"HTML 和 CSS 快速入门","slug":"web-html-css-base","date":"2019-05-27T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/05/27/web-html-css-base/","link":"","permalink":"https://blog.alphabethub.com/2019/05/27/web-html-css-base/","excerpt":"","text":"HTMLhyper text markup language 超文本标记语言，是最基础的网页开发语言。网页文件后缀名以.html/.htm结束。 基本标签文件标签&lt;!DOCTYPE html&gt;：html5 中定义该文档类型是html文档&lt;html&gt;：html 文档的根标签&lt;head&gt;：头标签，用于指定 html 文档的一些属性，引入外部的资源。&lt;title&gt;：标题标签&lt;body&gt;：体标签 文本标签注释：&lt;!-- 注释内容 --&gt;&lt;h1&gt; to &lt;h6&gt;：标题标签，字体大小逐渐递增&lt;p&gt;：段落标签&lt;br&gt;：换行标签&lt;hr&gt;：水平线,属性：color,width,size,align(center,left,right)&lt;b&gt;：字体加粗&lt;i&gt;：字体斜体&lt;font&gt;：字体标签,属性：color,size,face&lt;center&gt;：文本居中 属性定义color: 1. 英文单词：red,green,blue 2. rgb(值1,值2,值3)：值的取值范围：0255。 如rgb(0,0,255) 3. #值1值2值3：值的范围：00FF之间。如 #00FF00width: 1. 数值 width = ‘20’，数值的单位默认是px像素 2. 数值%：占比相对于父元素的比例。 图片标签&lt;img&gt;：图片标签，属性：src,alt,align,width,height相对路径：以.开头的路径，eg：./代表当前路径，../代表上一级目录 列表标签&lt;ol&gt;：有序列表外层标签&lt;ul&gt;：无序列表外层标签&lt;li&gt;：条目标签，包含属性 type 链接标签&lt;a&gt;：超链接标签属性：href：访问资源的 URL ,target：打开资源的方式(_self默认值,_blank) div和span&lt;div&gt;：每一个 div 占满一行，块级标签&lt;span&gt;：文本信息在一行展示，行内标签 语义化标签语义化标签是 html5 之后出现的新特性，目的是为了提高程序的可读性&lt;header&gt;：页眉&lt;footer&gt;：页脚 表格标签&lt;table&gt;：定义表格标签属性：width,border,bgcolor,aligncellpadding：单元格内容与单元格的距离cellspacing：定义单元格之间的距离，如果指定为0，则单元格线会合并为一条&lt;tr&gt;：定义行&lt;td&gt;：定义单元格&lt;th&gt;：定义表头单元格&lt;caption&gt;：表格标题&lt;thead&gt;：表格中表头内容，类似语义化标签，目的为增强代码可读性&lt;tbody&gt;：表格表体内容&lt;tfoot&gt;：表格脚注 表单标签用户采集用户输入的数据，和服务器进行交互。 表单体标签&lt;form&gt;：可以定义一个范围，范围代表采集用户数据的范围。属性： action method：请求方式有7种，一般使用 get，post name：(不指定无法提交表单项中的数据) 表单项标签&lt;input&gt;：可以通过 type 属性改变元素展示的样式。type属性值： text：文本 password：密码 radio(value属性指定提交的值,checked指定默认值), checkbox(value属性指定提交的值,checked指定默认值), placeholder：提示文字 file：选择文件框 hidden：隐藏域，用于提交一些信息。 submit：提交按钮 button：普通按钮 image：图片提交按钮，src属性选择图片路径 color：取色器 date：日期选择 datetime-local：带时分日期选择 email：邮箱 number：数字选择&lt;label&gt;：指定输入项的文字描述信息，其for属性一般会和 input 的 id 属性对应。这样点击 label 后 input 则会获取到焦点。&lt;select&gt;：下拉列表&lt;option&gt;：下拉列表中的子选项,value属性用于指定提交的值&lt;textarea&gt;：多行输入框，属性rows，cols用于指定行数和每行显示的字符数。 CSS概念Cascading Style Sheets 层叠样式表，多个样式可作用在同一个 html 元素上，同时生效。 使用内联样式在标签内使用style属性指定 css 代码eg： &lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 内部样式在head标签内，定义style标签 style 标签体内容就是 css 代码eg： &lt;style&gt; div&#123; color:blue; &#125;&lt;/style&gt;&lt;div&gt;hello css&lt;/div&gt; 外部样式1.定义 css 资源文件2.在head标签内，定义link标签，引入外部的资源文件eg：.css文件 div&#123; color:green;&#125; .html文件 &lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt;&lt;div&gt;hello css&lt;/div&gt; CSS语法格式： 选择器 &#123; 属性名1:属性值1; 属性名1:属性值1; ...&#125; 注意：每一对属性需要使用;隔开，最后一对属性可以不加; 选择器筛选具有相似特征的元素 基础选择器 id选择器：选择具体的 id 属性值的元素，建议在 html 页面中 id 值唯一；语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素；语法：标签名称{}，注意 id 选择器优先级高于元素选择器 类选择器：选择具有相同的 class 属性值的元素.class属性值{}，注意类选择器优先级高于元素选择器，低于 id 选择器 扩展选择器 选择素有元素；语法：*{} 并集选择器；语法：选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素；语法：选择器1 选择器2{} 父选择器：筛选选择器2的父元素选择器1；语法：选择器1 &gt; 选择器2{} 属性选择器：选择元素名称,属性名=属性值的元素；语法：元素名称[属性名=&quot;属性值&quot;]{} 伪类选择器：选择一些元素具有的状态；语法：元素:状态{} 属性 字体、文本font-size：字体大小color：文本颜色text-align：对齐方式line-height：行高 背景background：背景，属性url可以指定图片路径 边框border：设置边框，复合属性 尺寸width：宽度height：高度 盒子模型：控制布局margin：外边距padding：内边距，默认情况下调整内边距会影响整个盒子的大小，这时可设置box-sizing:border-box;确定盒子的指定宽高为最终大小float：left,right","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.alphabethub.com/tags/Web/"},{"name":"HTML","slug":"HTML","permalink":"https://blog.alphabethub.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.alphabethub.com/tags/CSS/"}]},{"title":"JDBC 基本使用","slug":"java-jdbc","date":"2019-05-25T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/05/25/java-jdbc/","link":"","permalink":"https://blog.alphabethub.com/2019/05/25/java-jdbc/","excerpt":"","text":"JDBC：Java DataBase Connection，简言就是使用 Java 语言操作数据库。 快速入门Class.forName(\"com.mysql.jdbc.Driver\");Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db2\", \"root\", \"root\");Statement statement = connection.createStatement();String sql = \"update account set balance = 500 where id = 1\";int count = statement.executeUpdate(sql);System.out.println(count);connection.close();statement.close(); 详解各个类DriverManager 驱动管理对象 注册驱动：通知数据库该使用哪一个数据库驱动的jar //注册给定的驱动程序 DriverManegerstatic void registerDriver(Driver driver)//写代码时使用Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在 com.mysql.jdbc.Driver 类中存在静态代码块 static &#123; try&#123; java.mysql.DriverManeger.registerDriver(new Driver()); &#125;catch(SQLException e)&#123; throw new RuntimeException(\"Can't register driver!\") &#125;&#125; 获取数据库连接 方法：static Connection get Connection(String url, String user, String password) 参数：url：指定连接的路径语法：jdbc:mysql//ip地址:端口号/数据库名称 例子：jdbc:mysql//localhost:3306/db2 细节：如果连接的是本机mysql服务器，并且默认端口为3306，则url可以简写为：jdbc:mysql:///数据库名称user:用户名password:密码 Connection数据库连接对象 获取执行sql对象Statement createStatement()PreparedStatement prepareStatement(String sql) 管理事务开启事务：setAutoCommit(boolean autoCommit)，调用该方法设置参数为false开启事务。提交事务：commit()回滚事务：rollback() Statement用于执行sql的对象 boolean execute(String sql)，可以执行任意的sql int executeUpdate(String sql)，执行DML(insert、update、delete)语句、DDL(create、alter、drop)语句；返回值是影响的行数，可以用来判断是否执行成功。 ResultSet executeQuery(String sql)：执行DQL（select）语句 ResultSet结果集对象boolean next():游标向下移动一行，判断当前行是否是末尾（是否有数据），如果是则返回false，如果不是则返回truegetXxx(参数):获取数据，Xxx代表数据类型，如：getString()、getInt()；参数可以使用列编号也可以使用列名 while(rs.next())&#123; int id = rs.getInt(1); String name = rs.getString(\"name\"); double banlance = rs.getDouble(3);&#125; PreparedStatement用于执行安全执行sql的对象，防止注入问题 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全问题。 解决SQL注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 使用 获取执行SQL语句的对象： PreparedStatement Connection.prepareStatement(String sql) 给?赋值：setXxx(参数1，参数2)， 参数1：? 位置的编号，从1开始 参数2：? 的值 注意：PreparedStatement 可以防止sql注入，且效率更高。 JDBC 控制事务使用Connection对象来管理事务开启事务：setAutoCommit(boolean autoCommit)，参数设置为false，即开启事务。一般在sql执行之前开启事务提交事务：commit()，当所有 sql 执行完提交事务回滚事务：rollback()，在 catch 中回滚事务设置回滚点：setSavePoin()回滚到回滚点：rollback(sp) JDBC 连接池频繁向系统申请连接数据库的操作是一个相对耗时的操作。为了提高效率并节省资源，引入数据库连接池的概念，而 JDBC 连接池其实就是一个用于存放数据库连接的容器（集合）；当系统初始化完毕之后，容器就会被创建，容器中会申请一些连接对象；当用户访问数据库时，从容器中获取连接对象；访问完毕将连接归还给容器。使得更节约资源，访问更高效。 DataSource DataSource 是 javax.sql 包下操作数据库连接池的标准接口，其提供统一的获取和释放数据库连接池的操作。 getConnection()：获取连接 Connecion.close()：归还至连接池 C3P0C3P0 是 Apache 一个开源的 JDBC 连接池，它实现了 DataSource 和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。 目前使用它的开源项目有Hibernate，Spring等。使用步骤： 导入jar包（2个）c3p0-0.9.5.2.jar 及其依赖包 mchange-commons-java-0.2.12.jar 导入数据库驱动 jar 包 定义配置文件： 名称：c3p0.properties/c3p0-config.xml 路径：直接放在 src 目录下 创建核心数据库连接对象 ComboPooledDateSource 获取连接：getConnection() DruidDruid是一个阿里巴巴提供的JDBC组件库，Druid是一个JDBC组件库，包括数据库连接池、SQL Parser等组件。 DruidDataSource 高效可管理的数据库连接池。https://github.com/alibaba/druid使用步骤： 导入 jar 包 druid-1.0.9.jar 定义配置文件：任意名字.properties放在任意目录下 加载配置文件 获取数据库连接池对象 DruidDataSourceFactory 获取连接：getConnection() Spring JDBCSpring 框架对JDBC的简单封装，提供了一个 JdbcTemplate 对象简化JDBC的开发使用步骤： 导入jar包 创建 JdbcTemplate 对象，依赖于数据源 DatasourceJdbcTemplate template = new JdbcTemplate(ds); 调用 JdbcTemplate 方法来完成 CRUD 的操作 update()：执行 DML 增删改语句 queryForMap()：查询结果并将结果集封装为 Map 集合，将列名作为 key ，将值作为 value ，将这条记录封装为一个 Map 集合。注意这个方法查询的结果集长度为 1 queryForList()：查询结果并将结果集封装到 List 集合中，其中每一条记录封装为 Map 集合，再将 Map 装在到 List query(参数)：查询结果并将结果封装为 JavaBean 对象 参数：接口 RowMapper、实现类 BeanPropertyRowMapper(可以实现数据到 JavaBean 的自动封装) new BeanPropertyRowMapper&lt;类型&gt;(类型.class); queryForObject()：查询结果并将结果封装为对象，一般用于聚合函数的查询","categories":[{"name":"DataBase","slug":"DataBase","permalink":"https://blog.alphabethub.com/categories/DataBase/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://blog.alphabethub.com/tags/JDBC/"}]},{"title":"MySQL 基本使用","slug":"mysql","date":"2019-05-09T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/05/09/mysql/","link":"","permalink":"https://blog.alphabethub.com/2019/05/09/mysql/","excerpt":"","text":"SQL的分类DDL(Data Definition Language)数据定义语言，用来定义数据库对象：数据库，表，列等。关键字：create，drop，alter 等 DML(Data Manipulation Language)数据操作语言，用来对数据库表中的数据进行增删改。关键字：insert，delete，update 等 DQL(Data Query Language)数据查询语言，用来查询数据库表中的记录（数据）。关键字：select，where 等 DCL(Data Control Language)用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT，REVOKE 等 DDL 操作数据库(CRUD)C(Create)create database dbname;create database if not exist dbname;create database dbname character set utf8;create database if not exist dbname character set utf8; R(Retrieve)-- 查询所有数据库的名称show databases;-- 查询某个数据库的字符集&#x2F;创建语句show crate database dbname; U(Update)alter database dbname character set utf8; D(Delete)drop database dbname;drop database if exist dbname; 使用数据库-- 查询当前正在使用的数据库select database();-- 使用指定的数据库use dbname; DML 操作表C(Create)create table tbname( 列名1 数据类型1， 列名2 数据类型2， ... 列名n 数据类型n);-- 赋值一张表create table 表名 like 被复制的表名; 数据类型： int:整数类型 age int double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间戳类型，包含年月日时分秒 yyyy-MM-dd HH:mm:ss（如果将来不给这个字段赋值，或者赋值为Null，则默认使用当前的系统时间来自动赋值） varchar:字符串类型 name varchar(20):姓名最多20个字符 zhangsan 8个字符，张三 2个字符 R(Retrieve)-- 查询数据库中所有表名称show tables;-- 查询表结构desc tbname; U(Update)-- 修改表名alter table tbname rename to newtbname;-- 查看表的字符集show create table tbname;-- 修改表的字符集alter table tbname character set utf8;-- 添加一列alter table tbname add column_name varchar(10);-- 修改列名称、数据类型alter table tbname change gender sex varchar(20);-- 只修列的数据类型alter table tbname modify sex varchar(10);-- 删除列alter table tbname drop column_name;&#96;&#96;&#96; ### D(Delete)&#96;&#96;&#96;mysqldrop table tbname;drop table if exists tbname;&#96;&#96;&#96; ## DML 操作表### 添加数据&#96;&#96;&#96;mysqlinsert into tbname(列名1,...列名n) values(值1,...值n); 注意： 列名要和值名一一对应，如果表名后不指定列名，则默认给所有列添加值。 insert into tbname values(值1,…值n); 值除了数字以外，其他都需要用引号（单双都可以）引起来 删除数据delete from tbname [where condition]; 注意： 如果不加条件，则删除表中所有的记录 如果要删除所有记录 delete from tbname; – 不推荐使用，因为有多少条记录就会执行多少次删除操作 truncate table tbname; – 推荐使用，先删除表，在创建一张一样的空表；效率更高 修改数据update tbname set 列名1 &#x3D; 值1,列名2 &#x3D; 值2,...[where condition]; 注意：如果不加任何条件，则会将表中所有记录全部修改。 DQL 查询语句select * from tbname; 排序查询 语法：order by 子句; order by 排序子句1 排序方式1,...排序子句2 排序方式n; 排序方式 ASC：升序，默认的。 DESC：降序。 注意：如果有多个排序条件，则当前面的条件值一样时候，才会判断第二条件，以此类推。 聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 select count(id) from tbname; 一般选择非空的列：主键 count(*) – 不建议使用 max：计算最大值 select max(列名) from tbname; min：计算最小值 select min(列名) from tbname; sum：计算和 select sum(列名) from tbname; avg：计算平均值 select avg(列名) from tbname; 注意：聚合函数的计算，排除null值解决方案： 选择不包含空的列进行计算 IFNULL函数select count(IFNULL(列名,0)) from tbname; 分组查询 语法：group by 分组字段 注意： 分组之后查询的字段：分组字段，聚合函数 where 和 having 的区别 where 在分组之前进行限定，如果不满足条件，则不参与分组。 having 在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后可以跟聚合函数，having 可以进行聚合函数的判断 分页查询 语法：limit 开始索引,每页查询条数; 公式：开始的索引 = （当前的页码 - 1）* 每页显示的条数eg：– 每页显示三条记录SELECT * FROM TBNAME LIMIT 0,3; -- 第1页SELECT * FROM TBNAME LIMIT 3,3; -- 第2页SELECT * FROM TBNAME LIMIT 6,3; -- 第3页 limit是一个mysql的「方言」 DQL 查询表中的语句 select * from tbname; 语法select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序子句列表limit 分页限定 基础查询 多个字段的查询select 字段名1,...字段名n from tbname; 注意：如果查询所有字段，则可以用*来代替字段列表2. 去除重复：distinct3. 多列的值计算 一般可以使用四则运算计算一些列的值。 ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1:那个字段需要判断是否为Null 表达式2：如果该字段为Null后的替换值 别名：as，也可以省略用空格替代。 条件查询 where子句后跟条件 运算符&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;BETWEEN...AND...IN(集合)、NOT IN(集合)IS NULL 、IS NOT NULLAND / &amp;&amp;OR / ||NOT / !LIKE：模糊查询。占位符有：_表示单个任意字符，%表示多个任意字符。 用法示例:-- 查询年龄大于20岁SELECT * FROM tbname WHERE age &gt; 20;SELECT * FROM tbname WHERE age &gt;&#x3D; 20;-- 查询年龄等于20岁SELECT * FROM tbname WHERE age &#x3D; 20;-- 查询年龄不等于20岁SELECT * FROM tbname WHERE age !&#x3D; 20;SELECT * FROM tbname WHERE age &lt;&gt; 20;-- 查询年龄大于等于20，小于等于30SELECT * FROM tbname WHERE age &gt;&#x3D; 20 &amp;&amp; age &lt;&#x3D; 30;SELECT * FROM tbname WHERE age &gt;&#x3D; 20 AND age &lt;&#x3D; 30;SELECT * FROM tbname WHERE BETEEN 20 AND 30;-- 查询年龄为18，20，30岁的人SELECT * FROM tbname WHERE age &#x3D; 18 || age &#x3D; 20 || age &#x3D; 30;SELECT * FROM tbname WHERE age &#x3D; 18 OR age &#x3D; 20 OR age &#x3D; 30;SELECT * FROM tbname WHERE age IN (18,20,30);-- 查询年龄不为18，20，30岁的人SELECT * FROM tbname WHERE age NOT IN (18,20,30);-- 查询英语成绩为nullSELECT * FROM tbname WHERE english IS NULL;-- 查询英语成绩为不null SELECT * FROM tbname WHERE english IS NOT NULL;-- 查询姓马的人SELECT * FROM tbname WHERE name LIKE &quot;马%&quot;;-- 查询姓名中第二个字为化的人SELECT * FROM tbname WHERE name LIKE &quot;_化%&quot;;-- 查询姓名中包含化的人SELECT * FROM tbname WHERE name LIKE &quot;%化%&quot;; 多表查询 内连接 显式内连接： select 字段列表 from 表名1 inner join 表名2 on 条件 隐式内连接： 使用 where 条件消除无用数据 外链接 左外连接： select 字段列表 from 表1 left [outer] join 表2 on 条件; (查询的是左表所有字段以及其交集部分) 右外链接 select 字段列表 from 表1 right [outer] join 表2 on 条件; (查询的是右表所有字段以及其交集部分) 子查询 概念：查询中嵌套查询，成嵌套查询为子查询。 子查询的结果是单行单列 子查询可以作为条件，使用运算符去判断。运算符：&gt; / &gt;= / &lt; / &lt;= / = eg： select * from emp where emp.salary &lt; (select avg(salary) from emp); 子查询的结果是多行单列 子查询可以作为条件，使用运算符 IN 去判断 eg： select * from emp where dept_id in (select id from dept where name in(&#39;财务部&#39;,&#39;市场部&#39;)); 子查询的结果是多行多列 子查询可以作为一张虚拟表参与查询 eg： select * from dept t1,(select * from emp where emp.&#96;join_date&#96; &gt; &#39;2011-11-11&#39;) t2where t1.id &#x3D; t2.dept_id; 约束(Constriant)对表中的数据进行限定，保证数据的正确性，完整性和有效性。 非空约束not null -- 1. 创建表时添加约束create table tbname( id int; name varchar(20) not null);-- 2. 删除name的非空约束alter table tbname modify name varchar(20);-- 3. 创建完表后，添加非空约束alter table tbname modify name varchar(20) not null; 唯一约束unique,值不能重复 -- 1. 创建表时，添加唯一约束create table tbname( id int. phone_number varchar(20) unique);-- 2.删除唯一约束-- 错误写法 drop table tbname modify phone_number varchar(20);alter table tbname drop index phone_number;-- 3. 创建表之后添加唯一约束alter table tbname modify phone_number varchar(20); 主键约束primary key，非空而且唯一，一张表只能有一个主键字段，唯一标识。 -- 1. 创建表时，添加主键约束create table tbname( id int primary key, name varchar(20));-- 2. 删除主键约束-- 错误写法：alter table tbname modify id int;alter table tbname drop primary key;-- 3. 创建完表后，添加主键约束alter table tbname modify id int primary key; 自增长auto_increment -- 1. 创建表时添加主键并且指定为自增长create table tbname( id int primary key auto_increment, name varchar(20));-- 2. 删除自增长alter table tbname modify id int;-- 3. 创建完表后添加自增长alter table tbname modify id int auto_increment; 注意：一般情况下auto_increment 与primary key 搭配使用，但是它也是可以单独使用的。 外键约束foreign key，让表与表产生关系，从而保证数据的正确性。 -- 1. 在创建表时，可以添加外键。create table tbname( ..... 外键列 constriant 外键名称 foreign key(外键列名称) references 主表名称(主表列名称));-- 2. 删除外键alter table tbname drop foreign key 外键名称;-- 3. 创建完表之后，添加外键alter table tbname add constraint 外键名称 foreign key(外键列名) references 主表名称(主表列名); 级联操作在操作相关联的表的数据时候，会同步更新或者删除 添加级联alter table tbname add constraint 外键名称 foreign key(外键列名) references 主表名称(主表列名) on update cascade on delete cascade; 分类 级联更新：on update cascade 级联删除：on delete cascade 数据库的设计多表之间的关系 一对一 &lt;1:1&gt;eg：人和身份证实现方式：一对一关系的实现，可以在任意一方添加唯一外键指向另一方的外键。一般还是建议合并为一张表。 一对多（多对一）&lt;1:n/n:1&gt;eg：部门和员工实现方式：在多的一方建立外键，指向一的一方的主键。 多对多 &lt;m:n&gt;eg：学生和课程实现方式：多对多关系实现需要借助第三章中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。也可以使用联合主键。 数据库设计的范式 第一范式（1NF）：每一列都是不可分割的原子数据项。 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF的基础上非主属性对主码的部分函数依赖） 函数依赖：A–&gt;B，如果A属性（属性组）的值，可以确定唯一的B属性的值，则称B依赖于A。eg：学号--&gt;姓名。（学号，课程名称）--&gt;分数 完全函数依赖：A–&gt;B，如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。eg：（学号，课程名称）--&gt;分数 部分函数依赖：A–&gt;B，如果A是一个属性组，则B属性值的确定只需要依赖A属性组中某一些值即可。eg：（学号，课程名称）--&gt;姓名 传递函数依赖：A–&gt;B，B–&gt;C；如果A属性（属性组），可以唯一确定B属性的值；B属性（属性组）的值可以唯一确定C属性的值，则称C传递函数依赖于Aeg：学号--&gt;系名，系名-&gt;系主任 码：如果在一张表中，一个属性或者属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码 主属性：码属性组中的所有属性 非主属性：除过码属性组的所有属性 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其他非主属性（在2NF基础上消除传递依赖） 数据库的备份和还原备份mysql&gt; mysqldump -u用户名 -p密码 &gt; 保存的路径 还原 登录数据库 mysql -uroot -proot 创建数据库 create database dbname 使用数据库 use dbname 执行以下命令：mysql&gt; source 文件路径 事务事务的基本介绍 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作： 开启事务：start transaction; 回滚：rollback; 提交：commit; 事务的两种提交方式 自动：MySQL 就是自动提交的，一条DML（增删改）语句会自动提交一次事务。 手动：Oracle 数据库默认手动提交事务。需要先开启事务再提交。 修改事务的提交方式：select @@autocommit;-- 1代表自动，0代表手动 set @@autocommit = 0; 事务的四大基本特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间，相互独立。 一致性：事务操作前后，数据总量不变。 事务的隔离级别 概念多个事务之间是独立的，相互隔离的；但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题 脏读：一个事务，读取到另外一个事务中没有提交的数据。 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作（DML）数据表中所有事物，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted：读未提交；产生的问题：脏读、不可重复读、幻读 read committed：读已提交（Oracle 默认）；产生的问题：不可重复读、幻读 repeatable read：可重复读（MySQL 默认）；产生的问题：幻读 serializable：串行化；可以解决所有问题 注意：隔离级别从小到大，安全性越来越高，但是效率越来越低。 -- 查询隔离级别select @@tx_isolation;-- 设置隔离级别set global transaction isolation level 级别字符串; DCL 管理、授权用户用户管理 添加用户create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;; 删除用户drop user &#39;用户名&#39;@&#39;主机名&#39;; 修改用户密码update user set password &#x3D; password(&#39;新密码&#39;) where user &#x3D; &#39;用户名&#39;;set password for &#39;用户名&#39;@&#39;主机名&#39; &#x3D; password(&#39;新密码&#39;); 查询用户-- 切换到mysql数据库use mysql;-- 查询user表select * from user; 注意：通配符%表示可以在任意主机使用该用户登录数据库 权限管理 查询权限show grant for &#39;用户名&#39;@&#39;主机名&#39;; 授予权限grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;-- 给张三用户授予所有权限，在任意数据库任意表上。eg:grant all on *.* to &#39;zhangsan&#39;@&#39;localhost&#39;; 撤销权限revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;; 修改 mysql 设置更改默认编码查看 mysql 数据库的默认编码命令： mysql&gt; show variable like 'character%';+--------------------------+--------------------------------------------------------+| Variable_name | Value |+--------------------------+--------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.10-osx10.9-x86_64/share/charsets/ |+--------------------------+--------------------------------------------------------+8 rows in set (0.01 sec) 可见 database 和 server 的字符集使用了 latin1 编码方式，不支持中文，即存储中文时会出现乱码。以下修改方法： cd /private/etc/ 新增一个 my.cnf 文件 然后写入以下命令保存退出[client]default-character-set=utf8 [mysql]default-character-set=utf8 [mysqld]collation-server = utf8_unicode_ciinit-connect='SET NAMES utf8' 重启 mysql 忘记root用户密码 net stop mysql mysqld –skip-grant-tables(使用无验证服务启动mysql服务) 打开新的终端窗口，直接输入 mysql 命令 use mysql; update user set password = password(‘新密码’) where user = ‘root’; 关闭两个窗口，并结束 mysqld 进程 启动 mysql 服务 使用新密码登录","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.alphabethub.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.alphabethub.com/tags/MySQL/"}]},{"title":"写在百年五四","slug":"daily-2019-0504","date":"2019-05-04T11:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2019/05/04/daily-2019-0504/","link":"","permalink":"https://blog.alphabethub.com/2019/05/04/daily-2019-0504/","excerpt":"","text":"最近读完了《奇特的一生》 开始觉得如果在未来的某个时刻，能够清晰的回忆起某一天的某件事以及当时自己是怎样的心情。就会让岁月的流逝变得更有意义，所以决定按天来记录自己的日常琐事；虽是流水账的形式呈现，但却可以让自己想起那些细节中包含的丰富故事。倘若没有文字的记录，那么便无法清晰唤起这些记忆中的细节。于是我决定以这种流水账的形式来记录未来读研岁月的每一天，也许其间会有中断，但我想养成这样的习惯一定是一件分外美好的事。 自律给我自由，这是KEEP的一句slogan。知乎上曾有一个问答是：「有哪些习惯值得长期坚持？」其中一个高票回答大意是：读书+跑步+学习英语。 俗话说：读书破万卷，下笔如有神。如果要让每一天的经历或者感悟，抑或某一刻的情感更自然流淌，并以流利的文字来呈现；就是要养成一个每天阅读的习惯，无论是电子书，纸质书。功利一点的做法就是：要固定自己每天阅读时间，每个月能读几本书，每年的阅读计划有多少。我想这样在年底对自己这一年做回顾总结的时候。就读书这件事来说，应是会有很大的收获的。 我也始终认为，一个人如果不能自己的身材进行较好的控制和管理，那么他将可能一事无成。所以未来三年，我要坚持跑步和游泳的习惯，有每周的目标和年度的量化，最好是能做到风雨无阻。 央视曾经有采访一个大佬视频，具体是谁记得已经不是特别清楚，谈到自己年轻的时候对于英语的学习不屑一顾，觉得没有这个东西自己的也会生活的很好。但是多年以后，再次谈起这件事，他一改曾经的认识，认为英文的学习会为自己的人生增添一扇窗户，是与世界沟通的一种工具。如果拥有了这一扇窗，自己的生命可能就会是另外一种维度。那么，坚持学习英文吧。为了让自己的生命更丰富，也为了更了解这个世界，因为生命只有一次。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"},{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"VSCode 使用技巧(一)","slug":"vscode-note-01","date":"2019-05-04T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/05/04/vscode-note-01/","link":"","permalink":"https://blog.alphabethub.com/2019/05/04/vscode-note-01/","excerpt":"","text":"VS Code Note 01命令面板Cmd+Shift+P / F1：打开命令面板，是VS Code的主要交互界面 界面概览文件资源管理器：Ctrl+Shift+E跨文件搜索：Ctrl+Shift+F源代码管理：Ctrl+Shift+G启动和调试：Ctrl+Shift+D管理扩展：Ctrl+Shift+X查看错误和警告：Ctrl+Shift+M 命令行的使用如果你是在 macOS 上使用，安装后打开命令面板，搜索shell 命令：在 PATH 中安装 code 命令并执行，然后重启终端模拟就可以了。 OPTIONS（常用命令）-n --new-window Force to open a new window..-r --reuse-window Force to open a file or folder in an already opened window.-g --goto &lt;file:line[:character]&gt; Open a file at the path on the specified line and character.-d --diff &lt;file&gt; &lt;file&gt; Compare two files with each other. 通过命令行打开文件，并滚动至特定的行比如输入code -r -g package.json:128命令，你就可以打开 package.json 这个文件，然后自动跳转到 128 行。适用于某文件错误的行数的快速定位 比较两个文件的内容只需使用 -d参数，并传入两个文件路径，比如输入 code -r -d a.txt b.txt命令 打开管道内容将命令行 ls 的执行结果在 VS Code 的编辑器中打开 ls | code -注：管道的说明 如何在终端和文件之间快速切换快捷键：Ctrl + ` VS Code Note 02光标的快捷键移动操作 首先是针对单词的光标移动: Option + 左右方向键 同时按住 Option 和方向键，那么光标移动的颗粒度就变成了单词，你就可以在文档中以单词为单位不停地移动光标了。 第二种方式是把光标移动到行首或者行末：Cmd + 左右方向键 接下来一种是对于代码块的光标移动：Cmd + Shift + \\，就可以在这对花括号之间跳转。 最后是移动到文档的第一行或者最后一行：Cmd + 上下方向键 文本选择基于以上快捷键，只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本。 删除操作 删除光标右侧所有内容：Cmd + fn + delete 删除光标左侧所有内容：Cmd + delete 删除单词内右侧的字符：Option + fn + delete 删除单词内左侧的字符：Option + delete 自定义快捷键首先你可以打开命令面板（Cmd + Shift + p），搜索“打开键盘快捷方式”然后执行，这时你将看到相对应的界面。 比如，你可以搜索“选择括号内所有内容”，双击，按下Cmd + Shift + ]，然后按下回车，这个快捷键就绑定上了。比如，你通过搜索 “cmd+backspace”这组快捷键，发现它对应的命令是“删除左侧所有内容”，但你不希望使用这个命令，那你就可以通过右键选择删除该快捷键的绑定。 VS Code Note 03代码行编辑 删除当前行代码： Cmd + Shift + K 剪切当前行代码： Cmd + x 在当前代码上面开始一行时：Cmd + Shift + Enter 在当前代码下面开始一行时：Cmd + Enter 移动当前选中行代码：Option + 上下方向键 赋值当前选中行代码：Option + Shift + 上下方向键 编程语言相关的命令 添加注释：Cmd + / 代码格式化：Option + Shift + F，VS Code 也会根据你当前的语言，选择相关的插件。当然，前提条件是你已经安装了相关插件。 选中的代码格式化：Cmd + k or Cmd + F，这样只有这段被选中的代码才会被格式化。 其他小技巧 调换字符的位置：Ctrl + t 是调整字符的大小写：你可以选中一串字符，然后在命令面板里运行“转换为大写(transform to uppercase)”或 “转换为小写”, 来变换字符的大小写。 是合并代码行：Ctrl + j，可以把较短的代码合并至一行，而不需要不断地调整光标、删除换行符。 是撤销光标的移动和选择：Cmd + U VS Code Note 04创建多个光标两个特别命令 Cmd + D 适用情况比较特别：处理多次出现的“相同”单词。如果要处理的文本并不是相同的，那么这个方法就不适用了。 Option + Shift + i 首先选择多行代码，然后按下 “Option + Shift + i” ,这样操作的结果是：每一行的最后都会创建一个新的光标。 快捷键跳转多文件跳转 Ctrl + Tab 在正在操作的文件列表中切换文件 Cmd + P 打开最近的文件列表，并支持搜索功能「小技巧」 Cmd + Enter 当找到文件后按下这个快捷键可在新窗口中打开该文件 行跳转Ctrl + G 跳转到指定的代码行「高级组合技巧」：按下Cmd + P 直接输入文件名：行号 eg:main.css:3 符号跳转Cmd + R 能够看到当前文件里的所有符号(包括类，方法等)。 定义 (Definition) 和实现 (implementation) 跳转Cmd + F12 选中引用跳转到函数的实现位置 引用 (Reference) 跳转Shift + F12 选中函数或类按下这个快捷键就可以出现一个引用的列表，选择后内嵌的编辑器里便展示相应的引用代码 VS Code Note 04玩转鼠标选择文本 在VS Code中，你单击鼠标左键就可以把光标移动到相应的位置。 而双击鼠标左键，则会将当前光标下的单词选中。 连续三次按下鼠标左键，则会选中当前这一行代码。 最后是连续四次按下鼠标左键，则会选中整个文档。 文本编辑在 VS Code中，我们除了能够使用鼠标来选择文本以外，还能够使用鼠标对文本进行一定程度的修改，我们把它称为拖放功能（drag and drop）。比如在示例代码中，我们选中 bar 这个函数，然后将鼠标移到这段选中的代码之上，按下鼠标左键不松开。这时你可以看到，鼠标指针已经从一条竖线，变成了一个箭头。这时候我们移动鼠标的话，就可以把这段文本拖拽到我们想要的位置。 悬停提示窗口在 VS Code 的编辑器里使用鼠标的过程中，当你的鼠标移动到某些文本上之后，稍待片刻就能看到一个悬停提示窗口。这个窗口里会显示跟鼠标下文本相关的信息。 方法(Method) 比如，在示例代码中，当我把鼠标移动到第五行 foo 上后，悬停提示窗口里展示了 foo的类型信息，它告诉我们 foo是一个函数，不需要任何的参数，返回值是 void。 如果我把鼠标移动到 foo 上面时，按下 Cmd 键，则能够在悬停提示窗口里直接看到 foo的实现。 变量(Field) 在 JavaScript 或者 Java 这样的编程语言中，当我们把鼠标移动到某个变量上时，我们能够看到这个变量的定义信息。而在 CSS 中，当我们把鼠标移动到一个 CSS 规则上时，我们能看到的则是一段能够让这个 CSS 规则生效的 HTML 的样例代码。 代码跳转和链接我们还是把鼠标移动到示例代码的第五行 foo 上，然后按下 Cmd 键，这时候 foo下面出现了一个下划线。然后当我们按下鼠标左键，就跳转到了 foo函数的定义处。当我们在编写 Markdown 这样的非编程语言的文档时，也可以通过 Cmd + 鼠标左键 来打开超级链接。","categories":[{"name":"VSCode","slug":"VSCode","permalink":"https://blog.alphabethub.com/categories/VSCode/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://blog.alphabethub.com/tags/VSCode/"}]},{"title":"Java - 泛型(Generic)","slug":"java-generic","date":"2019-05-01T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/05/01/java-generic/","link":"","permalink":"https://blog.alphabethub.com/2019/05/01/java-generic/","excerpt":"","text":"定义泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型；也可以把泛型看做是一个变量，用来接收数据类型。泛型是提供给java编译器使用的，只在编译阶段可见，在源码文件编译为字节码文件的过程中，泛型会被移除掉，这个过程叫做泛型的擦除。 名词解释E:Element元素T:Type类型 ArrayList中的E称为Element类型参数变量ArrayList中的Integer称为实际类型参数 整个称为ArrayList泛型类型整个ArrayList称为参数化的类型ParameterizedType 集合泛型在jdk1.5以前对象一旦存入集合就丢失了类型，在获取时需要进行强转，麻烦并且容易出错。在jdk1.5以后提供了泛型技术，可以在定义泛型时明确指定存储的类型；如果不指定默认为Object，可以存储任意类型数据。 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();//jdk1.7之后，后面的泛型可以说省略不写，会自动推导。List&lt;String&gt; list = new ArrayList&lt;&gt;(); 注意：泛型不支持基本数据类型，但支持其包装类。 自定义泛型定义在方法上的泛型作用范围是当前方法，在方法被调用时候，编译器会自动判断出泛型的具体类型。 定义在类上的泛型作用范围是整个类，在创建类的对象时，就需要明确的指定泛型的具体类型；如果不指定默认为此泛型的上边界，如果没有上边界则默认上边界为Object。 定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123;&#125; public E get(int index)&#123;&#125; ...&#125; 使用格式：在使用时候在指定具体的泛型类型//具体为StringList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"string\");//具体为IntegerList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(\"integer\"); 注意： 静态方法不能使用类定义的泛形，而应单独定义泛形 定义在接口上的泛型 定义格式：修饰符 interface 接口名&lt;代表泛型的变量&gt; &#123; &#125; 第一种方式eg：public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E get(); &#125; 使用格式：public class MyImpl implements MyGenericInterface&lt;String&gt;&#123; @Override public void add(String s)&#123;&#125; @Override public String get()&#123;&#125;&#125; 第二种方式，接口是什么类型，继承实现类还使用什么抽象类型。仿ArrayListeg：public interface MyGenericInterface&lt;I&gt;&#123; public abstract void method(I i);&#125; 使用格式：public class MyImpl&lt;I&gt; implements MyGenericInterface&lt;I&gt;&#123; @Override public void method(I i)&#123;&#125;&#125; 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型的类型不确定，可以用通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中自身元素方法无法使用。 eg： List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();List&lt;Object&gt; list0= null;list0=list1;//报错list0=list2;//报错 list0 没有办法引用 list1 和 list2，这时该如何设计 list0 的泛型使他能够引用 list1 和 list2 呢?此时引入泛型通配符可以写成： List&lt;?&gt; list0 = null; 表明当前集合泛型的具体类型是不确定的，此时这个引用就可以接受任意具体类型泛型。 泛型的边界使用了泛型通配符以后，List&lt;?&gt; list0 就可以等于任意的类型了，但是有时我们还可能需要对这个引用可以接受的泛型类型进行一些限定： 泛型的上限 格式：类型名称 &lt;? extends 类&gt; 对象名称也就是说，可以通过这种方式定义此泛型所接受的具体类型必须是限定的该类型或其子类类型。在使用这个泛型时，可以使用这个泛型上边界所具有的方法；如果不明确限定泛型的上边界，则上边界默认为Object。 泛型的下限 格式：类型名称 &lt;? super 类&gt; 对象名称也就是说，可以通过这种方式定义此泛型接受的具体类型必须是限定的该类型或其父类类型。 eg:Integer extends Number extends Object Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;getElement1(list1);getElement1(list2);//报错getElement1(list3);getElement1(list3);//报错getElement2(list1);//报错getElement2(list2);//报错getElement2(list3);getElement2(list4);//泛型的上限：此时的泛型? 必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;//泛型的下限：此时的泛型? 必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"Java - 注解(Annotation)","slug":"java-annotation","date":"2019-04-30T04:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/04/30/java-annotation/","link":"","permalink":"https://blog.alphabethub.com/2019/04/30/java-annotation/","excerpt":"","text":"定义注解，也叫元数据；一种代码级别的说明，是JDK1.5之后版本引入的一个特性，与接口、类、枚举在同一个层次。可以声明在包、类、字段、局部变量、方法参数等的前面，用来对这些元素进行注释说明。 说明：可用于取代xml、properties配置文件，给对象(Class,Field,Method)添加配置 作用分类 编写文档：通过代码里标识的元数据(注解)生成文档（doc） 代码分析：通过代码里标识的元数据(注解)对代码进行分析（利用反射） 编译检查：通过代码里标识的元数据(注解)让编译器能够实现基本的编译检查（Override） JDK中预定义的一些注解@Override检测被该注解标注的方法是否是继承父类（接口）的 jdk5表示当前被修饰的方法，必须覆写的父类中的方法 jdk6表示当前被修饰的方法，可以实现接口 @Deprecated该注解标注的内容，表示已过时 @SuppressWarningsrawtypes： 没有泛型信息unchecked： 给没有泛型信息的集合添加数据不进行数据验证unused： 没有使用deprecation： 方法过期null ：数据为nullserial：实现implements java.io.Serializable，但没有提供序列号IDall ：所有注意 压制警告，一般传递参数all @SuppressWarnings(&quot;all&quot;)，扩展用于类、方法、字段等 自定义注解格式public @interface 注解名称&#123; 属性列表;&#125; 本质注解本质上就是一个接口，该接口默认继承(extends)Annotation接口source： public interface MyAnno extends java.lang.annotaion.Annotation&#123;&#125; 属性类同接口中定义成员抽象方法，但是在注解中称之为属性。注解属性格式：修饰符 类型 字段名称() [default 默认值]eg: public @interface MyAnno&#123; [public] [abstract] int show(); String name(); //枚举类型 Genger gender(); //其他注解类型 MyAnno anno2(); //数组类型 String[] strs();&#125; 属性的返回值类型取值范围 基本数据类型 String 枚举 注解 以上类型的数组形式 注意：注解中所定义的属性返回值类型不可以是void 注解属性的赋值使用 使用格式：@注解名称(属性名称=值) 若定义属性时，使用了default关键字给属性以默认初始化值，则在使用注解时，可以不进行属性的赋值。public @interface MyAnno&#123; String name() default \"techbird\";&#125; 特别的：若属性名称为value，且属性只有一个时；那么在对属性赋值时候，value可省略，直接定义值即可@MyAnno(value = 12)public class Test&#123;&#125; 多个属性赋值需要用逗号分隔@MyAnno(value = 12,gender = Gender.Man,anno2 = @MyAnno,strs = &#123;\"a\",\"b\"&#125;) 如果属性类型为数组，赋值时需要用{}包裹，如果只有一个值时，{}可省略 元注解用于描述注解的注解成为元注解。 @Target@Target(ElementType)注解标记另外的注解用于限制此注解可以应用哪种Java元素类型 ElementType.TYPE:接口、类、枚举ElementType.FIELD:字段、枚举的常量ElementType.METHOD:方法ElementType.PARAMETER:方法参数ElementType.CONSTRUCTOR:构造函数ElementType.LOCAL_VARIABLE:构造函数ElementType.ANNOTATION_TYPE:注解ElementType.PACKAGE:包ElementType.TYPE_PARAMETER:Java8 引进，类型参数声明，可以应用于类的泛型声明之处ElementType.TYPE_USE:Java8 引进，此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查，ElementType.TYPE_USE包含了ElementType.TYPE和ElementType.TYPE_PARAMETER 注意：如果一个注解没有指定@Target注解，则此注解可以用于除了TYPE_PARAMETER和TYPE_USE以外的任何地方。 @Target(value=&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno&#123;&#125; @Retention@Retention(RetentionPolicy) 注解标记其他的注解用于指明标记的注解保留策略 @Retention(RetentionPolicy.SOURCE)：表示注解会在编译时被丢弃。@Retention(RetentionPolicy.CLASS) ：默认策略，表示注解会在编译后的class文件中存在，但是在运行时，不会被VM保留@Retention(RetentionPolicy.RUNTIME)：表示不仅会在编译后的class文件中存在，而且在运行时保留，因此它们主要用于反射场景，可以通过getAnnotation方法获取。 @Documented在使用javadoc生成api时，将被修饰的注解添加上。 @Inherited@Inherited 所修饰的注解，表示使用到该注解所标记的注解的类的所有子类，都继承当前注解。 使用(在程序中解析注解) 获取注解定义的位置的对象(Class,Field,Method) 获取制定的注解：位置对象.getAnnotation(Annotation.class) 调用注解中的抽象方法获取配置的属性值 eg: 定义注解 @Target(value = &#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno &#123; String className(); String methodName();&#125; 定义类并使用所定义的注解 @MyAnno(className = \"me.techbird.reflect.Test\",methodName = \"show\")public class Demo &#123; public static void main(String[] args) throws Exception&#123; Class&lt;Demo&gt; demoClass = Demo.class; //下面一行代码相当于内存中搞了一个MyAnnoImpl类复写了两个抽象方法 MyAnno annotation = demoClass.getAnnotation(MyAnno.class); String className = annotation.className(); String methodName = annotation.methodName(); Class&lt;?&gt; aClass = Class.forName(className); Object obj = aClass.newInstance(); Method method = aClass.getMethod(methodName); method.invoke(obj); &#125;&#125; 反射注解 检查类/方法/类变量/构造方法是否有具体的注解,获取注解,根据注解来执行不同的操作AnnotatedElement定义了如下方法,而Class/Method/Field/Constructor都实现了这个接口,所以通过这些对象都可以调用如下方法在类/方法/成员变量/构造器上获取或判断是否包含指定的注解 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)如果存在该元素的指定类型的注解，则返回这些注解，否则返回 null。 Annotation[] getAnnotations()返回此元素上存在的所有注解。 Annotation[] getDeclaredAnnotations()返回直接存在于此元素上的所有注解。 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。 注意一个对象一个注解只能使用一次","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"Java - 反射(Reflect)","slug":"java-reflect","date":"2019-04-30T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/04/30/java-reflect/","link":"","permalink":"https://blog.alphabethub.com/2019/04/30/java-reflect/","excerpt":"","text":"定义反射是框架设计的灵魂。Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 Class一个Java类中用一个Class类的对象来表示，一个类中的组成部分：成员变量(Field)，方法(Method)，构造方法(Constructor)，包(Package)等等信息也用一个个的Java类来表示 获取Class对象的三种方式：//Class.forName(“全类名”)，多用于配置文件中Class cls1 = Class.forName(\"me.techbird.base.Person\");//类名.class，多用于参数的传递Class cls2 = Person.class;//对象.getClass()，多用于拥有对象的情况下获取字节码Person p = new Person();Class cls3p.getClass(); 结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，无论使用哪一种方式获取的对象都是同一个。 九个预定义的Class： 包括八种基本类型（byte、short、int、long、float、double、char、boolean）的字节码对象和一种返回值为void类型的void.class。 Integer.TYPE是Integer类的一个常量，它代表此包装类型包装的基本类型的字节码，所以和int.class是相等的。基本数据类型的字节码都可以用与之对应的包装类中的TYPE常量表示 只要是在源程序中出现的类型都有各自的Class实例对象，如int[].class。数组类型的Class实例对象，可以用Class.isArray()方法判断是否为数组类型的。 Class类中的常用方法static Class&lt;?&gt; forName​(Module module, String name)Annotation[] getAnnotations()ClassLoader getClassLoader()String getName()T newInstance()Class&lt;? super T&gt; getSuperclass()String getSimpleName()boolean isPrimitive()//是否是基本类型 注意：字节码文件作比较时候建议使用==而不是equels，因为字节码在内存中只有一份。 FieldField getField​(String name):获取所有public修饰的成员变量Field[] getFields():获取指定名称的public修饰的成员变量Field getDeclaredField​(String name):暴力获取指定名称的成员变量，不考虑修饰符Field[] getDeclaredFields():暴力获取所有成员变量，不考虑修饰符 ConstructorConstructor&lt;T&gt; getConstructor​(Class&lt;?&gt;... parameterTypes):获取public的带参构造方法 //带参数Constructor con1 = cls.getConstructor(String.class,int.class);//不填参数是即为获取空构造方法Constructor con2s = cls.getConstructor();//拿到构造方法之后便可以调用constructor.newInstance(...)方法来构造对象 Constructor&lt;?&gt;[] getConstructors():获取所有构造方法Constructor&lt;T&gt; getDeclaredConstructor​(Class&lt;?&gt;... parameterTypes)Constructor&lt;?&gt;[] getDeclaredConstructors() MethodMethod getMethod​(String name, Class&lt;?&gt;... parameterTypes) //带参数Method method1 = cls.getMethod(\"show\", int.class);//不带参数Method method2 = cls.getMethod(\"show\"); Method[] getMethods()Method getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes)Method[] getDeclaredMethods()Object invoke​(Object obj, Object... args):调用方法 说明: 如果传递给Method对象的invoke()方法的第一个参数为null，说明Method对象对应的是一个静态方法 PackagePackage getPackage() :获取当前类的包对象String getPackageName() :获取当前类的包字符串 数组的反射int [] a1 = new int[]&#123;1,2,3&#125;;int [] a2 = new int[4];int[][] a3 = new int[2][3];String [] a4 = new String[]&#123;\"a\",\"b\",\"c\"&#125;; 具有相同维数和元素类型的数组属于同一个类型，即具有相同得Class实例对象. System.out.println(a1.getClass() == a2.getClass());System.out.println(a1.getClass() == a4.getClass());System.out.println(a1.getClass() == a3.getClass()); 代表数组的Class实例对象的getSuperclass()方法返回的是Object类对应的Class. System.out.println(a1.getClass().getName());System.out.println(a1.getClass().getSuperclass().getName());System.out.println(a4.getClass().getSuperclass().getName()); 基本类型的一维数组可以被当做Object类型使用，不能当做Object[]类型使用；非基本类型的一维数组，既可以当做Object类型使用，又可以当做Object[]类型使用. Object aObj1 = a1;Object aObj2 = a4;//Object[] aObj3 = a1; //不成立Object[] aObj4 = a3;Object[] aObj5 = a4; Arrays.asList()方法处理int[]和String[]时候的差异. System.out.println(a1);System.out.println(a4);System.out.println(Arrays.asList(a1));System.out.println(Arrays.asList(a4)); 利用java.util.reflect.Array类完成对数组的反射操作. //可以打印一个obj和一个obj数组的方法private static void printObject(Object obj) &#123; Class clazz = obj.getClass(); if(clazz.isArray())&#123; int len = Array.getLength(obj); for(int i=0;i&lt;len;i++)&#123; System.out.println(Array.get(obj, i)); &#125; &#125;else&#123; System.out.println(obj); &#125;&#125; 如何获取数组中的元素的类型 Object[] objs = new Object[](\"a\",1);a[0].getClass().getName(); 暴力反射如果想要获取非public类型的Field、Constructor、Method等，需要在执行Declared方法前设置以下代码： obj.setAccessable(ture); 用反射技术执行某个main方法//反射方式 Class clazz=Class.forName(“className”); Method methodMain=clazz.getMethod(\"main\",String[].class); //方式一：强制转换为超类Object，不用拆包 methodMain.invoke(null, (Object)new String[]&#123;\"123\",\"456\",\"789\"&#125;); //方式二：将数组打包，编译器拆包后就是一个String[]类型的整体 methodMain.invoke(null, new Object[]&#123;new String[]&#123;\"123\",\"456\",\"789\"&#125;&#125;);","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"Junit的使用","slug":"java-junit","date":"2019-04-29T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/04/29/java-junit/","link":"","permalink":"https://blog.alphabethub.com/2019/04/29/java-junit/","excerpt":"","text":"使用步骤 定义一个测试类（测试用例） 测试类名：被测试的类名+Test eg: CaculatorTest 包名：xxx.xxx.xxx.test eg: me.techbird.test 定义测试方法：可以独立运行 方法名：test+被测试的方法名 eg: testAdd() 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖环境 判定结果 红色：失败 绿色：成功 一般可以使用断言操作来处理结果：Assert.assertEquals(期望的结果，运算的结果); 补充 @Before 修饰的方法会在测试方法执行之前被自动执行 @After 修饰的方法会在测试方法执行之后被自动执行","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"Idea快速入门","slug":"idea-shortcuts","date":"2019-04-11T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2019/04/11/idea-shortcuts/","link":"","permalink":"https://blog.alphabethub.com/2019/04/11/idea-shortcuts/","excerpt":"","text":"Idea快速入门指南1.安装1.1.安装我们使用的是最新的2017.3.4版本： 双击打开， 选择一个目录，最好不要中文和空格： 然后选择桌面快捷方式，请选择64位： 然后选择安装： 开始安装： 然后勾选安装后运行，Finish： 1.2.首次配置 然后是UI界面选择，有白色和黑色两款，总有一款适合你： 把不需要的组件禁用： 插件暂时不选择安装，以后有需求还可以来安装： 然后进入运行界面： 激活Idea： 这里有三种激活方式： 第一种:购买正版用户(如果有资金最好选择正版) 第二种:激活码(这种方法在下面有讲解) 第三种:在线激活(有一个过期时间，这个时间一过就必须再次联网授权服务器请求激活) 土豪请选择第一种，每年大概不到$700 非土豪，请参考：http://idea.lanyus.com/ 中的教程。 激活完成，就可以开始撸代码了： 2.配置我们在启动界面打开配置页面： 进入idea以后，我们可以进行一系列配置。 2.1.字体和主题： 另外，主题也可以到网上下载，但是建议大家不要去浪费时间了。 2.2.启动项： 2.3.快捷键类名自动补全： 默认并不是Alt + /。而大家玩eclipse比较熟悉了，所以我们改成Alt + / 代码生成： 默认的代码生成快捷键：Alt + insert。很多同学电脑中没有 Insert 按键。 因此这里需要修改，大家自己选择。我设置的是Alt + I 还有快捷弹出 New菜单： 默认是Alt+Insert，没有Insert按键的同学，可以修改。我设置的也是Alt+ I 2.4.代码联想 2.5.编辑器字体： 2.6.编码 2.7.mavenidea自带的maven版本是3.3.9，我们一般不需要指定自己的。不过我们可以指定settings.xml来修改自己的仓库地址。 2.8.ES6语法支持 2.9.Vue插件安装 3.常用快捷键 快捷键 作用 Ctrl + Y 删除一行 Ctrl + D 复制一行 Ctrl + Alt + L 格式化 Ctrl + Alt + O 导包 Alt+Insert（可修改） New菜单\\代码生成菜单（生成getter和setter，maven依赖等） Ctrl + / 注释 Ctrl + Shift + / 多行注释 Ctrl + Alt + 左/右 回退到上一次操作的地方，等于eclipse中的 Alt+左/右 Shift + Alt + 上/下 将代码上移或下移一行 Ctry + H ：罗列类的继承关系 4.代码补全idea有很多的代码自动补全功能，有两个地方可以设置： 还有一个： 其作用演示： 通过后缀的方式快速完成一些代码的补全，一般写完后缀，按tab或回车即可。罗列一些比较常用的： 代码 效果 psvm 自动生成main函数 .var 自动为对象生成声明 sout 输出：System.out.println() .if 生成if判断 .for 生成循环，默认是高级for fori 用普通for进行遍历 .try 生成try … catch 5.project与module5.1.idea的maven理念在Idea中，没有工作空间的概念，每一个Project就是一个独立的文件夹，也是一个独立的窗口。然后我们可以在Project中创建多个Module。 是不是感觉与maven的项目结构完全一致？ 说对了，idea就是完全贯彻了maven的理念。 5.2.小技巧熟悉eclipse的同学会觉得很不方便，无法在一个界面中创建很多的工程。 不过有一个取巧的办法：我们可以创建一个empty的工程： 然后选择empty工程： 然后填写名称： 点击Finish： 但是接下来，就不要再新建Project了，而是新建Module，Module就类似原来的工程的概念： 然后创建一个maven工程： 然后填写项目信息： 填写项目位置信息： 界面结构： 6.打开springboot的run dashboard先看下run dashboard是什么： 可以看到，这里可以同时显示多个springboot项目，非常方便。 默认情况下，idea的run dashboard是关闭的，当检测到你有多个springboot项目时会弹出提示框，询问是否打开。 如果我们想要自己打开，需要修改配置。 在你的idea的项目目录中，有一个.idea目录： 其中，有一个workspace.xml： 打开，搜索Rundashboard，找到下面这段： 然后在Component中添加下面的内容： &lt;option name=\"configurationTypes\"&gt; &lt;set&gt; &lt;option value=\"SpringBootApplicationConfigurationType\" /&gt; &lt;/set&gt; &lt;/option&gt; 常用小技巧IDEA 常用快捷键 Alt+Enter ：自动修正代码 Option+/：自动补全提示 Cmd+F12 显示当前类的方法和变量列表 Shift+F6 重构名称 Cmd+Shift+/ 利用/*注释*/方式选中的代码 Command+Option+t 选中代码添加try/catch Debug F8：逐行执行程序 F7：进入到方法中 Shift+F8：跳出方法 F9：调到下一个断点 Ctrl+F2：退出debug模式，停止程序 IDEA 编写代码小技巧 方法.var ：.var的使用可以直接创建好getInstance方法的返回值对象 eg: Calendar.getInstance().var fori ：可以直接list.fori eg: ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.fori //生成下面的代码 /* for (int i = 0; i &lt; list.size(); i++) &#123; &#125;*/ psvm：自动生成main方法 sout：自动生成打印语句 foreach：可以直接list.for eg: list.for //生成下面的代码 /* for (String s : list) &#123; &#125;*/ iter同foreach的功能一样，底层其实都是封装了迭代器","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Idea","slug":"Idea","permalink":"https://blog.alphabethub.com/tags/Idea/"}]},{"title":"Java 7、8、9+版本的一些新特性","slug":"java-upgrade-note","date":"2019-04-10T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/04/10/java-upgrade-note/","link":"","permalink":"https://blog.alphabethub.com/2019/04/10/java-upgrade-note/","excerpt":"","text":"集合JDK1.7之前，创建集合对象必须把前后的泛型都写上；JDK1.7之后，后面的反省可省略，会自动推导。 内部类从JDK1.8开始只要局部变量事实上不变，那么内部类访问外部变量时，final关键字可以省略。 哈希表JDK1.8之前是哈希表=数组+链表结构。从JDK1.8开始，哈希表=数组+链表/红黑树（提高查询的速度），如果链表的长度超过了8位，就会把链表转换为红黑树结构。 Objects类在JDK1.7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的使用方法组成。这些方法是null-save(空指针安全)、null-tolerant（容忍空指针），用于计算对象的hashcode，返回对象的字符串形式、比较两个对象。在比较两个对象的时候Object的equals方法容易抛出空指针异常，而Objects类中的equals就优化了这个问题，方法如下: public static boolean equals(Object a, Object b)&#123; return (a == b) || (a != null &amp;&amp; a.euals(b));&#125; IO流异常JDK1.7之前的写法：try&#123;&#125;catch(异常类变量 变量名)&#123;&#125;finally&#123;&#125; JDK1.7之后的写法：try(定义对象1;定义对象2;...)&#123; //定义的对象作用范围仅在此大括号内&#125;catch(异常类变量 变量名)&#123;&#125; JDK1.9之后：try前面也可以定义流对象，在try后面的()中可以直接引入流对象的名称(变量名)；在try执行完毕后，流对象也可以释放掉，不用写finally。但是比较麻烦的是既需要 throws 也需要try catch。 A a = new A();B b = new B();tru(a,b)&#123;&#125;catch(异常类变量 变量名)&#123;&#125; Lambda表达式JDK1.8开始，Oracle加入了Lambda表达式重量级新特性；函数式接口在Java中是指，有且仅有一个抽象方法的接口，称为函数式接口；即适用于函数式编程场景的接口，在Java中函数是编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且只有一个抽象方法，Java中的Lambda才能顺利的进行推导。 Lambda接口修饰符 interface 接口名称&#123; [public] [abstract] 返回值类型 方法名称(可选参数信息); //其他非抽象方法(默认，静态，私有)&#125; @FunctionalInterface这个注解可以确保我们定义的接口是一个函数式接口，也就是接口中有且必须只有一个抽象方法。 调用Lambda的标准格式： 由三部分组成： a. 一些参数 b. 一个箭头 c. 一段代码 格式：（参数列表）-&gt; {一些重写方法的代码}; 特性：可推导，可省略 可省略的内容： (参数列表)：括号中参数列表的数据类型，可以省略不写 (参数列表)：括号中参数如果只有一个，那么类型和()都可省略 {一些代码}：如果{}中代码只有一行，无论是否有返回值，都可以省略({},return,分号)注意：要省略{},return,分号必须一起省略 常用的函数式接口JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景，他们主要在java.util.function 包中被提供。 eg:Supelier 中方法有：get()Consumer 中方法有：andThen(Consumer)、accept(T)Predicte 中方法有：and(Predicte)、or(Predicte)、negate()、test(T)、isEqual(Object)Function 中方法有：andThen(Funtion)、apply(T)、conpose(Function)、identity() 使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda 使用Lambda必须具有上下文上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 方法引用(Method Reference)对象名引用成员方法对象引用::实例方法名 obj::method public class Demo &#123; public void printString(Printable lambda)&#123; lambda.print(\"Hello\"); &#125; public static void main(String[] args) &#123; Demo obj = new Demo(); obj.printString(System.out::print); &#125;&#125; 类名引用静态方法类名::静态方法名 Class::method public static int method(int num,Calcable lambda)&#123; return lambda.calcAbs(num);&#125;public static void main(String[] args) &#123; int number1 = method(-10, (num) -&gt; &#123; return Math.abs(num); &#125;); System.out.println(number1); //省略写法 int number2 = method(-10, num -&gt; Math.abs(num)); System.out.println(number2); //静态方法引用 int number3 =method(-10,Math::abs); System.out.println(number3);&#125; this引用本类成员方法this::method super引用父类成员方法super::method 类构造器引用类名::new 数组构造器引用类型[]::new Stream流说到Stream很容易联想到I/O Stream，实际上两者是完全不同的概念。在JDK1.8中，得益于Lambda所带来的函数式编程，引入了一种全新的Stream概念，用于解决已有集合类库/数组既有的弊端。eg: list.stream().filter(name-&gt;name.starWith(\"zhang\")) .filter(name-&gt;name.length == 3) .forEach(name-&gt;System.out.println(name)); 延迟方法返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其他均为延迟方法）例如：filter、map、skip、limit等 终结方法返回值类型不再是Stream自身接口类型的方法，因此不再支持StringBuilder那样的链式调用。例如：forEach和count 静态方法Stream.of(1,2,3)//把Int数组转为Stream流Stream.concat(stream1,stream2);//合并两个流为一个 Interface(接口)在Java 9+的版本中，接口包含的内容有如下： 成员变量其实是常量，格式：[public] [static] [final] 数据类型 常量名称 = 数据值;注意：常量必须进行赋值，而且一旦赋值不能改变。 常量名称完全大写，用下划线进行分割。 接口中最重要的就是抽象方法，格式：[public] [abstract] 返回值类型 方法名称（参数列表);注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。 从Java 8开始，接口里允许定义默认方法，格式：[public] default 返回值类型 方法名称（参数列表）{方法体}注意：默认方法也可以被覆盖重写 从Java 8开始，接口里允许定义静态方法，格式：public static 返回值类型 方法名称（参数列表）{方法体}注意：应该通过接口名称进行调用，不能通过实现类对象调用静态方法（因为多实现中可能存在相同的方法） 从Java 9开始，接口里允许定义私有方法，格式：普通的私有方法：private 返回值类型 方法名称（参数列表){方法体}静态的私有方法：private static 返回值类型 方法名称(参数列表){方法体}注意：private的私有方法只有接口自己才能调用，不能被实现类或别人使用。 注意： 接口中没有静态代码块或者构造方法 接口中没有静态代码块或者构造方法","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"Java 内存划分","slug":"java-memo-devide","date":"2019-04-10T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2019/04/10/java-memo-devide/","link":"","permalink":"https://blog.alphabethub.com/2019/04/10/java-memo-devide/","excerpt":"","text":"栈（Stack）存放的都是方法中的局部变量局部变量：方法的参数或方法内部的变量作用域：一旦超出作用域，立刻从堆内存中消失 堆（Heap）凡是new出来的都在堆内存中堆内存中的东西都有一个地址值：十六进制堆内中的数据都有默认值，规则：如果是整数 默认为0如果是浮点 默认为0.0如果是布尔 默认为false如果是引用类型 默认为null 方法区（Method Area）存储.class相关信息，包含方法的信息方法区中包含存储静态方法的静态区，静态方法属于其对应的类 本地方法栈 (Native Method Stack)与操作系统相关 寄存器（pc Register）与CPU相关","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.alphabethub.com/tags/Java/"}]},{"title":"回忆是一场逆旅","slug":"daily-2019-0409","date":"2019-04-09T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2019/04/09/daily-2019-0409/","link":"","permalink":"https://blog.alphabethub.com/2019/04/09/daily-2019-0409/","excerpt":"","text":"回忆是一场逆旅 人们号称最幸福的岁月其实往往是最痛苦的，只不过回忆起来非常美好。白岩松 很想再登上那列突突突的火车，回到2012年见一面当初的自己，回到2012年的10月7日的长治车站，看一眼你转身的背影，黑色的卫衣，中长的头发，青涩的脸，一个黑青色的斜挎包。 我想告诉你，人是可以改变自己的。只要你一直坚持和努力，并且拥有巨大的决心，你每一段痛苦的煎熬的时光都会迎来与之匹配的喜悦、感动和收获。你要一直敢于做自己害怕的事情、做自己不擅长的事情，并时常反思自己。要拥有可以归零的心态和重新出发的勇气，有了这些你就能成为你想要成为的任何人。 时光匆匆，这一切已经过去了七年之久。而你也已经毕业-工作-考研，要对你说一声恭喜啊，恭喜你暂时成为了你想要成为的人！我清楚你离开家里时候的决绝，理解你登上北上列车时候的心情，熟悉你在熬过的每一个凌晨，更知道考研的每一个日日夜夜中你夜不能寐，辗转反侧的焦虑和煎熬。是啊，现在可以说：这一切都过去了！但也正是这所有的经历才构成了现在的你啊，不是吗？ 人最大的改变就是去做自己害怕的事情。 再一次来到济南，同一个车站。20121008/20190405 七年之隔，涨了岁月，多了沉淀。虽都是新阶段开始的前奏，却也怀着不一样的心境。希望就此走开去，构建让自己更认可的人生。 后记：你才25岁，黄金年龄中的黄金年龄，你还有机会成为任何你想成为的人。所谓幸福并不是未来的某个时刻和过去的某个瞬间，而是活在当下的一种心态。愿你内心仍有着某种不灭的火焰，那样才会把你和别人区分开来。愿你不负青春韶华，持续把困难的事做成。愿你今后的旅程，一路平安，桥都坚固，隧道都光明。 2019/04/09 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"线性代数的知识结构图","slug":"linear-maths","date":"2018-07-15T16:42:17.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2018/07/15/linear-maths/","link":"","permalink":"https://blog.alphabethub.com/2018/07/15/linear-maths/","excerpt":"","text":"如题，给「线性代数」做了点小总结。 行列式 矩阵 n维向量 线性方程组 特征值/特征向量 二次型","categories":[],"tags":[]},{"title":"环琼计划","slug":"journey-hainan","date":"2018-02-10T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2018/02/10/journey-hainan/","link":"","permalink":"https://blog.alphabethub.com/2018/02/10/journey-hainan/","excerpt":"","text":"环琼计划 海南岛成卵圆形，海口至三亚大致可分东中西三线，也即G223、G224、G225三条国道线路：其中东线G223全长323公里，因部分靠海，且风景更为清秀，骑行者最多，G225全长429公里，即环岛西线，由三亚经东方、儋州返回海口。 建议使用百度地图的骑行功能：国道+县道+乡道结合风景更好，也远离过往车辆的噪音。 车辆从海口捷安特租赁（提前从电话或网上联系：0898-88261164） 参考攻略：点击路线：D1：海口-三江镇-清澜镇 （41+54=95KM） D2：清澜镇-长坡镇-博鳌镇（42+43=85KM） D3：博鳌镇-万宁市-兴隆（59+26=85KM） D4：兴隆-陵水-海棠湾-三亚（40+35+40=115KM）D5，D6：浪三亚。D7：三亚-天涯镇-佛罗镇 (80KM）D8：佛罗镇-叉河镇（99KM）D9：叉河镇-儋州市（87KM）D10：儋州市-海口（115KM）装备列表： 车辆：备胎（补胎片），手电筒，打气筒，挡泥板，驼包（防雨罩），捆扎绳，水壶，修车工具刀 个人：头盔，骑行眼镜，魔术头巾，全指手套，束裤带 ，骑行护膝 ， 衣物：骑行内裤，雨衣雨裤，普通线手套 其他：塑料袋（装衣服，防雨防水），拖鞋 洗漱用品：刷牙套装，洗发水（袋装） 设备：相机（座充），手机（充电器） 美食： 经典菜式：除海鲜外，海南的文昌鸡、嘉积鸭、东山羊、和乐蟹并称海南四大名菜。顾名思义，这些以地名命名的美食，最好还是前往当地品尝。 椰子八宝饭：又叫椰子船，是文昌、琼海一带的小吃，把糯米、椰浆装入原只椰肉蒸熟而成，食用时像切西瓜一样把椰子肉瓢切开，状如船形。 清补凉：清补凉是海南岛的特色冰凉甜品，原料有绿豆、薏米、花生、空心粉、椰肉、红枣、西瓜粒、菠萝粒、鹌鹑蛋、凉粉、椰奶等。 海南粉:：海南粉也叫海口腌粉，是海南米粉大家族中的鼻祖，是米粉与十几种色味独特的佐料腌制而成的。 抱罗粉：抱罗粉是一种米粉，比“海南粉”略粗，当地俗称“粗粉汤”，以文昌市抱罗镇所产的最为出名。烫熟冷却的米粉，加入炒花生米、炒芝麻、笋丝、酸菜、牛肉干丝、炒猪肉丝，蒜香熟油、香菜、葱花，再浇一勺滚烫靓汤，便可成就一碗独特美味。 老爸茶：老爸茶是海南海口市的特色茶文化的代表，融国内老人品茶社交习惯与归侨带回的西式生活方式为一体。老爸茶店在经营内容上也是中西结合，既有西式茶点，也有中式餐点，还兼有各地的地方小吃。 参考攻略：点击 景点： 天涯镇：天涯海角 清澜镇：东郊椰林日出 注意事项：","categories":[{"name":"Journey","slug":"Journey","permalink":"https://blog.alphabethub.com/categories/Journey/"}],"tags":[{"name":"Journey","slug":"Journey","permalink":"https://blog.alphabethub.com/tags/Journey/"}]},{"title":"路遥以怎样的态度对待写作 - 读《早晨从中午醒来》","slug":"read-zcczwxl","date":"2018-01-15T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2018/01/15/read-zcczwxl/","link":"","permalink":"https://blog.alphabethub.com/2018/01/15/read-zcczwxl/","excerpt":"","text":"早晨从中午醒来 作为一部随笔，抛开什么文学性，艺术性。路遥告诉我们他是以怎样得态度对待写作。一直坚信，有些文字是有重量的，而且会在时间的流里慢慢地积淀它的力量，然后或者让人感到温暖，或者让人觉得寒冷。 《早晨从中午开始》是路遥的创作随笔，非常完整地记录了他创作《平凡的世界》的过程以及他的心路历程。当人们尝试着去寻找在过去时间里的自我时会产生很多维度的距离，而这些距离的产生无疑会更改着文字所要表达的意义。 记忆中的那些日子沉默而清晰，当最艰苦的劳动变得死一般苍白，于是便开始吸入秋天冷冽的气息，冬天在不久之后即将到来，用写下文字的笔捣毁那些珍贵的瞬间，然后将它们到处抛撒，最终将常常不得不从椅子中起来，移向其它的伤心事，落入其它的陷阱。那种透彻心扉的寒冷是必须独自面对并且切身经历的，而且这也正是所有温暖的真正根源。 这种为文学而奋斗的人生，虽然短暂，但却独绝并无比地震撼人心。在这个依旧甚至从来都是平凡的世界里，能把创作当成生命的人需要怎样的勇气！ “在这里，我才清楚地认识到我将要进行一次命运的‘赌博’（也许这个词不恰当），而赌注则是自己的青春抑或生命。尽管不会让世俗的观念操纵我的意志，但如果说我在其中没有作出任何世俗的考虑，那就是谎言。无疑，这部作品将耗时多年，如果将来作品有某种程度的收获，这还多少对抛洒的青春热血有个慰藉。如果整个地失败，那将意味着青春乃至生命的失败。这是一个人一生中最好的一段年华，它的流失应该换取最丰硕的果实——可是怎么可能保证这一点呢！” 最终路遥赢了，他用一部《平凡的世界》鼓舞了所有平凡的人生们，但在做完这个“一生中最重要的一件事”之后不久，他也把自己的生命永远地交付给了自己的作品融入字里行间而匆匆告别人世。 或许道理真的很简单：“任何一个人，尤其是一个有某种抱负的人，在自己的青少年时期会有过许多理想、幻想、梦想，甚至是妄想。这些玫瑰色的光环大都会随着时间的流逝和环境的变迁而消散得无影无踪。但是，当一个人在某一方面一旦具备了某种实现雄心抱负的条件，早年间的梦想就会被认真地提升到现实中并考察其真正复活的可能性。” 但是又有多少人能够做到呢？ 2018/01/15 北京","categories":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/categories/Readed/"}],"tags":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"以怎样的态度面对生活 - 读《平凡的世界》","slug":"read-pfdsj","date":"2018-01-09T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2018/01/09/read-pfdsj/","link":"","permalink":"https://blog.alphabethub.com/2018/01/09/read-pfdsj/","excerpt":"","text":"平凡的世界 不要见怪，不要见外，田。命运总是不如人愿。但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来。虽然这些东西在实际感受中给人带来的并不都是欢乐。 坦率的说，我是没有‘勇气’来写自己对着这本书的感受的，因为在书中我热爱的每一个角色，都没有得到我预想的故事的结局。比如我是不能释怀田晓霞的离去的，也请原谅我是这么的狭隘，不能理解所谓的社会背景下就应该有怎样的结局，故事在作者厚重的笔下让我喘不过气，让我难受，让我忍不住为他们的苦难泪眼迷蒙。 是的，我想要晓霞去赴古塔山杜梨树下与少平一点四十五分的约定！我不能接受田晓霞的死去，孙少平与田晓霞的爱情故事是这部现实主义小说中最为浪漫的一道彩虹，他们让我知道真正的爱情是超越门第，超越贫富，甚至超越生死的。虽然他们的社会身份有着巨大的差异，但在思想上却达到完美的融合。他们被彼此的气质所吸引，在海阔天空的思想交流中建立起深厚的友谊，而后又在更深的理解中将友情升华为爱情。这样的爱情稳固而坚贞，能够经受岁月的磨砺而焕然如新。 也是的，生活中无处不有纠结与挣扎，而现实与精神的双重痛苦常常使人彻底堕落，只有在无比的痛苦中还能巍然站立，有力把握着生活马车的车辕的人才是真正的强者！孙少安和孙少平就是这样的强者，他们经历过巨大的艰难与痛苦，却把艰难痛苦都当作人生的财富，始终紧握生活的马鞭，奔向各自道路的未知远方。 伟大的作品是用平实的语言去描写亘古不变的人情人性，虽然路遥的身躯早已回归到最亲爱的大地中去，而他却从未远离我们，因为他早已把灵魂注入到书中字里行间。他是孙少平，是小说中的每一处花开花落，草长莺飞，更是人物内心微妙地悸动和涌起地波澜。而这些融入他所有生命精华的著作也必将留芳于世，感动着现在以及以后的人们。 后记：在2018年研究生考试结束之后读这本书对我来说是合适的，《平凡的世界》之所以能感动这么多人是因为展现出平凡人在艰难的生活中仍能保持高尚的精神和灵魂，永远用一种积极向上的态度去面对一切苦难，相比于生活赐予少平的苦难和他对待生活的态度也只会使我更有勇气去面对未来我将要经历的一切… 2018/01/09 北京","categories":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/categories/Readed/"}],"tags":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"2018，我想和这个世界谈谈","slug":"daily-2017-1231","date":"2017-12-31T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2017/12/31/daily-2017-1231/","link":"","permalink":"https://blog.alphabethub.com/2017/12/31/daily-2017-1231/","excerpt":"","text":"题记：一年又一年，时光不断催人向前，2018，我想和这个世界谈谈，心平气和的娓娓诉说。 “We can not connect the dots looking forward; We can only connect them looking backwards.” 再次引用Jobs的这句话，站在2017即将走完的今天，回顾2017时候，我仍然坚定的相信在未来的某天，能够看到这一年的每一个决定和选择对于未来的意义。 2017，在这一年，终于完成挑战和梦想之旅，走完了318川藏段全程。 今年是我人生走过的第二十二个岁月，很多人在这个犯二的年龄都会做着自己喜欢的事情，不管对与错，因为我们年轻，青春是我们最大的任性。6月10日从成都出发，25天，2000多公里，25篇骑行日志记录了全程骑行的人和事，身高还是183，只是瘦了20斤。318三个简单的数字，对特定的一群人来说，勾勒出的，是意志力和耐力的见证，是想起来就会感动久久的回忆，而对我来说也应当是重要的转折点，318的故事很长，难以界定起点和终点，或者说，我不想知道哪里才是起止，一段旅行，一人，一车，仅此而已。我所认为的世界观是走出来的，看到的，听到的，真的也好，假象也罢，经历本身就很美好。 临行前的各种憧憬并期待，有些兴奋，想着应该会探索到很多想要的答案，可是到后来你会觉得，其实人生，并没有所谓的答案，可能一直就是在寻找中度过。6月6日，我和磊哥，带着各种装备，大包小包，飞离北京，那天的首都机场，暴雨整整倾泻了四个多小时，八点的航班晚点到十二点才起飞，到达成都青旅时已是凌晨四点。成都，凌晨四点仍然等候的阿铭，三巷一号调车的大哥，陪伴我走完全程的老七，你们好吗？相隔半年之期，关于这一切我已不再时常惦念，只是偶尔想起时会微笑，幸福的那种… 2017，终于考研了。 嘿嘿，这两个字说出来其实对于我承载着太多特殊的意义。如果说川藏之行是身体上的折磨和挑战的话，那么考研便是心理和精神上。（8.1-12.25）147页日历见证了走过的考研岁月,4篇考研日志记录了片段的考研心路历程。道长说其实人的一生改变命运的机会不多，而高考和考研便是其中为数不多的两次，此刻，当我端坐在电脑前，敲下这些文字的时候，距离2018研究生考试结束已经过去了5天，身体和精神上也都已不再是冲刺的状态，像是一根憋足了劲儿的弹簧，从考完的那一刻，从头到脚，无力感像潮水般涌来，专业课交卷的那一霎，我仰天长叹，这一叹伴着呼吸在零度的长治凝结成白色的雾气，我望着它缓缓地升腾，渐渐消散，最终分不清是雾气还是白云。再抬头，一缕阳光照在我的脸上，也照进我的心底。 当2018年全国硕士研究生统一考试的初试告一段落，当在凌晨六点生物钟自动醒来的时候，我想从某种意义上说，考研过程和结果本身都会在一定程度上影响一个人的生命的厚度，而且无关于成败。如果有人问我，考研给予我最多的是什么。我想就是考研岁月所经历的一切… 引用王江涛老师的的一句话说：“考研是人生中的小小驿站。人生关键处只有为数不多的几次选择，考研正是这样的一次拼搏。每当旭日东升，正处于酣战中的你突然觉得前途渺茫的时候，请记住四个字：“永不放弃！”，多年以后当珍贵的大学光阴已经随风而逝时，希望还能记得今天，记得2017年这场残酷而美丽的战斗。” 但行好事，莫问前程。后记：考研恍若一梦，愿大家都能笑着醒来。 2017/12/31 长治","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"考研日记","slug":"daily-kaoyan","date":"2017-12-30T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2017/12/30/daily-kaoyan/","link":"","permalink":"https://blog.alphabethub.com/2017/12/30/daily-kaoyan/","excerpt":"","text":"考研日记（四）￼ 老罗说，所有的失败都是因为半途而废。当自习室里越来越多的人弃考，大多数人进入极度的疲惫期，午休的时间比之前都加长，我一定会坚持到最后，在绝望中寻找希望! 如果当你全身心努力去付出后，结果不像理想中那样，还是会很难以接受，毅力根本不是问题，坚持也根本不是问题，只是时间问题。换个角度，努力和经历本身就是一种收获。洗把脸吧，继续奔赴下一个黎明。 11/01 北京 考研日记（三） 因为你选择了考研，所以你就已经成了你想成为的模样。9月2日，北师开学的日子，迎来新的面孔，送走旧的脸庞，悬挂的横幅上写着：欢迎201x级新同学。这让我想起2012年，在送别父亲的车站，你流着眼泪，带着微笑，穿过熙熙攘攘的人群，在心里和曾经说再见时的希望所向。 9月15日，中秋节的自习室有一丝空旷，不，是空空荡荡。晚上的时候我在木铎下和你说：没事儿，这不过是万千思绪中的一种，你要去的是大海的方向，风浪必然会是你的衣裳，你乘着它，便是远方。 9月26日，平日里温暖的自习室，参加司考的同学结束了最后的审判，低头收拾铺着的行囊的时候，不经意间在这个秋日的午后，剩下一地的考研er依然坚强。隔墙的走廊变得只有偶尔能听见的几簇上下课走动的声响。你忽地觉得孤单，忽又觉得仓促而又漫长。并不是因为你太容易过于感伤，也不是因为日子就这样一天天成为过往。 9月30日，在你来不及回望的每个清晨，在东门你驻脚等候的620的站牌旁，你抬头看漫天星辰的时候，你的背影满目八月的模样。 10/01 北京 考研日记（二） 选择考研，就如同选择种下一粒种子，坚持就会生长，直至参天。 嘿，九月，你好啊！嘿，时光，能不能别走的这么快啊！ 当我背起书包出门，乘着620穿过安立路去了又回，这两个简单的场景便能勾勒出八月的每一个日出和日落。九月的北京，秋天在睡醒一觉后就慕地来临，在清晨睁开眼透过窗外看北五环楼林的时候，彼时天空是那种迷人的蓝，你忽地觉得：岁月如此静好！如此静好！ 原谅我总是要在说正事之前煽情一番。因为，我也总是认为：当一个人在做自己认为值得和有意义的事情的过程中，有必要去记录某些时刻思想的经历和感悟。这样如果多年以后读起年青时写下的文字也定会是别样的思绪万千！努力做一个精神世界美好而富有的人嗬，虽然现实所经历的从不曾如想象那般尽如人意，但这也更能显得弥足珍贵。 Steve Jobs 说：“We can not connect the dots looking forward; We can only connect them looking backwards.”(我们不能把现在的每个点连接起来去看到未来，但是当我们回头看时，却能把它们串连起来看到对于过去的意义) 。对于一个已经离开校园漂泊很长时间的人来说，离开其实已经是一种勇气，而我理解中的考研过程本身也已变成是一个人内心和精神的修炼。彷徨与痛苦，挫折与欣喜，线条化的生活让人与世隔绝，人生失去颜色却又充满另一种芬芳。 话说如果你爱一个人，就让他考研，因为那里是天堂，又说如果你恨一个人，也让他考研，因为那里是地狱，当然我考研的动机既不是为了探寻生的理由和存在的意义，自然也不曾爱一个人或恨一个人到要和他一同考研的地步。我选择考研，只是想和一些时期的作为和不作为做个了断，只愿不再自我纠缠。而且这件事啊，非如此不可！非如此不可！我很喜欢戈麦的这首诗，因为有朝一日，真像终将大白于天下。 有朝一日，我会赢得整个世界有朝一日，我将挽回我的损失有朝一日，我将不停地将过去摔打珍视我的人，你没有伪装我将把血肉做成黄金，做成粮食献给你们庄重与博大爱我的人啊，我没有叫你失望你们的等待，虽然灰冷而渺茫但有朝一日，真相将大白于天下辛酸所凝铸的汗水将一一得到补偿 同样也很喜欢《功夫熊猫2》里面师傅对熊猫说的这句话： “Your story may not have such a happy beginning, but that doesn’t make who your are. It is the rest of your story, who you choose to be.”（你人生故事的开头也许不那么快乐，但这并不影响你成为什么样的人。关键看后来的人生路，你选择怎么走下去。） 09/01 北京 考研日记（一）今天，就算是这段旅程的开始我仍习惯性地把它称之为旅程我静坐于北师教九的一间教室试着去规划未来五个月的日子 我将重新开始沿着地平线努力拥抱每一个黎明和黄昏 我将再次出发指着大海的方向虔诚迎接每一个日出和日落 如果你在途中和我迎面走来请对我报以善意的鼓励和微笑并祝我一路顺风 08/01 北京 考研于我 所谓的光辉岁月，并不是后来闪耀的日子，而是无人问津时，你对梦想的偏执。 我想考研。毕业和离开，投身人海和朝九晚五之后，这个想法已经在心底愈来愈强烈。 总是被一个想法羁绊着，你无法描述那种感觉，但是，你一定会选择在某个时间去做，去实现它。那个想法像是一棵树，可能是因为一些是经历，慢慢生根，发芽，悄然直至有天你发现它已参天蔽日，枝枝蔓蔓充斥你的一切，然后，当决定了要去做的时候，一定要狠狠做，加倍做。 老妈说，出了社会还想回来难啊，是啊，我说人越成长就越少了想法，所以我想趁着我还有点想法，又有点年轻任性资本的时候，多做点想做的事情，想考研，就当是对梦想的偏执吧。 02/10 长治","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"川藏南线(318)之旅","slug":"journey-318","date":"2017-06-10T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2017/06/10/journey-318/","link":"","permalink":"https://blog.alphabethub.com/2017/06/10/journey-318/","excerpt":"","text":"写于川藏出发前 有些事现在不做，永远都不会去做了。 318国道，东起上海人民广场，西至中国与尼泊尔边界樟木口岸友谊桥，全长5476公里，是中国最长的国道。“那些伟大的景观不在318的两旁，就在道路南北不出200公里的范围内：钱塘江、西湖、太湖、黄山、庐山、鄱阳湖、洞庭湖、九华山、神农架、恩施、张家界、峨眉山……”而进入四川，318又被称为川藏公路，“贡嘎山、海螺沟、折多山、雅拉雪山、南迦巴瓦、加拉白垒，海拔8000米以上的马卡鲁峰、卓奥友峰、珠穆朗玛峰、希夏邦马峰……还有无数的雪山和冰川在这条大道的两旁。318国道从纵横中国大地的公路网中脱颖而出，成为了一条绵延万里的景观长廊。”2006年，318国道被《中国国家地理》评为“中国景观大道”（据百度百科和维基百科） 我这次的目标，就是走318国道最为壮丽的一段，成都-拉萨，川藏线。为了这次旅行，从4月开始跑5km储备体能，于5月31日正式离职，收拾行囊。我一直相信，真正的美景始终在路上，旅行的奇妙体验在于不可预知，在于每天早晨会在不同的地方醒来。 我热爱旅行，迷恋在路上的感觉，在之前的生命里，我一直以体验不同的生活为最大乐趣。 塞内加曾说：何必为部分的生活而哭泣，君不见，全部的人生都让人潸然泪下。今天，就要踏上旅途，也许失败，也许艰难，也许幸福。但，无论怎样，我都已准备好去享受这一切，双手合十，愿一路平安。 /06/06 成都 成都小记这次的成都之行是一次难忘的经历，第一次住青旅的新鲜感，陌生人之间互相娴熟的聊天毫无晦涩感，喜欢这种体验。青旅的老板阿铭是我眼中的完美男人，微胖，短须，菜做的色香味，娴熟的琴技加上浑厚的嗓音，悠远的歌声中，让人容易想起旧事，他给旅舍起了个名字，比邻，天涯若比邻的寓意，邻家大哥的感觉，幽默十足。杀人游戏，露天烧烤，这里真的让我恍惚，像家的感觉。以后有机会，希望这个小栈还在，希望再次回到成都能再来这里看看。￼三巷一号帮我调车的大哥，我没有机会问他的名字，也没选择他家的旅舍，我非常感谢他，萍水相逢，好人！￼终于组到了队伍，七个人，因为担心一下子记不住那么多名字，我们按照年龄做了排序，我排老六，老大是甘肃人，带了队旗，写着brave heart 勇敢的心。老二是惠州人，长于深圳，广东仔，86年生。老三老四，来自南京，同89年生人，初步接触，老三低调，沉默寡言，曾当过武警，老四爱吹牛，爱说南京那些事儿，话痨，南吹，不算贬义词吧！老五是地地道道的四川广安人，四川话说得非常好听，92年的。我暂时对老七一无所知，他是最后一个加入我们队伍的，排老七是因为比还我小五个月，哈哈哈，没错终于有比我小的了，94年人。￼希望我们这支队伍能一起冲到最后，不抛弃，不放弃。一路平安。出发之前的凌晨，举着手机敲下这些憋足的文字。 /06/10 成都 Day 01成都-雅安 /小雨转阴 /150km￼出发伴随着小雨，上午60公里的缓上坡，这段路基本没有什么风景，下午雨停了，90公里的起伏路，累到爆，虽然我心里非常清楚这仅仅是开始，但川藏线真名不虚传，感谢前人留下的路书和攻略，让我们自由前行。离开成都时，阿井说，川藏线上每一天都是挑战。我的同伴有一个四川广安的小伙，他说真佩服那些能骑到拉萨的人，忍受这种折磨，真不是简单人，我一辈子都不会忘记这一天！我说我们也想成为像他们一样不简单的人，所以我们选择了折磨和痛苦来到了他们曾经走过的路，然后他说对，要做不平凡的事！老二说了一句非常经典的适合描述川藏线的话，让我非常感慨: 当你在穿山越岭的另一边，我在孤独的路上没有尽头。第一天强行军150公里，老二在骑到名山就给我们打电话派车去接他了，他身体不好可以理解，我也在心底默默的跟自己说，一定不搭车，一定不推车，万事开头难，不抛弃不放弃，加油！ /06/10 雅安 Day 02雅安-新沟 /晴 / 90km经过昨晚的休息后，精神好了很多，PP也逐渐适应长时间的摩擦，早上7点起床收拾吃饭，队友要补充装备，上午在雅安成墨迹到9点才出发，太阳火辣辣的烤着就上路了，上午状态不错，中午11点多到达天全吃午饭，休整一小时后继续前行。 下午有60公里的路程，谁也没想到一路的爬坡，离新沟还有10公里时体力几乎已经透支，路上遇到从名山单骑到新沟，最后3公里与我同行，一句鼓励我，激励我，很感谢他。我只是累到说一句话的力气都没有，安静，只有车轮滚滚向前，蹬踏，全世界都仿佛安静了…… 今天是正式从101国道切到318国道，时常会有人们从身旁划过，给你竖起大拇指，说加油！我也会回应大拇指，我理解这应该算是318的文化吧，路上遇到就会互相鼓励，互相帮助！ 走318让我对坚持有了重新的感悟，也对生命多了更深一层的认识，虽然我踏上这条传说中的路刚刚两天，我也知道有更多的故事个人等着我去遇见。 ￼ /06/11 新沟 Day 03新沟-泸定 /晴 /57km￼因为今天的路程不是太多，相对第二天和第一天比较轻松一点，所以我们9点才离开新沟前往泸定，今天要爬的是川藏线第一座叫得上名字的山，先是20公里盘山公路环绕而上，让人欲仙欲死，不过我还是坚持了两不原则，不推车，不搭车，我比大部队晚出发十分钟，加上不擅长爬坡，所以也是最后到达二郎山隧道口，老二和老大在隧道口等着我，让我心里感动了一下下。￼穿过4公里的隧道，老大说饿了，我们就决定吃饭后再赶往泸定，饭后是30多公里的长坡，很爽，但是很危险，我一直让速度保持在30码以下，人年纪渐长就不敢那么冲动了，我是全队下坡最慢的，下午3点到达红色名城泸定，休整半天，洗脏衣服，出发三天来基本都是湿衣服，汗水不停的流淌，我估计按这样下去骑到拉萨，瘦个20斤不成问题。下午短暂的休息和洗漱之后，和队友一起去了小学课本中的泸定桥，据说下午6点之后才不收费，大渡河的滔滔江水，让人站在桥上会眩晕，仿佛看到历史伴随着这江水滚滚而去。￼ /06/12 泸定 Day 04泸定-康定 /多云 / 52km /海拔 2395m 从北京到成都的那天晚上喉咙疼，第二天就咳嗽加浑身无力，到新沟时已经有所好转，到昨晚还是咳嗽到2点，早上六点就起床收拾出发了，20公里的起伏路，接着就是没完没了的爬坡，下午4点爬到康定红灯笼客栈，连给这座美丽的城市拍照的力气都没有了。 老大今天也搭车了，半路被扎胎，正好给了他搭车的理由，哈哈，我是真的这么理解的，他确实爬不动了，大多数时候都是在推车，队伍中老三和老四打算骑到折多塘的，但老四下午六点才到康定，也是半路被扎胎，不过他还是坚持骑到了康定，给他点赞，他还是那么爱吹牛。 我有些担心，晚上咳嗽很严重，早上起床也感觉有些轻微的感冒，明天海拔就超过3000了，真的不想离开队伍自己休息好养好再走，大家一起从成都出发，如果一起骑到拉萨该是多好的事情！ 希望高反不会太严重，耽误大家的时间，希望感冒咳嗽快点好，高原感冒有生命危险啊，今天早些吃药上床休息了，希望一切赶紧好起来。骑318到现在一直没有精力拍照，总是在赶路赶路……心好累，辜负了那么多美景！ /06/13 康定红灯笼客栈 Day 05康定 - 折多塘村 /晴 /17km /海拔3300m 康定是座美丽的小城，跑马山我小的时候就知道，据说康定的人都会唱情歌，一问之下竟然是真的。 联系了大学同学，给她发了康定的位置和跑马山的照片，告诉她我经过她的家乡，特此问候，虽然她远在上海…故乡的位置和照片应该会让人感到亲切吧。 图为清晨的青山环绕的康定新城，蓝天白云和远处的雪山，好想就在这住下去…￼昨晚咳嗽有所好转，休息的也不错，还是早上6点起床，客栈老板是藏族，早餐第一次喝酥油茶，味道还可以，微咸。￼ 从康定爬到折多塘村，17公里，海拔从2300上升到3300，大家决定就地休整半天，一为了适应高反，大家调整下，再也为了在折多山泡一下传说中的温泉，也是我第一次泡温泉。￼认识这是什么吗，我真的第一次见，叫日晕。￼七兄弟在藏民家的合影，房间分为汉室和藏室两种，藏室里面还放着一口棺材，把老三吓的不轻，我也胆小只好和老七一起睡了汉室。 /06/14 折多塘村 Day 06折多塘 - 折多山 - 新都桥 /小雨，雪，阴 /58km /海拔3600 晚上下了一夜的雨，很早就休息了，早上六点醒来，窗外的雨声还是没有停，老七拉开窗帘看了下，大雨。在群里询问了老大的意见，说继续休整，就继续睡去…… 再醒来就是九点了，看到老四发朋友圈独自上路了，后大家商议决定，老大，二，三，五搭车翻越折多山到新都桥等我和老七，吃过早饭，我和老七就出发了。十点出发，22公里，海拔上升到4298，“折多”在藏语中是弯曲的意思，写成汉语又是“折多”二字。被称为康巴第一关，折多山以西就是青藏高原的东部，真正的藏区。 伴随着小雨，积雪的青山，我们以平均5码的龟速向着垭口爬行，出发一个小时后，老大他们的车就超越我们扬长而去…… 青山白云间穿行，路遇77岁的老大爷同样骑川藏线，一起合影，佩服的肝肠寸断，我想22岁的年纪再没有任何理由可以阻挡我去做完这件事了吧，就是这样！ 你看那飘扬的经幡，就说明垭口就要到了，折多山被我们征服了，虽然伴随着轻微的高反，心里这时是自豪的！只要在路上永远都是故事，到达垭口的时候在碑前拍照，竟然遇到了同县同镇的老乡，他们是组团出游包车从成都出发，我在让队友拍照时，身旁的阿姨用普通话问我，你们是骑车的吗，你们队伍中有没有山西人呀，我说有啊，我就是山西人，接着我问她你山西的吗？山西那里的，她又说我长治的，我就用长治话跟他说我也长治的，然后她说你真的是长治的天呐，对啊，我用壶关话说我是壶关滴，然后她就更震惊的表情看着我我用壶关话说她也是壶关的，哈哈哈哈，世界原来这么小，还遇到了同镇的，于是我又切换到了标准的树掌话，哈哈，都被详细追问到了你爹在那个单位工作看看是不是认识，阿姨和大叔们问我要往哪里去，我说到拉萨，他们说你一定要注意安全啊，嘿嘿，阿姨小跑去车上取下一大包家乡的琪炒，说这个治水土不服，饿了也管饱，你带上，有谁没车上有我去给你拿，实在是推不开，都说近乡情更怯，但我真觉得离乡千万里，乡音更让情更怯，合照，依依分别，大叔还在原处感叹着乡音呐！乡音呐！背井离乡多年，漂泊于外面的世界，会让人变得冷漠，是他们的热情感染了我，重拾原来家乡的人可以这么亲切…康巴第一关，以后的路就是藏区了，出行时的七个人仍然不离不弃，新都桥被称为摄影家家的天堂，到处都是美景，微单依然躺在驮包里，我却没有一点想法去拍点什么……入住了新都桥桐花里客栈，老板说话让人听起来非常愉快，山东汉子，青岛人，我还给他简单的来了几句青岛话，告诉他我曾经在潍坊上大学，有很多青岛的同学朋友，老板旅行过全国所有的地方，最后留在了这里，开一间小客栈，我们没有过多的交流，但从老大口里听的出这是个有故事的男人。晚饭的时候看到老大发的朋友圈，是这样的:78年的七尺汉子，当着我的面，真的流泪了，我看到他红了眼眶，就把头转了过去，我不喜欢这样，虽然都是性情中人，老大说当他坐着车从我和老七身边划过时，就哭了，真的后悔了。老五接着说，他那时把眼睛望向了窗外，让泪水在里面转几圈，记住放弃的味道……然后骑下去。我理解他们，所有人都放弃的时候我会感觉到孤独，但选择了走318我就一定不能让自己后悔，不尝试，不尽力就放弃的后悔。 Day 07新都桥 - 高尔寺山 - 雅江 - 相克宗村 /晴 /92km /海拔3600 今天从七兄弟变成了六个，老三走了，回了南京，我们也不好追问具体详细，昨晚小喝了一杯送别酒，希望老三一路顺风，晚上到达相克宗时听说他已回到了成都。8点钟出发爬坡20多公里到高尔寺隧道，老二在半路高反比较严重，我们在隧道口等了一个多小时，隧道将近6公里长，因为正在修建，其中四公里没有灯，所以必须结伴前行。爬山途中遇到昨天在折多山的77岁老大爷的同伴，也是70岁高龄，身体非常硬朗，重庆人，两人结伴骑过五次长途，曾环过山东半岛，其他的我给忘记了，我问他川藏线是不是他骑过最难最有挑战的，他毫不犹豫的告诉我，是的，在高原攀山越岭，太有挑战了。半年之前骑行的骑友就没有这种享受了，他们要翻越4659m的高尔寺山，如果折多山被称为康巴第一关，那么高尔寺就是第二关，以前让骑行队伍分开的最多的一座山，挑战和痛苦可想而知……从隧道通过后就是40公里的大长坡到雅江，一路的美景，让人心碎的美景，北京从没有过的蓝天白云，就像许少歌里唱的一样：只有青山藏在白云间，蝴蝶自由穿行在清涧。当然没看到蝴蝶，领悟精神，领悟精神！ 一路的长下坡伴随着大回环，我又是队伍中下坡速度控制的最慢的，下午两点钟我们到达了雅江，休息吃午饭，补充水。今天的目的地是相克宗村，还有20多公里的陡坡要爬，海拔会重新上升1000多米，所以这一天真正的挑战才刚刚开始，短暂的休息过后，3点钟继续顶着烈日，迎着横风出发了……景色依然美不胜收啊……路上第一次出现了拉萨的标志，1608公里，我们还有很高很高的山要翻越，很长很长的坡要爬……也第一次遇到了川藏公路的长长军车队伍，老七算了一下大概150多辆，我就在想为什么现在交通手段这么成熟，不派几量飞机直接运送，却要让这些汽车兵，成群结对辛辛苦苦的走这川藏线，一个小插曲吧……G318的路牌，留一张。从此之后，里程碑就步入3开头了，再留一张。碑上写满了骑友想说的话，碑上写不下了就在旁边的栅栏上写……这个时候，相克宗也终于到了，今天的行程体力几乎拉爆了，明天迎接我们的将是川藏线以来最难的，最有挑战的一天……爬4600米的剪子弯山，再翻越卡子拉山，会在4200米的高海拔迎接几十公里的起伏路，并伴随野狗的触摸，自己到处的岗风，侧风，横风，想起来腿就软了，早点休息，早点出发吧，晚安。 Day 08相克宗村 - 剪子弯山 - 卡子拉山 - 红龙乡/雨，晴/79km/海拔4170m 被客栈老板称为最难最有挑战的一天，在清晨六点的闹钟中开始了，老大和老二估计是被老板吓到了，果断选择了搭车，14公里的爬坡到剪子弯隧道，途径天路十八弯。14公里的爬坡对于刚刚出发的体力来说，易如反掌，2个小时就爬到剪子弯隧道口隧道长2.2公里，黑漆漆没有灯，必须结队通过，过了隧道就到剪子弯山的垭口，之后就是在4200以上的高原骑行几十公里的起伏路，云彩好像就在头顶贴着头皮一起飞。十公里后，骤云突变，漂泊大雨呼啸而来，整整三十公里的奔袭，加上一句逆风和起伏路，手脚几乎僵硬，一路都是无人区，没有补给的地方，待冲到卡子拉山脚下的日里村时，遇到了藏族的一位大叔，招呼我去他家里喝茶，我就径直跟他爬上藏式的小楼，正好是午饭的时间，喝酥油茶，吃藏餐，烤火炉，不得不感叹这淳朴的民风。休息并等队友会合，一个小时后雨几乎停了，还是不见三位队友的影子，我便开始独自翻越卡子拉山。高原的骑行超级爽，第一次连续翻两座山，318醉人的景色，再也没有高反的症状，一路杀到红龙乡，超越了一路的骑友。码表破600公里了，1/4的旅程已过，越过这最艰难的一天，继续一路向西。那歌词怎么说的来，对，就这个feel倍儿爽…… Day 09红龙乡 - 理塘/晴/37km/海拔3960因为曾喜欢仓央嘉措的诗句，所以到了理塘就一定会想起他，理塘，一个高原小城，海拔四千多米，这座“选在高空的城市”自古以来就是茶马互市上的重镇，而理塘在藏语是“平坦如铜镜的草坝”的意思，县内还有广袤无垠的毛垭大草原。因此理塘也有“世界高城”的称号。所以说起理塘，就不得让人想起仓央嘉措的那首情诗：洁白的仙鹤啊，请把双翅借给我，不飞遥远的地方，只到理塘就回。这首诗，把仓央嘉措和理塘紧紧联系在了一起。也因此，有很多人会认为，理塘，是仓央嘉措的故乡。其实不然，仓央嘉措一生从未到过理塘，而这个地方确实他心灵深处最伤感的地名。因为理塘，是仓央嘉措爱人卓玛的故乡。放眼理塘，这座小城并不大，一条主街道走的再慢也不过个把时辰的光景。因为修路，街道略脏，但是你可以看到，天空很蓝，大朵大朵的白云凝固在这深蓝的天空中。树不多，但草原、山丘、河流，披着阳光，显得很干净很原生态。和梦中的境界一样。而这座城市中，轻而易举就能发现仓央嘉措的影子。路边有几家紧挨着的旅馆，名字大多借用了仓央嘉措的绝笔诗，大凡是仙鹤宾馆、白鹤旅馆等等。从红龙乡到理塘的旅程很短很短，所以就慢下来，静静地看着这里的天，缓缓的感受这里的风景。有很多想写理塘的话，可是当我真的到了这里，却不知从何写起……再找不到句子，就让情感流淌，理塘的天色有些黯淡了，独自坐在湖边，湖水泛着金光，从草原腹地浅浅的顺流而下…… Day 10理塘 - 禾尼乡/阵雨/58km/海拔4130 上午没有出发，看完了这个夏天最后一场比赛。金州勇士输掉了完美赛季里的最重要的一场比赛，输掉了奥布莱恩杯，输掉了总冠军！祝贺克利夫兰， 最后的赢家，最好的球队不一定能走到最后，竞技体育，最合适的结局！球赛结束后，阵雨的陪伴下，出发前往禾尼乡。队伍只剩下我和老五老七，其他已经赶到巴塘休整等我们汇合。三个人，三辆单车，继续在画中徜徉，笔直的318直插天际，美到让人喊出来，在喊声里告诉所有人这里的美！小溪，蓝天，白云，草原。开车太快，走路太慢，骑单车，刚刚好…… Day 11禾尼乡 - 巴塘/阵雨/120km/海拔2590m 当你骑着车子，伸出手臂，把手掌轻摊开来，和对面走来的藏民问好，击掌。相信我你会爱上这种感觉！从理塘到巴塘都是宽阔的草原，翱翔的雄鹰，低飞的燕雀，还有那远处的化作斑斑点点的牦牛。出发第11天，终于扎胎了，在刚刚出发的一小时后，就这么扎了！今天的路程是爬30公里的坡翻越海拔4685米的海子山，经90公里的长坡到巴塘。海拔下降将近两千米，并没有体验到传说中的醉氧。第一次经历生死川藏，下午2点还倚在所波大叔家门框道平安的骑友，4点钟就倒在了往海子山的路上，生命真的这么脆弱，一瞬间，天人永相隔……兄弟愿你一路走好，若有来生再圆川藏梦！高原的天气多变，往往一天要淋好几场雨，往往都是出好几身臭汗……出发11天了，终于要出四川了，明天就过金沙江大桥入西藏界了 Day 12巴塘 - 金沙江大桥 - 温泉山庄/晴/47km/海拔2840 出四川了，终于出四川了！穿过金沙江大桥就是西藏界，桥中间横分川藏两界。上午十点出发去邮局买明信片，盖邮戳。说到明信片和邮戳，在理塘之前都没有想到，有点遗憾，以后到拉萨的途中，每到一座城都买吧！下午两点到达温泉山庄，老大已经在等候，老四独自一人翻越宗巴拉山到芒康去了，队伍如今只剩下五人，新的温泉山庄已经基本修建完毕，但还没有开始营业，以后的骑友可以体验享受了！ Day 13温泉山庄 - 宗巴拉山 - 芒康/晴/60km/海拔3920m 痛苦的一天，转弯之后一个接一个的爬坡，还是没有尽头的路，50公里的爬坡，其中将近10公里的烂路，海拔从2800上升到4150，今天，真够累！下午担心少数民族地区邮局五点下班，一路狂奔到邮局买明信片盖邮戳，芒康这个鬼地方全城都在修路。 Day 14芒康 - 拉乌山 - 如美/晴/50km/海拔2670 出城过检查站的时候，才想起昨天在邮局盖邮戳取钱时把银行卡落在了ATM机被吞了，这次旅行只带了一张卡，叫了老七一起匆匆赶到邮局时，邮局工作人员都回家午休了，下午两点半才上班，需要等一个半小时，那就等吧，在门口待了十多分钟后走过来两个姑娘是邮局的工作人员，说三点半才上班，我就着急了，老五和老大已经先爬坡往如美去了，如果等到三点半天黑前还能不能赶到如美，给两位美女说明事情和为难后，美女给相关工作人员确认了银行卡确实在机器里，然后加了微信，说拿到卡片后帮我寄回北京，感动的我快哭了，这张卡对我有特殊的意义，使用多年，实在不舍得注销。事情处理完毕，立即和老七追赶他们的脚步，芒康进城出城都要翻山，进城是宗巴拉山，出城是拉乌山，望着眼前没完的盘山路，就听见老七在我的后面叹息。公路的旁边就是悬崖，交警单位把报废的汽车时摆在路旁，时刻提醒着过往的路人，安全第一！老七说你拍这有啥意思，我说要拍，提醒自己，小心加小心，生命只有一次。在拉乌山垭口遇到了三个骑滇藏线过来的骑友，这座山是他们目前爬过最高的海拔，聊到他们看到了梅里十三峰，真幸运，祝他们幸运。从拉乌山垭口到如美是35公里的下坡，海拔从4370下降到2670，一路风景如画，路过3456的里程碑，留个纪念，上面同样涂满了来自五湖四海骑友想说的话。如美小镇跨越澜沧江，到达时还不到五点，老大和老五又搭车了，从撞烂的汽车的地方就搭了，他们坐车到达一刻钟我和老七就到了，我本打算时间尚早再爬十公里山路到教授山庄为明日翻越觉巴山做准备，但是老大说腿软，那就住下吧！顺便洗臭袜子，全汗味的衣服…… Day 15如美 - 觉巴山 - 容许兵站/晴/54km/海拔4020m你是否站在过1300米的高处眺望过大地？是什么感觉？觉巴山被当地人称为绝望山，其实海拔并不是很高3911，但是足够征服一个人对山的所有理解。出如美到觉巴山垭口26公里的陡坡，海拔从2670上升到3911，九点出发，两点到垭口，5升水，半块压缩饼干，累到说不出话来，只能张开嗓子，干呕两声……当站在山顶回望来时的路，我是真的佩服自己，佩服这条线。老大在出发后十公里处终于坚持不住选择了搭车。早上出门时，后车轮刹车有点松，调了一下，待到山顶下坡时，发生了问题，后刹刹不住，幸好下坡直有十多公里，前刹还好，下到登巴村时老五和老大又搭车走了，还好有老七陪伴，我已经几乎竭力，还有13公里的爬坡到容许兵站，为明天东达山做准备。晚上休息的客栈老板车技超高，高中毕业后就一直玩户外，拿的奖状贴满了客栈餐厅的墙壁，菜做的一级水准，帮我调了刹车和变速，学了好几招调车的方法，等回北京我打算找家车店，周末休息时，去免费帮人调车多学点技能啊哈哈。 Day 16容许兵站 - 东达山 - 左贡/晴/62km/海拔3810m东达山，川藏线两座5000米大山之一，难度在于高海拔，坡度平缓，26公里海拔上升1000米，翻过东达山就表示行程已经过半，接下来到达拉萨只剩下四座大山。过东达到左贡，如果没有高反就是很轻松的行程，老七在半路高反严重，休息吃药后才继续出发，我最早到达垭口，在垭口等队友将近两个小时。行程太慢，15号出发的队伍都已经追上我们，买了10号拉萨到西宁的机票，川藏之行结束顺路去七月的青海湖，约了一圈好友，大家都没时间，那就我自己吧……我只是从未如此想去一个地方。 Day 17左贡 - 邦达/晴，雨/107km 海拔4130m 西藏的天气是什么样的呢，一言不合就下雨，刚穿上雨衣雨就停，脱完了雨再下，折磨，折磨！今天没有山，100多公里的起伏路，川藏线骑习惯了，平路就当是下坡，一般的上坡就当是平路。累，就写这点吧… Day 18邦达 - 业拉山 - 怒江72拐 - 八宿/晴/95km/海拔3250再出发，三人行，老大又搭车！垭口回望来时的路，邦达小镇依稀可见。业拉山，海拔4658，已经变的没什么挑战。怒江天路72拐，巍峨壮观，身临其境，心惊胆寒！在这里摔车的朋友，一个接一个。老七也摔了，不过问题不大，我肯定不会，我下坡最慢了。再看一眼怒江，汹涌着，嘶吼着。天生脾气就不好！下了天路72拐，就是30公里的上坡到休息地，前14公里荒无人烟，早上没做准备带干粮，坚持到半路遇见一个能在水浒中才有的凉亭，一碗泡面下肚，立马就过岗，哈哈。14公里后，三人坐下每人来了一瓶啤酒，喝完我就腿软了，然后席地而睡休息了一个小时。半路遇到一个开车的大哥非要送我一瓶红牛，我拍拍胸脯告诉他我可以，出发至今带了一罐红牛一直没喝，放在驮包里，我只想靠坚持和毅力去翻越每一座山，每一段旅程。 Day 19八宿 - 安久拉山 - 然乌/晴/90km/海拔3850昨晚晚饭时听到几个来自山西晋城的大哥说今天的路程，68公里上坡到安久拉山垭口，22公里起伏路到然乌，他们说过了今天就好了，五星难度，以后的路只是时间问题。真正踏上今天的旅程，我们怀着忐忑的心，但是却是休闲骑，直到被一个个晚出发的队伍超越，下午遇到三个纯徒得驴友，互相鼓励，他们已记不起早上是从哪里出发。下午六点，我和老七终于爬到安久拉山垭口这时老大电话响起，已经定好然乌湖旁边的湖景房。傍晚的然乌湖，湖风煦煦，雪山倒映在湖中，我独自坐在湖边感受着这份难得的安静。 Day 20然乌 - 波密/雨/132km/海拔2700伴随着小雨，告别美丽的然乌湖，短暂的休整让我们再次出发！今天的行程是132公里的缓下坡和起伏路，海拔将从3850下降到2700，也将步入物产丰富林芝地区。进入林芝，以后的景色也都会变得郁郁葱葱～不起眼的4000里程碑，又被路过的骑友涂满了各种想说的话，这回没有了栅栏，拉萨越来越近，心情变得急促，我说拉萨不是目的，享受的是在路上……路遇生灵，我在4000公路碑拍照时就一直跟着我，前爪受伤严重，特别可怜！喂了一袋压缩饼干，它让我想起陪伴童年时光的那条小黑。希望它一切都好～今天的行程是132公里的冒雨穿越，什么防雨措施都成了摆设，十个小时的雨，浑身通透……波密是座美丽的小城，被称为藏王故里，冰川之乡，干净的街道，整齐的建筑，该是沿途看到最繁华最有特色的地方了，一天的雨中穿梭后，大家的衣服浸湿，队伍计划在此休整一天后再向通麦出发。 七月，你好岁月如歌，弹唱着盛夏的炎热，六月走过，七月流火，送走了半年苍凉。七月，你好。你是一个半年的开始，你是一个半年的结束。我在时光里穿梭，忘却了日历的轮廓，那密密麻麻的数字，原来是错落排列的日出和日落。2015年6月，2000公里的呼伦贝尔穿越。 年6月，2000公里的川藏南线挑战。……用车轮丈量大地，体会生命的意义，享受在路上的感觉。追寻倒映在水中的蓝天白云，攀在山顶望见绵延不绝的高山。平日的浮躁与忙碌，总是冲淡我们对美好事物的追求。我们都曾有梦想居住的地方。在依旧有炊烟的村庄，山水亮丽得如同梦里的笑容，每条小路清秀得像一句诗歌。白天浩瀚的蔚蓝、海边架起的小木屋、在阳光跳跃的草原，躺下，自己就是一片湖。千篇一律的生活中，需要一趟说走就走的旅行。“有些事现在不做，也许一辈子都不会做了”。一句简简单单的话，不知击中过多少颗青春不羁的心。只是任何时候，除了向往自由，战胜现实，我们必须知道的是：直面自己、找到通往内心的路。这一季，走过风花雪月，路过倾国倾城。下一季，故地重游，看尽云卷云舒，花开花落。 Day 21波密 - 通麦 - 拉月村/阴/116km/海拔2320m 波密，就在波密，剩下的哥四个终于统一了发型，本来是约定拉萨一起剃光，提前执行了，我跟老大说，我18岁的时候打死都不会搞这个发型。而现在，从良了，只觉得舒服就好，反正怎么着也都没有女朋友……计划之外，在波密休整了两天，原计划休息一天，第二天出发通麦，晚上就下起了雨，早上醒来时仍然没有停的意思，询问大家都说下雨不出发就又果断睡去了。查看了未来几天的天气后，于是昨天晚上下定决心，今天下雹子也要走，因为已经提前买了十号拉萨飞西宁的机票，都是眼泪，我是下雨也打算出发的，但奈何队友都不走，一个人雨天路上太危险。今天计划的目的地是通麦，我曾在新浪的&lt;胖哥试车&gt;节目的西部穿越之旅里见识过传说中的通麦天险，从波密出发到通麦90公里的起伏路，海拔下降700米，40公里在修路，远超山西未实现村村通工程前的石头泥巴路，路上的骑友举着相机说，这才是318的味道，我路过，回一句，那就好好享受……想说的是队伍只剩下了我和老七，老大和老五在早上醒来后再次选择了搭车到八一，从波密到八一300多公里的路，也就意味着我和老七三天才能到。或许那个时候他们早就又坐车到拉萨了吧……刚刚建成的通麦大桥，看胖哥节目的时候还没有他，那时应该正在修建，胖哥在节目里说，等大桥通车，以后过通麦的朋友就幸福了，果然，我幸福了，但也意味着再见不到通麦天险和单边放行的通麦铁板桥。到通麦是刚刚下午四点，天色尚早，体力尚充沛，补充水后，我和老七商量下决定往前赶路到排龙乡后面的拉月村，这样如果努力一点的话，可以把三天的行程合并成两天，明天直接杀到八一。走在我前面的老七的背影，很感谢他，在所有人都放弃的时候，他没有放弃，陪着我从成都到现在，从未搭过车，做到了用车轮丈量大地的承诺，也因为有他，318对我来说，不显得那么孤单。 Day 22拉月村 - 鲁朗 - 八一/雨/114km/海拔300070公里的爬坡，海拔上升两千多米，第一次挑战在下午体力即将耗尽的时候翻山。太酸爽！这便是三天的路两天赶完的代价。在这条线的倒数第二座山，色季拉山的垭口，我给老大打电话，他正在往拉萨的车上，还剩30公里，真的只剩下了我和老七相依为命！出发时的七个人只剩下两个了，这个时候不用说什么坚持之类的云云，我和老七都知道，我们一定会骑完，百分之一的人能真正骑完川藏南线，我们即将做到。淋了一天的雨，晚上九点半才到林芝市（原八一镇），318目前为止最大的城市，我说这是大城市！浑身只剩两块银元，和老七满大街的找取款机，取钱吃过饭到住的地方已近11点。我什么都不想说，沿途的风景再美，也抵不住我想尽快到拉萨的心。 Day 23八一 - 工布江达/雨/132km/海拔3420不知道我和老七是对自己的体力逐渐有了自信还是，反正总是最晚出发，每天都是我催他起床。一觉睡到自然醒，吃饭，洗车，墨迹墨迹就中午。一路沿着尼洋河走，景色优美让人心情分外愉悦，下午三点在百巴镇吃午饭。路过k4321留念下午八点到达工布江达，路况较好，所以130公里难度对现在的身体已经够不成太大的挑战，只是中途被浇了好几场雨，鞋子湿了个通透，很酸爽。林芝地区的天气太善变…… Day 24工布江达 - 松多/晴/95km/海拔4200m出发19公里处是中流砥柱景点，但是因为有人不幸掉水溺死，被蓝色的铁皮围了起来，我们只好爬到旁边的小山去拍一张没有字的一面。路书上说，这将是轻松的一天，本计划6 - 8个小时的行程没找到光下午就走了六个小时，全程在修路，漫天的沙子，什么都看不见，等到松多几乎不用吃饭了，沙子加土混合的菜几乎吃饱，嗓子想干呕，又吐不出来。k4444界碑已经没有了，在漫天的黄沙中拍了4445界碑，这一路上到处是豆豆的名字，也不知道豆豆是谁下午40公里这样的烂路，整整骑了11个小时，接下来到拉萨只剩下180公里，有很多队伍计划一天骑到，我想我还是两天吧，这烂路将持续到拉萨，一天180公里不敢想象。分两天走吧，不作就不会死！慢慢会开始对沿途的风景疲劳，会开始想东想西，从上学时的同学老师到工作后的同事朋友，一个一个想她们的模样，和一些过往，318让我又一次恍惚，分不清昨天今天明天，生活变的只有日出和日落，赶不完的路…… Day 25松多 - 拉萨/晴/180km/海拔3650m大多数人在这一天是要赶到拉萨的，我和老七商量之下，决定把路分成两天走，所以该怎么睡就怎么睡，下楼吃饭时，所有的骑友都走了，只剩下我俩的车子停在哪里……从松多出发，28公里的爬坡翻越米拉山，5013米，318的最后一座山，也是最高的山，海拔上升700，难度不大。正在修建的米拉山隧道，以后来318的骑友可以少爬很多坡了，不知是悲伤还是欢喜12点爬到垭口，四个多小时在山顶和老七吃了两块小面包补充体力，一路的缓下坡冲到墨竹工卡刚刚下午五点墨竹工卡就是我们今天的计划休息地。但天色尚早，很多在我们后面的骑友都往拉萨走了，我也难掩兴奋之情，想一鼓作气冲到拉萨！那索性就继续出发……K4567的里程碑，合影留念，过了这就是平坦的柏油路直面拉萨。我在最后冲刺的九十公里，身体状态达到了最佳，四个小时就冲到了布达拉，一举超过很多前面的骑友，在冲刺的时候整个脑海在回响这一路爬的每一座山，口中念着每一天的行程。进城过拉萨桥的时候，不由地流泪了，是被自己感动，22天风雨兼程318，不推车，不搭车，不抛弃，不放弃。我做到了！","categories":[{"name":"Journey","slug":"Journey","permalink":"https://blog.alphabethub.com/categories/Journey/"}],"tags":[{"name":"Journey","slug":"Journey","permalink":"https://blog.alphabethub.com/tags/Journey/"}]},{"title":"群哥结婚了","slug":"daily-2017-0221","date":"2017-02-21T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2017/02/21/daily-2017-0221/","link":"","permalink":"https://blog.alphabethub.com/2017/02/21/daily-2017-0221/","excerpt":"","text":"群哥结婚了 是的，卢群，我们大伙儿管他叫群哥，我的大学舍友，是山东不多的哥们之一。是的，群哥在今天领证儿了！我也只是通过空间看到他晒出的照片。 认识群哥快五年了，此时，我在北京，他在济南，千里之遥，正值春雪覆满大地之时，多想与他举杯恭喜，分享他的幸福之情… 群哥，真不好意思，好久不见了，现在的你我在忙着各自的事情，已经有很久没有坐在一起了，还记得大学时我们一起讨论技术，一起努力，一起挥洒汗水的球场，还有一起在晚自习后去吃的南湖的兰州拉面吗？当我在空间看到你结婚的消息时，我高兴啊！高兴你终于把爱情修成正果。还是要祝福你啊，也希望你在新的起点肩负起新的责任，充满信心和热情去迎接人生的下一个阶段… 群哥，想你了，相信你也想我了，话如泉涌啊，不说了，办事儿的时候叫我喝喜酒啊… 2017/02/21 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"Objc - 对象之类对象和元类对象","slug":"oc-class-relationships","date":"2016-06-09T00:12:45.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/06/09/oc-class-relationships/","link":"","permalink":"https://blog.alphabethub.com/2016/06/09/oc-class-relationships/","excerpt":"","text":"Objc 中的类（Class）众所周知，在 Objc 中所有的对象都由类实例化而来，殊不知类本身也是一种对象。在 Objc 中几乎所有的类都是 NSObject 的子类，NSObject类定义如下(忽略方法声明)： @interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;@end 这个isa是什么呢？在 objc.h 中我们发现它仅仅是一个 typedef 的结构体(struct)定义，如下: typedef struct objc_class *Class; 同样的objc_class又是什么呢？在 Objc2.0 中 objc_class定义如下： struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 这里又出现了一个isa指针，这个 isa和上一个有什么区别和联系？ 答：其实在 Objc 中任何类的定义都是一个对象。在编译的时候，编译器会给每一个类生成且只生成一个「描述其定义的对象」，也就是苹果公司所说的类对象（class object）；因为 Objc 和是一门动态语言，程序中所有的实例对象（instance object）是在运行时库生成的，而这个类对象（class object）就是运行时库用来创建实例对象（instance object）的依据。 再回到之前的问题，为什么实例对象（instance object）的isa指针指向的类对象（class object）里面还有一个isa指针？而这个类对象（class object）的 isa 指向的仍然是一个objc_class，它就是元类对象（metaclass object）；那么实例对象（instance object）、类对象（class object）、元类对象（metaclass object）之间的关系是怎样的呢？如下图： 类对象（class object）类对象的实质类对象是由编译器创建的；即在编译时所谓的类，就是指类对象。 官方文档中这样描述：The class object is the compiled version of the class. 任何直接或间接继承了 NSObject 的类，它的实例对象(instance object)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instance object)所属的类定义的一切：包括变量、方法、遵守的协议等。因此类对象(class object)能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例对象(instance object)，但是类对象不能访问任何实力对象的内容。当调用一个类方法(class method)时，例如：[NSObject alloc]，事实上是发送了一个消息给它的类对象。 类对象和实例对象的区别尽管类对象保留了一个类实例的原型，但它并不是实例本身；它没有自己的实例变量，也不能执行那些类的实例方法 类对象与类名在代码中，类对象由类名表示。 举个例子：定义类 Person 继承 NSObject int versionNumber = [Person version]; 在上面的例子中，Person 类从 NSObject 继承 version方法来返回类的版本号；只有在消息表达式中作为接受者时，类名才代表类对象。 另外，类对象和其他对象一样也是id类型，例如： id clazz = [anyObject class];id pClazz = [Person class]; 总之，类对象是一个功能完整的对象，所以也能被动态识别(dynamically typed)接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量)，只是在运行时产生实例的代理。 元类对象（metaclass object）元类对象的实质实际上，类对象是元类对象的一个实例，元类对象描述了一个类对象，就像类对象描述了普通的实例对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应；当一个类发送消息时候，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替实例对象描述了实例化方法。 很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例，而根元类是其自身的实例，即根元类的 isa 指针指向自身。 类的super_class指向其父类，而元类的 super_class 则指向父类的元类；元类的 super_class 链与类的super_class链平行，所以类方法的继承与实例方法的继承也是平行的。而根元类(root class’s metaclass)的 super_class指向根类(root class)，这样整个指针链就链起来了。 综上所述: 类对象(class object)保存的是关于实例对象的信息(ivar，实例方法等)，而元类对象(metaclass object)存储的是关于类的信息（类的版本，名字，类方法等）要注意的是，类对象和元类对象的定义都是objc_class结构。其不同仅仅是在用途上，比如其中的方法列表在类对象(class object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中保存的则是类方法(class method) 类对象和元类对象的相关方法object_getClassobject_getClass跟随实例的isa指针，返回此实例所属的类，对于实例对象(instance object)返回的是类(class)，而对于类(class)则返回的是元类(metacalss) classclass方法对于实例对象(instance object)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身，即[@“instance” class]则返回的是__NSCFConstantString；而[NSString class]则返回的是 NSString class_isMetaClassclass_isMetaClass判断某类是否是元类 objc_allocateClassPair使用objc_allocateClassPair可在运行时创建新的类对与元类对，使用class_addMethod和class_addIvar可向类中增加方法和实例变量，最后使用objc_registerClassPair注册后，就可以使用此类了。 参考资料 https://blog.csdn.net/wzzvictory/article/details/8592492","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"}]},{"title":"柴静十年成长的个人告白 - 读《看见》","slug":"read-kj","date":"2016-06-01T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/06/01/read-kj/","link":"","permalink":"https://blog.alphabethub.com/2016/06/01/read-kj/","excerpt":"","text":"看见 水无所起止，只知流淌，但总得流淌。山高月小，它要滴落，乱石穿空，它要拍岸，遇上高山峡谷，自成江河湖海。——柴静 这本书是柴静十年成长的个人告白，中国社会变迁的备忘。讲述十年央视生涯。从对新闻一无所知的新人，尝遍失败、迷茫、摔打的滋味。从未停止反思和追问。 柴静这个人让很多人佩服，我小时候就看她的节目，非典的时候对她印象很深刻，在书里读到她写非典的采访，脑袋里就不自觉的飘过2003年夏天守在姑姥家电视机前看新闻调查的画面。03年那个时候我们家还没有电视机，03那年夏天老爸和老妈都回老家忙农活了，我和我哥住在姑姥家。我不爱喝中药，讨厌那个味道，旧街药材公司的板蓝根冲剂开始限购，学校会每天早上量体温，填表。03年夏天我不小心打碎了家里唯一的体温计，被老妈回来摁在床上暴揍一顿。03年到16年，时光荏苒，13个年头已悄然而去… 柴静在书里写到：对与错，好与坏，真与伪，善与恶…如何断定？太多的欲望夹杂着太多的无奈，又或是太多的无知与蒙昧？让人分不清道不明这社会的混沌，看见或感受，理解或矛盾，只是一种经历，经历过后了无痕迹，又回头再来！只愿做好自身，冷静不失冷暖，客观不失情感。一个好的记者，应该让大家知道真相，可以不评价不总结只讲述，知道了真相的人们自有评判，虽然有时真相会刺痛我们，但仍然感谢柴静，让我们如实看见。 2016/06/01 北京","categories":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/categories/Readed/"}],"tags":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"Xcode - 打包证书创建流程","slug":"xcode-pack-cer-create-process","date":"2016-05-29T03:48:37.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/29/xcode-pack-cer-create-process/","link":"","permalink":"https://blog.alphabethub.com/2016/05/29/xcode-pack-cer-create-process/","excerpt":"","text":"创建CSR证书点击spotlight输入keychain打开钥匙串 生成CSR文件 注意： 创建Cer证书登录 apple developer使用CSR文件创建Development和Distribution的CER证书并下载 双击下载好的cer证书，然后导出对应的p12文件（dev/dis） 创建Provisioning Profile这里要创建是三种profile（dev/dis/adhoc）","categories":[{"name":"Xcode","slug":"Xcode","permalink":"https://blog.alphabethub.com/categories/Xcode/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://blog.alphabethub.com/tags/Xcode/"}]},{"title":"iOS - TableView 的重用机制及优化","slug":"ios-uitableview-optimize","date":"2016-05-28T13:41:01.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/28/ios-uitableview-optimize/","link":"","permalink":"https://blog.alphabethub.com/2016/05/28/ios-uitableview-optimize/","excerpt":"","text":"iOS-TableView的重用机制什么是Cell的重用？重用机制，简单的说意思是一行一行cell的复用 为什么要重用？为了做到显示和数据分离，UITableViewCell的实现而且不是为每一个数据项创建一个tableCell，是仅仅创建屏幕可显示最大个数的cell，然后反复使用这些cell，对cell做单独的显示配置，来达到既不影响显示效果，又能充分节省内存的目的；当屏幕滚动出现新Cell的时候，就会调用方法获取新出现的Cell,而有的Cell则会滚动到屏幕的外面 如何实现Cell的重用？通过UITableView的dequeueReusableCellWithIdentifier函数实现，从字面理解就是出列可重用的Cell，简单来说就是有一个Cell池，里面存放了之前从屏幕滚动消失的Cell 重用机制的实现原理进入UITableView的头文件可以发现： @property (nonatomic, readonly) NSArray&lt;UITableViewCell *&gt; *visibleCells;@property (nonatomic, readonly) NSDictionary&lt;NSString *, UITableViewCell *&gt; * reusableTableCells; visibleCells内显示当前显示的cellsreusableTableCells保存可重用的cells，可复用的cell使用字典是因为可复用的可能cell不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式。 执行思路：tableView显示之初，reusableTableCells为空，假如一个界面显示5个Cell，界面慢慢向上拖动，当cell1完全从屏幕上小时的时，cell6（cell6是新创建的cell,因为reusableTableCells为空）完全展示在界面上时；cell1移入到reusableTableCells中，继续拖动,展示cell7会从reusableTableCells中取出缓存的cell1,以此类推… 注意并非仅仅有拖动超出屏幕的时候才会更新reusableTableCells,reloadData和reloadRowsAtIndex时也会更新并操作reusableTableCells UITableViewCell的性能优化 扩展：UITableView delegate/dataSource方法执行顺序1.//有多少组-(NSInteger)numberOfSectionsInTableView:(UITableView * )tableView2.//cell 页眉高度-(CGFloat)tableView:(UITableView * )tableView heightForHeaderInSection:(NSInteger)section3.//cell页脚高度-(CGFloat)tableView:(UITableView * )tableView heightForFooterInSection:(NSInteger)section4.//每组有多少行-(NSInteger)tableView:(UITableView * )tableView numberOfRowsInSection:(NSInteger)section5.//cell高度-(CGFloat)tableView:(UITableView * )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath6.//布局UITableviewcell-(UITableViewCell )tableView:(UITableView * )tableView cellForRowAtIndexPath:(NSIndexPath * )indexPath","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"UITableView","slug":"UITableView","permalink":"https://blog.alphabethub.com/tags/UITableView/"}]},{"title":"Xcode - 代码片段 Code Snippets","slug":"xcode-code-snippets","date":"2016-05-28T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/28/xcode-code-snippets/","link":"","permalink":"https://blog.alphabethub.com/2016/05/28/xcode-code-snippets/","excerpt":"","text":"在iOS开发过程中，经常会用到一些相似的代码。我们可以将这些代码保存起来，在使用的时候直接从Code Snippets拖拽代码块到指定的位置，也可以设置一些快捷方式来调用Xcode代码片段。 新增 例如编写以下代码片段 @property (nonatomic, strong) &lt;#Type#&gt; *&lt;#value#&gt;; &lt;##&gt; 作用是占位，## 之间可以输入提示文字。 使用快捷键：command+option+0 将上述代码片段拖拽到下图所示区域 小技巧：用鼠标选中代码块后把光标放在所选代码块上点击长按2-3秒(光标会由插入标变为小箭头状态)就可以拖拽了 弹出下图 Title：标题Summary：描述Platform：可以使用的平台Language：可以在哪些语言中使用Completion Shortcut：快捷方式（例如：@xs）。Completion Scopes：作用范围 修改对代码片段进行修改，选中代码片段，点击edit即可。 删除对代码片段进行删除，选中代码片段，按delete键即可。 Git管理为了方便在更换电脑后可以更快速的使用自己的代码块，可以托管在Github上进行管理，这样在家里和公司两台Mac任何一端有了更新，另一端随时都可以pull一下使用了。 Xcode中代码片段默认的目录：~/Library/Developer/Xcode/UserData/CodeSnippets 同步代码片段上述目录设置成一个 Git 的版本库，将代码片段放到 Github 上。","categories":[{"name":"Xcode","slug":"Xcode","permalink":"https://blog.alphabethub.com/categories/Xcode/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://blog.alphabethub.com/tags/Xcode/"}]},{"title":"陈坤在世间行走的旁白 - 读《突然就走到了西藏》","slug":"read-trjzdlxz","date":"2016-05-24T02:01:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/24/read-trjzdlxz/","link":"","permalink":"https://blog.alphabethub.com/2016/05/24/read-trjzdlxz/","excerpt":"","text":"突然就走到了西藏 “只要你行走，就能与你生命中的真相相遇。”——陈坤 相信很多朋友看过陈坤的影视作品，知晓他是一名演员，小的时候也磕磕绊绊看过他《金粉世家》《像雾像雨又像风》等荧屏作品。 这里要说的是陈坤有一本书，书名叫《突然就走到了西藏》，很短，十个章节。我是几乎一口气看完的。书里记录了陈坤带领十名大学生志愿者行走西藏过程中，对生命的点滴感悟。穿插了他成名前后生活中的小故事。应该是一本带有自传色彩的书，应该也是一个在世间行走的人对生命和心灵的旁白，你可以读到他的挣扎，他的茫然和转化。 在书里，的的确确能看到陈坤的真诚，并且看到他乐意分享旅程中和过去生活中的故事，以及自己的心路历程。书没有预先想象得那样肤浅。文笔一般，会让人感觉到偏执，但也能感受到字里行间的正面力量。同样很感动陈坤愿意分享他的年少时光，以及对待亲人和友人的态度，和他作为一个儿子，一个朋友以及一个父亲的时候，面对多种人生角色变换时，自己的感受。我想该是值得一读的吧，抵不上好书，是一个人的成长的心路写实。 2016/05/24 北京","categories":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/categories/Readed/"}],"tags":[{"name":"Readed","slug":"Readed","permalink":"https://blog.alphabethub.com/tags/Readed/"}]},{"title":"iOS - RunLoop & AutoreleasePool","slug":"ios-runloop-and-autoreleasepool","date":"2016-05-24T01:30:51.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/24/ios-runloop-and-autoreleasepool/","link":"","permalink":"https://blog.alphabethub.com/2016/05/24/ios-runloop-and-autoreleasepool/","excerpt":"","text":"RunLoop A NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. A NSRunLoop object also processes NSTimer events. RunLoop 的概念运行循环也叫消息循环，作用是循环的捕捉消息，然后执行消息对应的操作；并且保证应用程序不会退出。OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 Input source 与 Timer sourceInput source 与 Timer source这两个都是 RunLoop 事件的来源 Input Source 可以分为三类 Port-Based Sources：系统底层的 Port 事件源，例如CFSocketRef，但在应用层中几乎用不到。 Custom Input Sources：用户手动创建的事件源，例如手势，触摸，键入。 Cocoa Perform Selector Sources：Cocoa 提供的performSelector系列方法也是一种事件源。 Timer Source即是指定时器事件（NSTimer）。 RunLoop 与线程线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时候并没有 RunLoop，如果你不主动获取，那么它一直不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。所以只能在一个线程的内部获取 RunLoop(主线程除外)。 下图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。 Warning The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results. RunLoop ObserverRunLoop 通过监听 Source 来决定有没有任务要做；除此之外，我们还可以用 RunLoop Observer 来监控 RunLoop 本身的状态。 RunLoop Observer 可以监听以下 RunLoop 事件： The entrance to the run loop. When the run loop is about to process a timer. When the run loop is about to process an input source. When the run loop is about to go to sleep. When the run loop has woken up, but before it has processed the event that woke it up. The exit from the run loop. RunLoop Mode在监听与被监听中，RunLoop 要处理的事情非常复杂；为了让 RunLoop专注于处理特定事件而引入了 RunLoop Mode 概念如果所示，RunLoop Mode 实际上是 Source、Timer、Observer 的集合，不同的 Mode 把不同组的 Source、Timer、Observer 隔绝开来；而 RunLoop 在某个时刻下只能跑在某一个 Mode 下，处理这一个 Mode 当中的Source、Timer 和 Observer。 苹果文档中提到的 Mode 有五个，分别是： NSDefaultRunLoopMode NSConnectionReplyMode NSModalPanelRunLoopMode NSTrackingRunLoopMode NSRunLoopCommonModes iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 、UITrackingRunLoopMode 和 NSRunLoopCommonModes。 而NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSTrackingRunLoopMode。 RunLoop 的使用RunLoop 和线程是绑定在一起的；每个线程（包括主线程）都有一个对应的 RunLoop 对象。 获取 RunLoop我们不能自己创建 RunLoop 对象，只能获取到系统提供的 RunLoop 对象。 [NSRunLoop currentRunLoop];[NSRunLoop mainRunLoop]; 在主线程和子线程中区别RunLoop 在主线程和子线程中的 区别 在于：主线程的 RunLoop 会在应用启动的时候默认开启；其他线程（子线程）的 RunLoop 默认并不会启动，需要手动开启。 //手动启动RunLoop，无法控制结束[[NSRunLoop currentRunLoop] run];//手动启动RunLoop，指定结束时间[[NSRunLoop currentRunLoop] runUntilDate:[[NSDate date] dateByAddingTimeInterval:5]]; RunLoop 与 NSTimertimerWithTimeInterval://需要手动加入 RunLoop 并设置 ModeNSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];//立即调用一次[timer fire];//手动加入 RunLoop[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; scheduledTimerWithTimeInterval://默认加入 RunLoop 并设置 Mode 为 NSDefaultRunLoopModeNSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];//立即调用一次[timer fire]; 坑日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer，一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 NSDefaultRunLoopMode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode；而这个时候， Timer 就不会运行。 解决方案：设置RunLoop Mode，例如 NSTimer，我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。这样无论当前 RunLoop 运行哪个 Mode ，事件都能得到执行。 例如在 AFNetworking 中，就有相关的代码，如下： - (void)startActivationDelayTimer &#123; self.activationDelayTimer = [NSTimer timerWithTimeInterval:self.activationDelay target:self selector:@selector(activationDelayTimerFired) userInfo:nil repeats:NO]; [[NSRunLoop mainRunLoop] addTimer:self.activationDelayTimer forMode:NSRunLoopCommonModes];&#125; 这里就是添加了一个计时器，由于指定了 NSRunLoopCommonModes，所以不管 RunLoop 处于什么状态，都会执行这个计时器任务。 Runloop 和 Autoreleasepool 的关系图解 Autorelease PoolAutorelase Pool 提供了一种可以允许你向一个对象延迟发送 release 消息的机制；当你想放弃对象的所有权，同时又不希望这个对象被立即释放掉（例如在一个方法中返回一个对象时），Autoreleasepool就可以发挥作用。所谓的延迟发送release消息是指，当我们把一个对象标记为autorelease时: NSString* str = [[[NSString alloc] initWithString:@\"hello\"] autorelease]; 这个对象的retainCount+1，但不会发生 release；当这个变量所处的autoreleasepool被 倾倒(drain) 操作时，所有标记了autorelease的对象的 retainCount-1；即release消息的发送被延迟到autoreleasepool释放的时候了。在 ARC 环境下，苹果引入了 @autoreleasepool 语法，不在需要手动调用autorelease 和 drain 等方法。 提示 : 此处讨论的自动释放池不是手动创建的，是跟运行循环相关的，并非 main.m 中的 @autoreleasepool Autorelease Pool 的用处在 ARC 下我们并不需要手动调用autorelease有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确的管理好内存；因为 Cocoa Touch 的 RunLoop 中，每个 RunLoop Circle中系统都加入了 Autorelease Pool 的创建和释放。 当我们需要创建和销毁大量对象时，使用手动创建的autoreleasepool可以有效的避免内存峰值的出现；因为如果不手动创建的话，外层系统创建的 Pool 会在整个 Runloop Circle 结束之后才执行 drain 操作，手动创建的话会在 block 结束之后就就执行 drain 操作。详情请见苹果官方文档 一个普遍被使用的例子如下： for (int i = 0; i &lt; 10000000; i++)&#123; @autoreleasepool &#123; NSString* string = @\"abc\"; NSArray* array = [string componentsSeparatedByString:string]; &#125;&#125; 在上面的例子中如果不使用autoreleasepool，需要在循环结束之后释放1000000个字符串；如果使用的话会在每次循环结束的时候都进行release操作。 Autorelease Pool 进行 Drain 的时机如上所述，系统在 RunLoop 中创建的 autoreleasepool 会在 RunLoop 的一个 Event 结束时进行 Drain 操作；而我们手动创建的 autoreleasepool 会在 block 执行完后进行 Drain 操作。 但需要注意的是： 当 block 以异常(exception)结束时，pool 不会进行 drain 操作 Pool 的 drain 操作会把所有标记为 autorelease 的对象retainCount-1，但并不意味着这个对象一定会被释放掉；我们可以在 autoreleasepool 中手动 retain 该对象，以延长它的声明周期(在MRC中） main.m 中的 autoreleasepool 的解释在 iOS 程序的 main.m 文件中有类似这样的语句： int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 在面试中问到有关autorealeasepool的知识时，也多半会问一下，这里的 pool 有什么作用？能不能去掉之类…根据苹果官方文档：UIApplicationMain函数是整个 app 的入口，用来创建 application对象（单例）和application delegate；尽管这个函数有返回值，但是却永远不会返回，当按下Home键时，app 只是切换到了后台状态。 由文档知道，UIApplication会自己创建一个 main runloop，大致可以得到下面的结论： main.m中 UIApplicationMain 永远不会返回，只有在系统kill掉整个app时候，系统会把应用占用的全部内存释放出来。 因为 UIApplicationMain 永远不会返回，所以这里的 autoreleasepool 就永远不会进入到drain阶段。 假设真的有变量进入了main.m 中的这个 Pool（而没有被更内层的 Pool 捕获），那么这些内存实际上就是被泄露的，这个autoreleasepool 等于把这种泄露情况进行了隐藏。 UIApplication自己会创建 main runlooop，在 Cocoa 的 RunLoop 中实际上也是包含 autoreleasepool 的，因此main.m中的autoreleasepool可以认为是 没有必要 的。 另外，在基于 AppKit 框架的 Mac OS 开发中，main.m中就是不存在 autoreleasepool 的，这也进一步印证了上面的结论。不过因为不知道更底层的代码，加上苹果文档中不建议修改main.m 文件，所以我们也没有理由把它删掉。但是，删掉之后也不会影响 App 运行，用 Instruments 也没有发现内存泄露。 autoreleasepool的创建与销毁 创建 : 运行循环检测到事件并启动后，就会创建自动释放池 销毁 : 一次完整的运行循环结束之前，会被销毁 以上，autoreleasepool的创建与销毁都和运行循环（RunLoop）息息相关。 参考资料https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.htmlhttps://blog.ibireme.com/2015/05/18/RunLoop/","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"RunLoop","slug":"RunLoop","permalink":"https://blog.alphabethub.com/tags/RunLoop/"},{"name":"AutoreleasePool","slug":"AutoreleasePool","permalink":"https://blog.alphabethub.com/tags/AutoreleasePool/"}]},{"title":"iOS - Category 的使用和优缺点","slug":"ios-category-use-merit-and-demerit","date":"2016-05-16T06:30:47.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/16/ios-category-use-merit-and-demerit/","link":"","permalink":"https://blog.alphabethub.com/2016/05/16/ios-category-use-merit-and-demerit/","excerpt":"","text":"什么是Category?分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求；在实际开发中我们都会对系统的一些常用类进行扩展，例如：NSString,Button,Label等；简单来说类别是一种为现有的类添加新方法的方式。利用OC的动态运行时分配机制，category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象的子类就能为现有的类添加新的方法，category可以为任何已经存在的类添加方法，包括系统的框架UIKit等。 Category的优点： 可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理；也可以对框架提供类的扩展，把不同的功能组织到不同的category里，从而按需加载想要的category。 创建对私有方法的前向引用：如果其他类中的方法未实现时，或者在访问该类私有方法时编译器报错时；在类别中声明这些方法（不必提供方法实现）从而绕过编译器不会再产生警告或者错误。 向对象添加非正式协议：创建一个NSObject的类别成为“创建一个非正式协议”，因为可以作为任何类的委托对象使用（声明私有方法）。 apple的SDK中就大面积的使用了category这一特性。比如UIKit中的UIView。apple把不同的功能API进行了分类，这些分类包括UIViewGeometry、UIViewHierarchy、UIViewRendering等。不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景： 1. 模拟多继承（另外可以模拟多继承的还有protocol） 2. 把framework的私有方法公开 Category的局限性： category只能给某个已有的类扩充方法，不能扩充成员变量。 category中也可以添加属性，只不过@property只会生成setter和getter的声明，不会生成实现以及成员变量。 如果category中的方法和类中原有的方法同名，运行时会优先调用category中的方法。也就是，category中的方法会覆盖掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同;避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如category_xxx。 如果多个category中存在同名的方法，运行时到底调用那个方法由编译器决定，最后一个参与编译的方法会被调用。 如下：给UIView添加两个category（one和two）并且给这两个分类都添加了名为log的方法 UIView+One #import \"UIView+One.h\"@implementation UIView (One)- (void)log &#123; NSLog(@\"调用One分类的方法\");&#125;@end UIView+Two #import \"UIView+Two.h\"@implementation UIView (Two)- (void)log &#123; NSLog(@\"调用One分类的方法\");&#125;@end 在UIViewController中引用这两个分类的头文件并调用log方法 #import \"UIView+One.h\"#import \"UIView+Two.h\"@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIView * view = [UIView new]; [view log];&#125;@end 当编译顺序如下图时输出： 2018-05-18 15:23:13.379081+0800 CategoryDemo[2373:700484] 调用One分类的方法 将UIView+One.m移动到UIView+Two.m上面，编译顺序如下图时输出： 2018-05-18 15:27:25.008682+0800 CategoryDemo[2441:715950] 调用Two分类的方法 调用优先级Category-&gt;本类-&gt;父类 为什么Category不能添加成员变量？Objective-C的类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针 typedef struct objc_class * Class; objc_class结构体的定义如下： struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; &#x2F;&#x2F; 父类 const char *name OBJC2_UNAVAILABLE; &#x2F;&#x2F; 类名 long version OBJC2_UNAVAILABLE; &#x2F;&#x2F; 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; &#x2F;&#x2F; 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; &#x2F;&#x2F; 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; &#x2F;&#x2F; 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; &#x2F;&#x2F; 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; &#x2F;&#x2F; 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; &#x2F;&#x2F; 协议链表#endif&#125; OBJC2_UNAVAILABLE; 在上面的objc_class结构体中，ivars是objc_ivar_list（成员变量列表）指针；methodLists是指向objc_method_list指针的指针。在Runtime中，objc_class的大小是固定的，不可能往这个结构体中添加数据，只能修改。所以ivars指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。methodLists是一个二维数组，所以可以修改*methodLists的值来增加成员变量方法，虽然没办法扩展methodLists指向的内存区域，却可以改变这个内存区域的值（存储的是指针），因此可以动态添加方法，不能添加成员变量。 Category中能添加属性吗？Category中不能直接添加成员变量，那么可以添加属性吗？需要从Category的结构体开始分析： typedef struct category_t &#123; const char *name; &#x2F;&#x2F;类的名字 classref_t cls; &#x2F;&#x2F;类 struct method_list_t *instanceMethods; &#x2F;&#x2F;category中所有给类添加的实例方法的列表 struct method_list_t *classMethods; &#x2F;&#x2F;category中所有添加的类方法的列表 struct protocol_list_t *protocols; &#x2F;&#x2F;category实现的所有协议的列表 struct property_list_t *instanceProperties; &#x2F;&#x2F;category中添加的所有属性&#125; category_t; 从Category的结构体定义也可以看出:Category可以添加实例方法、类方法、协议、属性，但不能添加成员变量（实例变量） 为什么网上很多人说Category不可以添加属性?实际上，category是可以添加属性的，同样可以使用@property，但是不会生成带下划线的成员变量也不会生成属性getter和setter方法的实现。所以，尽管添加了属性，也无法使用点语法调用getter和setter方法（实际上，点语法是可以写的，只不过在运行时调用到这个方法的时候会报Unrecognised selector send to instance的错误），但可以使用Runtime去实现Category为已有的类添加新的属性并生成getter和setter方法 为什么不能为Category手动添加一个下划线开头的成员变量成员变量是一个类的东西，而分类本身就不是一个类，它并没有自己的isa指针，分类本来就是OC里通过运行时动态的为一个类添加属性和方法等，不是一个真正的类无法添加成员变量。 可以使用Runtime技术中的关联对象可以为类别添加属性 两点注意： 当category中的方法和原类中的方法同名时，category中的方法并没有完全替换掉原类中的方法，也就是说如果category和原类中都有一个methodA方法，那么category附加完成之后，类的方法里面会有两个methodA，实际上category的方法只是被放到新方法列表的前面，而原来类的方法只是被放到了新方法列表的后面，这也就是通常说的覆盖同名方法；这是因为运行时在查找方法的时候是顺着方法列表顺序查找的，它只要已找到对应名字的方法，就直接调用不会再往后面找了。 由于category的实现原理，和Objc的动态绑定有很强的关系，所以实际上类的扩展比较占用启动时间，因尽量合并一些在工程，架构上没有太大意义的扩展，会对启动有一定的优化作用。 扩展：成员变量和属性的区别？@property声明的属性默认会生成一个以下划线开头的成员变量，同事也会生成getter/setter方法。但这仅仅是在iOS5之后，苹果才推出的一个机制。在一些比较老的项目经常可以看到一大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用了@synthesize方法。 @interface ViewController ()&#123; // 1.声明成员变量 NSString * myString; &#125; //2.在用@property@property(nonatomic, copy) NSString * myString; @end@implementation ViewController//3.最后在@implementation中用synthesize生成set方法@synthesize myString; @end 实际上，发生这种状况的根本原因是苹果将默认编译器从GCC转换为LLVM（low level virtual machine）后，才不再需要为属性声明实例变量了。在没有更改之前，属性的正常写法需要 成员变量 + @property + @synthesize成员变量三个步骤如果我们只写成员变量+@property @interface GBViewController :UIViewController&#123; NSString * myString;&#125;@property (nonatomic, strong) NSString * myString;@end 这时，编译器会警告： Autosynthesized property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString' 但更换为LLVM之后，编译器在编译过程中发现没有生成实例变量时，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量（注意：是不必要，不是不可以）对于@synthesize我们要明白，@synthesize不仅可以帮助生成setter/getter方法；同时还有一个作用就是可以指定与属性对应的实例变量 @synthesize myString = _xxx； 那么self.myString其实是操作的实例变量_xxx，而不是_myString了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Category","slug":"Category","permalink":"https://blog.alphabethub.com/tags/Category/"}]},{"title":"Objc - Block","slug":"oc-block","date":"2016-05-10T03:21:20.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/10/oc-block/","link":"","permalink":"https://blog.alphabethub.com/2016/05/10/oc-block/","excerpt":"","text":"引言Apple 在iOS4.0之后推出Block，它本身封装了一段代码并可以将这段代码当做变量，参数，属性，数据类型，函数（匿名），代码块（只有在被调用时才会执行）等等，使用方式灵活，功能十分强大。 Block的简单使用定义Block 无参无返回值 void(^block)() = ^()&#123; NSLog(@\"this is a no param and no return of block\");&#125;;block(); 有参无返回值void(^block)(NSString * ) = ^(NSString * param)&#123; NSLog(@\"this is a has param and no return of block\");&#125;;block(@\"param\"); 有参有返回值NSString *(^block)(NSString * ) = ^(NSString * param)&#123; NSLog(@\"this is a has param and return of block\"); return @\"\";&#125;;block(@\"param\"); 定义Block的快捷方式 Block 的定义可以借助键入 inlineBlock 速记. // inlineBlockreturnType (^blockName)(parameterTypes) = ^(parameters) &#123; statements&#125;; Block定义成属性@property (copy, nonatomic) void(^block)(); Block作参数-(void)demo04&#123; void(^block)() = ^&#123; NSLog(@\"block become param\"); &#125;; [self callbackWith:block];&#125;-(void)callbackWith:(void(^)())block&#123; //调用外界传入的block block();&#125; typedef 定义Block// 声明typedef void(^MyBlock)();// 使用MyBlock block01 = ^&#123; NSLog(@\"block01\");&#125;;block01(); 小结：方便之处在于可以常用类型的Block可以用typedef来定义Block与外部变量Block内部访问/引用 外部变量int num = 10;NSLog(@\"%p %d\",&amp;num,num);void(^block)() = ^&#123; NSLog(@\"%p %d\",&amp;num,num);&#125;;num = 20;NSLog(@\"%@ %p %d\",block,&amp;num,num);block(); MRC输出结果：018-05-10 12:33:49.178446+0800 BlockDemo[1825:245809] 0x7ffee31dc9dc 102018-05-10 12:33:49.178655+0800 BlockDemo[1825:245809] &lt;__NSStackBlock__: 0x7ffee31dc9a8&gt; 0x7ffee31dc9dc 202018-05-10 12:33:49.178770+0800 BlockDemo[1825:245809] 0x7ffee31dc9c8 10 ARC输出结果：2018-05-10 12:36:47.248638+0800 BlockDemo[1887:256355] 0x7ffee517f9dc 102018-05-10 12:36:47.248856+0800 BlockDemo[1887:256355] &lt;__NSMallocBlock__: 0x604000259530&gt; 0x7ffee517f9dc 202018-05-10 12:36:47.249115+0800 BlockDemo[1887:256355] 0x604000259550 10 小结在block中访问外部的变量时，会自动拷贝到内存一份并开辟新的地址，这就是深拷贝 Block内部修改外部变量__block int num = 10; NSLog(@\"%p %d\",&amp;num,num); void(^block)() = ^&#123; num = 30; NSLog(@\"%p %d\",&amp;num,num); &#125;; num = 20; NSLog(@\"%@ %p %d\",block,&amp;num,num); block(); MRC输出结果：2018-05-10 12:41:56.490868+0800 BlockDemo[2018:272473] 0x7ffee14519d8 102018-05-10 12:41:56.491055+0800 BlockDemo[2018:272473] &lt;__NSStackBlock__: 0x7ffee1451980&gt; 0x7ffee14519d8 202018-05-10 12:41:56.491165+0800 BlockDemo[2018:272473] 0x7ffee14519d8 30 ARC输出结果：2018-05-10 12:43:13.402390+0800 BlockDemo[2047:277009] 0x7ffeea3149d8 102018-05-10 12:43:13.402662+0800 BlockDemo[2047:277009] &lt;__NSMallocBlock__: 0x60400024da70&gt; 0x604000034cf8 202018-05-10 12:43:13.402777+0800 BlockDemo[2047:277009] 0x604000034cf8 30 小结block内修改的外部变量，需要用__block修饰.在此后若被block访问修改，变量的内存地址会重新指向拷贝后开辟的新的内存地址. 验证一个想法 在ARC/MRC中block内引用外部变量地址如何在堆栈中变化，通过将Block自身作为自身的参数传入 int num = 10; NSLog(@\"%p %d\",&amp;num,num); void(^block)(void(^)()) = ^(void(^block2)())&#123; NSLog(@\"%@ %p %d\",block2,&amp;num,num); &#125;; num = 20; NSLog(@\"%@ %p %d\",block,&amp;num,num); //本身作为参数传入并输出指针对象的堆栈 block(block); 1.在ARC中block内引用外部变量地址如何在堆栈中变化，输出结果: 2018-05-10 12:51:29.359318+0800 BlockDemo[2216:302301] 0x7ffee29ab9dc 102018-05-10 12:51:29.359563+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x7ffee29ab9dc 202018-05-10 12:51:29.359708+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x600000259250 10 2.在MRC中block内引用外部变量地址如何在堆栈中变化，输出结果: 2018-05-10 12:46:27.120908+0800 BlockDemo[2153:287894] 0x7ffee8a699dc 102018-05-10 12:46:27.121106+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699dc 202018-05-10 12:46:27.121239+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699c8 10 小结：ARC下，永远在堆区中。MRC下永远在栈区中 block内存管理（MRC/ARC）函数体当函数体不变时void(^myBlock)() = ^ &#123; NSLog(@\"hello world\");&#125;;NSLog(@\"%@\", myBlock); 输出结果：2018-05-09 22:59:07.637768+0800 BlockDemo[3288:930159] &lt;__NSGlobalBlock__: 0x10afa20d8&gt; 小结：不引用任何外部变量的 block 保存在全局区 NSGlobalBlock，如果Block没有引用外部变量,那么这个Block的函数体内部包装的代码都不会发生变化,而且执行效率高,保存在全局区;(类似不变的字符串存在常量区)当函数体可变时（即访问修改外部变量时）int i = 10;void(^myBlock)() = ^ &#123; NSLog(@\"hello world %d\", i);&#125;;NSLog(@\"%@\", myBlock); 输出结果：2018-05-09 23:03:01.082413+0800 BlockDemo[3349:946888] &lt;__NSMallocBlock__: 0x600000440090&gt; 小结：引用外部变量的 block 保存在 :ARC : 堆区 NSMallocBlockMRC : 栈区 NSStackBlock因此在定义 block 属性时应该使用 copy 关键字，将 block 从栈区复制到堆区 Block属性//定义 block 属性@property (nonatomic, copy) void (^demoBlock)();-(void)blockDemo &#123; int i = 10; void(^myBlock)() = ^ &#123; NSLog(@\"hello world %d\", i); &#125;; NSLog(@\"%@\", myBlock); // 错误的写法，不会调用 setter 方法,MRC下,无法拷贝到堆区 //`_demoBlock` = myBlock; // 正确的写法，调用 setter 方法，并且对 block 进行 copy self.demoBlock = myBlock; NSLog(@\"%@\", self.demoBlock);&#125; MRC下输出结果：会执行copy操作，从栈区拷贝到堆区2018-05-10 12:03:17.374375+0800 BlockDemo[1225:138257] &lt;__NSStackBlock__: 0x7ffee68509a8&gt;2018-05-10 12:03:17.374581+0800 BlockDemo[1225:138257] &lt;__NSMallocBlock__: 0x60000025dca0&gt; ARC下输出结果：不会执行copy操作,本身就在堆区2018-05-10 12:04:42.891691+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt;2018-05-10 12:04:42.891902+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt; 注 : 为了避免程序员的麻烦,在 ARC 中,定义了引用外部变量的 block,系统默认都是在堆区的! copy关键字的探讨ARC （为什么可以用copy / strong）- (void)blockDemo&#123; int num = 10; void (^task)() = ^ &#123; NSLog(@\"%d\",num); &#125;; // ARC : 堆区 ==&gt; __NSMallocBlock__ // ARC环境下,属性也是强引用,同时会copy // self.task = task; // ARC环境下,成员变量也是强引用,同时会copy `_task` = task; NSLog(@\"%@ -- %@\",task,`_task`);&#125; 输出结果：2018-05-09 23:14:43.139413+0800 BlockDemo[3468:994925] &lt;__NSMallocBlock__: 0x60400024ea60&gt; -- &lt;__NSMallocBlock__: 0x60400024ea60&gt; 小结：在ARC环境下,上述block本来就保存在堆区,给属性赋值的时候,调用setter方法时,只会给一个引用.故ARC下使用strong和copy的效果是一模一样的 MRC（为什么必须用copy）-(void)blockDemo&#123; int num = 10; void (^task)() = ^ &#123; NSLog(@\"%d\",num); &#125;; // MRC : 栈区 ==&gt; __NSStackBlock__ // 这个赋值过程会copy,也会引用计数+1 // self.task = task; // 这个赋值过程不会copy,仅仅是引用计数+1,内存依然在栈区 `_task` = task; NSLog(@\"%@ -- %@\",task,`_task`);&#125; 输出结果：2018-05-09 23:17:25.352415+0800 BlockDemo[3528:1006735] &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt; -- &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt; 小结：在MRC环境下,调用成员变量进行赋值,仅仅是引用计数加1;不会进行copy操作. 所以内存依然在栈区. 面试时如何回答？当Block被引入到OC时 ，OC仍是MRC的管理内存模式 ，在MRC管理模式中，Block处于栈区，超出作用域就会被销毁 ，如果用一个属性来全局的记录这个Block，就必须满足两个条件：1.这个属性必须对Block强引用2.需要把Block拷贝到堆区要满足以上两个条件就需要使用copy修饰符 Block的循环引用满足什么条件会出现循环应用 block和外部变量互相强引用导致出现循环引用,内存不能正常释放 坑：不要在Block的内部使用成员变量(_name)，而要尽量使用属性，因为看不到self字段，会造成如果出现循环引用不容易发现的问题. 注：不是所有的 self. 都会出现循环引用 —— block 执行完毕就销毁，例如 UIView 的动画代码 如何解决循环引用// 使用 __weak 修饰符,定义一个弱引用的对象__weak typeof(self) weakSelf = self;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Block","slug":"Block","permalink":"https://blog.alphabethub.com/tags/Block/"}]},{"title":"iOS - pthread 使用和 __bridge","slug":"ios-thread-use-pthread","date":"2016-05-08T11:41:58.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/08/ios-thread-use-pthread/","link":"","permalink":"https://blog.alphabethub.com/2016/05/08/ios-thread-use-pthread/","excerpt":"","text":"pthread是POSIX thread的简写，跨平台多线程的C语言开发框架,pthread是实现多线程的技术方案之一，NSThread就是对它的封装。 pthread开启子线程的函数介绍#import &lt;pthread.h&gt;int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict, void *(*)(void *), void * __restrict); 参数pthread_t * : 线程标示符，传入指向线程标示符的指针地址。pthread_attr_t * :线程属性，传入指向线程属性的指针地。void*( * )(void * ) :新线程要执行的函数(任务)，传入函数地址，即函数名。void *:传入到函数的参数。 返回值 返回int类型的值,0表示创建新线程成功,反之,创建新线程失败,返回失败的编号。 C语言框架里面并不是非零即真原则；因为他们认为成功的结果只有一个，但是失败的原因有很多。 pthread开启子线程的函数实现- (void)pthreadDemo &#123; // 新线程的标示符 pthread_t ID; // 创建子线程 int result = pthread_create(&amp;ID, NULL, demo, NULL); // 判断创建子线程是否成功 if (result == 0) &#123; NSLog(@“success”); &#125; else &#123; NSLog(@“failure”); &#125;&#125; 子线程异步执行的函数/任务void * demo(void *param)&#123; NSLog(@\"demo %@\",[NSThread currentThread]); return NULL;&#125; 小结 C 语言中 void * 与 OC 中的 id 类似。 void *(*)(void *) 中的(*) 表示指向函数的指针，即函数指针，即函数名或者函数地址。 __bridge用作于普通的 C 指针与 OC 指针的转换，不做任何操作。 void *p;NSObject *objc &#x3D; [[NSObject alloc] init];p &#x3D; (__bridge void*)objc; 这里的 void * p 指针直接指向了 NSObject * objc 这个 OC 类，p 指针并不拥有 OC 对象，跟普通的指针指向地址无疑。所以这个出现了一个问题，OC 对象被释放，p 指针也就释放了。 __bridge_retained用作 C 指针与 OC 指针的转换，并且也用拥有着被转换对象的所有权 __bridge_transfer用作 C 指针与 OC 指针的转换，并在拥有对象所有权后将原先对象所有权释放。(只支持 C 指针转换 OC 对象指针)其实可以理解为先将对象的引用计数器 +1，然后再将引用计数器 -1。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.alphabethub.com/tags/Thread/"}]},{"title":"iOS - 多线程之 GCD","slug":"ios-thread-gcd","date":"2016-05-05T07:59:59.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/05/ios-thread-gcd/","link":"","permalink":"https://blog.alphabethub.com/2016/05/05/ios-thread-gcd/","excerpt":"","text":"GCD与 NSThread 的对比NSThread的劣势 如果要开多个线程 NSThread 必须实例化多个线程对象 NSThread 靠 NSObject 的分类方法实现的线程间通讯，GCD依靠 block 实现 GCD的优势 让代码更加简单，易于阅读和维护 使用GCD 不需要管理线程的创建/销毁/复用的过程，不用关心线程的生命周期 GCD会充分利用CPU的内核 队列有哪些，任务有几种队列 串行队列（Serial Dispatch Queue）dispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_SERIAL); 并行队列（Concurrent Dispatch Queue）dispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_CONCURRENT); 任务 同步任务（sync）dispatch_sync(queue, ^block); 异步任务（async）dispatch_async(queue, ^block); 写一个死锁程序 主队列+同步任务 = 死锁 - (void)deadlockDemo&#123; dispatch_queue_t queue = dispatch_get_main_queue(); NSLog(@\"start”); dispatch_sync(queue, ^&#123; NSLog(@\"excuting...%@\",[NSThread currentThread]); &#125;); NSLog(@\"end\");&#125; 死锁解决办法：主队列中的同步任务放进子线程中，不使其阻塞主线程 - (void)resolveDemo&#123; dispatch_async(dispatch_queue_create(\"flag\", DISPATCH_QUEUE_CONCURRENT), ^&#123; NSLog(@\"start\"); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@\"excuting...%@\",[NSThread currentThread]); &#125;); NSLog(@\"end\"); &#125;);&#125; 全局队列的两个参数分别代表什么？ 参数1：服务质量(队列对任务调度的优先级)/iOS 7.0 之前，是优先级，传入0在所有系统上使用默认设置 参数2：预留参数，以便于扩展，一般传入0 小结：如果要适配 iOS 7.0 &amp; 8.0，需要使用以下代码： dispatch_get_global_queue(0, 0); 全局队列和并发队列的区别全局队列 没有名称 无论MRC &amp; ARC都不需要考虑释放 并发队列 有名称，和 NSThread 的 name 属性作用类似 如果在 MRC 开发时,需要使用 dispatch_release(q); 释放相应的对象 队列和任务组合总结 串行和并发决定了任务的执行方式(串行一次一个，并发一次多个) 同步和异步决定了要不要开启新的线程 (同步不开，异步开) GCD延迟执行(after) 延迟操作: dispatch_after 这个函数默认是异步执行的-(void)afterDemo&#123; NSLog(@\"start\"); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)),dispatch_get_global_queue(),^&#123; NSLog(@\"delay code\"); &#125;); NSLog(@\"end\");&#125; GCD一次性执行(once) dispatch_once_t 内部有一把锁,能够保证线程安全. 原理：onceToken 有个初始值,当第一次执行时,判断是否是初始值,如果是初始值就执行函数内部的代码,执行结束之前会修改onceToken初始值.反之,就不执行.- (void)onceDemo&#123; NSLog(@\"mark\"); static dispatch_once_t onceToken; NSLog(@\"result %ld\",onceToken); dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"hello\"); &#125;);&#125; 单例设计模式（iOS）单例设计模式的特点 有一个全局访问点（供全局实例化单例的类方法） 单例保存在静态存储区 在内存有且只有一份 生命周期跟APP一样长 如何做到被子类继承 在给instance赋值时要使用[self new];或者[[self alloc] init]; 懒汉式+ (instancetype)shared&#123; // 保存在静态存储区 static id instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; 饿汉式@implementation Singleton// 声明静态对象static id instance;+ (void)initialize&#123; // 只会开辟一次内存空间,只会被实例化一次 instance = [[self alloc] init];&#125;+ (instancetype)shared&#123; return instance;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.alphabethub.com/tags/Thread/"},{"name":"GCD","slug":"GCD","permalink":"https://blog.alphabethub.com/tags/GCD/"}]},{"title":"iOS - NSURLRequest & NSURLResponse","slug":"ios-nsurlrequest-and-nsurlresponse","date":"2016-05-02T14:30:51.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/05/02/ios-nsurlrequest-and-nsurlresponse/","link":"","permalink":"https://blog.alphabethub.com/2016/05/02/ios-nsurlrequest-and-nsurlresponse/","excerpt":"","text":"NSURLRequest创建请求对象 (缓存策略和超时时长都是默认的)NSURLRequest * request = [NSURLRequest requestWithURL:url]; 创建请求对象的同时指定缓存策略和超时时长NSURLRequest * request = [NSURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15]; 缓存策略 枚举 数值 说明 NSURLRequestUseProtocolCachePolicy 0 默认的缓存策略 NSURLRequestReloadIgnoringLocalCacheData 1 忽略本地缓存数据，始终加载服务器的数据对数据的及时性要求高的应用 NSURLRequestReturnCacheDataElseLoad 2 如果有缓存，就返回缓存，否则加载最新数据 NSURLRequestReturnCacheDataDontLoad 3 只加载缓存数据,不去服务器上获取(离线地图) 超时时长 默认网络时长是 60 s SDWebImage 的默认超时时长是 15 秒AFN 的默认超时时长是 60 秒 NSMutableURLRequest（可变请求）// 可变的请求对象才能设置额外的信息NSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15];// 设置请求头 : 告诉服务器,我的设备是iphone[requestM setValue:@\"iphone AppleWebKit\" forHTTPHeaderField:@\"User-Agent\"]; NSURLResponse响应头 响应属性 说明 URL 服务器反馈的 URL，有的时候，服务器会重定向新的 URL MIMEType 服务器告诉客户端，返回的二进制数据的类型（纯文本，视频，语音，超文本等）ContentType根据 MIMEType 客户端就知道使用什么软件处理返回的二进制数据 statusCode 状态码1XX消息2XX 成功3XX 更多选择4XX 客户端错误5XX 服务器错误 expectedContentLength 数据长度，下载文件总长度 suggestedFilename 获取服务器的文件的名称 allHeaderFields 返回数据的头部信息，key－value格式 textEncodingName 编码的名称 响应体 data data 服务器返回的二进制数据，程序员最关心的内容 拿到响应体之后,无法直接使用,需要进行反序列化,转换成OC对象. GET请求 URL中有中文时如何处理？NSString * URLString = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; 注意：GET请求时,问号?后面的查询字符串里面不能有中文或者空格.如果有就需要使用%转义,不然URL会为nil. POST请求时,请求体里面可以有中文.URLQueryAllowedCharacterSet : 百分号转义查询字符串 URL转字符串的方法[filePath.path / filePath.absoluteString]","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Network","slug":"Network","permalink":"https://blog.alphabethub.com/tags/Network/"},{"name":"NSURLRequest","slug":"NSURLRequest","permalink":"https://blog.alphabethub.com/tags/NSURLRequest/"},{"name":"NSURLResponse","slug":"NSURLResponse","permalink":"https://blog.alphabethub.com/tags/NSURLResponse/"}]},{"title":"iOS - 多线程之 NSThread","slug":"ios-nsthread","date":"2016-04-30T06:56:59.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/04/30/ios-nsthread/","link":"","permalink":"https://blog.alphabethub.com/2016/04/30/ios-nsthread/","excerpt":"","text":"多线程基础（NSThread）NSThread创建线程的三种方式1. NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@\"alloc\"];2. [NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@\"detach\"];3. [self performSelectorInBackground:@selector(demo:) withObject:@\"perform\"]; target和selector的关系 执行哪个对象上的哪个方法. 线程的状态-生命周期 start ：就绪状态，等待被CPU调用，当被调用的时候为运行状态 sleep/加锁：阻塞状态 exit：完全杀死（非正常死亡），不要在主线程中调用 线程属性name (线程名称) 设置线程名称可以当线程执行的方法内部出现异常时，记录异常和当前线程 stackSize(栈区大小) 默认情况下，无论是主线程还是子线程，栈区大小都是 512K 栈区大小可以设置 [NSThread currentThread].stackSize = 1024 * 1024; 必须是 4KB 的倍数 isMainThread (是否主线程)threadPriority (线程优先级) 优先级，是一个浮点数，取值范围从0~1.0 1.0表示优先级最高 0.0表示优先级最低 默认优先级是 0.5 优先级高只是保证 CPU 调度的可能性会高 qualityOfService (服务质量,iOS 8.0 推出) NSQualityOfServiceUserInteractive - 用户交互，例如绘图或者处理用户事件 NSQualityOfServiceUserInitiated - 用户需要 NSQualityOfServiceUtility - 实用工具，用户不需要立即得到结果 NSQualityOfServiceBackground - 后台 NSQualityOfServiceDefault - 默认，介于用户需要和实用工具之间 线程安全-资源共享（互斥锁小结） @synchronized互斥锁，使用了线程同步技术 同步锁/互斥锁：可以保证被锁定的代码，同一时间，只能有一个县城可以操作 self：锁对象，任何继承自NSObject的对象都可以是锁对象，因为内部都有一把锁，而且是默认开着的 锁对象：一定要是全局的锁对象，要保证所有的线程都能访问，self是最方便使用的锁对象 互斥锁锁定的范围应该尽量小，但是一定要锁住资源的读写部分 加锁后程序的执行效率比不加锁的时候要低，因为线程要的等待解锁 牺牲了性能保证了安全 原子属性和非原子属性-以及自旋锁nonatomic : 非原子属性 线程不安全，不考虑多线程情况时使用此属性 编译器少生成一些互斥加锁代码，可以提高效率。 atomic : 原子属性 线程安全的,针对多线程设计的属性修饰符,是默认值. 特点 : 单写多读 单写多读 : 保证同一时间,只有一个线程能够执行setter方法,但是可以有多个线程执行getter方法. atomic 属性的setter里面里面有一把锁,叫做自旋锁. 原子属性的setter方法是线程安全的;但是,getter方法不是线程安全的. nonatomic和atomic对比： nonatomic: 非线程安全,适合内存小的移动设备. atomic : 线程安全,需要消耗大量的资源.性能比非原子属性要差一点 自旋锁和互斥锁的区别举个比较形象的例子就是：在火车上上厕所，自旋锁是比较着急那个人一直会敲门，问好了没有好了没有；而互斥锁就会等待厕所内的人出来之后自己在进去。显然自旋锁更为高效 线程间通信（为什么能通信？） performSelectorInBackground performSelectorOnMainThread 因为多线程共享地址空间和数据空间， 一个线程的数据可以直接提供给其他线程使用,叫做线程间通信","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.alphabethub.com/tags/Thread/"},{"name":"NSThread","slug":"NSThread","permalink":"https://blog.alphabethub.com/tags/NSThread/"}]},{"title":"iOS - 多线程之 NSOperation","slug":"ios-thread-nsoperation","date":"2016-04-29T09:14:05.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/04/29/ios-thread-nsoperation/","link":"","permalink":"https://blog.alphabethub.com/2016/04/29/ios-thread-nsoperation/","excerpt":"","text":"NSOperationapple提供的多线程解决方案NSOperation是一个表示与单个任务关联的代码和数据的抽象类；因为是一个抽象类，所以不能直接使用，需要使用它的两个子类(NSInvocationOperation or NSBlockOperation) 去执行实际的操作任务；同样我们也可以通过自定义NSOperation。通常将操作添加到操作队列（NSOperationQueue类的实例）来执行操作。其实NSOperation就是对GCD的封装，相对于GCD来说可控性更强，并且可以加入操作依赖（addDependency: and removeDependency）。 NSInvocationOperationstart- (void)demo1 &#123; NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"]; [op start];&#125;- (void)operationTask:(id)param &#123; NSLog(@\"%@\",[NSThread currentThread]);&#125; 输出结果：发现在主线程中输出的结果，但start方法是在当前线程中执行的 2018-05-19 14:45:07.956558+0800 NSOperation练习[1324:290009] &lt;NSThread: 0x604000078000&gt;&#123;number = 1, name = main&#125; 将操作添加到队列- (void)demo2 &#123; NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"]; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; [queue addOperation:op];&#125; 输出结果：开启子线程异步执行 2018-05-19 14:50:53.013010+0800 NSOperation练习[1408:312296] &lt;NSThread: 0x60400046b600&gt;&#123;number = 3, name = (null)&#125; NSBlockOperation (使用较多)start- (void)demo4 &#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"%@\",[NSThread currentThread]); &#125;]; [op start];&#125; 输出结果：start方法是在当前线程中执行 2018-05-19 15:06:11.837276+0800 NSOperation练习[1661:375754] &lt;NSThread: 0x6000000745c0&gt;&#123;number = 1, name = main&#125; 将操作添加到队列- (void)demo5 &#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"%@\",[NSThread currentThread]); &#125;]; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; [queue addOperation:op];&#125; 输出结果：开启子线程异步执行 2018-05-19 15:10:23.974301+0800 NSOperation练习[1720:389949] &lt;NSThread: 0x60400027ea40&gt;&#123;number = 3, name = (null)&#125; 执行块- (void)demo6 &#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"block 2 %@\", [NSThread currentThread]); &#125;]; [op addExecutionBlock:^&#123; NSLog(@\"block 1 %@\", [NSThread currentThread]); &#125;]; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; [queue addOperation:op]; NSLog(@\"%@\", op.executionBlocks);&#125; 输出结果：执行块和操作享有共同的属性设置，异步执行 2018-05-19 15:20:27.839119+0800 NSOperation练习[1882:431125] ( \"&lt;__NSGlobalBlock__: 0x1086f9080&gt;\", \"&lt;__NSGlobalBlock__: 0x1086f90c0&gt;\")2018-05-19 15:20:27.839131+0800 NSOperation练习[1882:431333] block 2 &lt;NSThread: 0x60000027bbc0&gt;&#123;number = 3, name = (null)&#125;2018-05-19 15:20:27.839133+0800 NSOperation练习[1882:431330] block 1 &lt;NSThread: 0x604000466fc0&gt;&#123;number = 4, name = (null)&#125; 线程间通讯- (void)demo7&#123; [[NSOperationQueue new] addOperationWithBlock:^&#123; NSLog(@\"consuming time：%@\",[NSThread currentThread]); /// 回到主线程刷新UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; NSLog(@\"refresh ui: %@\",[NSThread currentThread]); &#125;]; &#125;];&#125; 监听block执行完成- (void)demo13 &#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; for (NSInteger i=0; i&lt;5; ++i) &#123; NSLog(@\"%zd %@\",i,[NSThread currentThread]); &#125; &#125;]; //设置监听操作执行完成的block，必须要在把操作添加到队列之前设置 [op setCompletionBlock:^&#123; NSLog(@\"setCompletionBlock %@\",[NSThread currentThread]); &#125;]; [[NSOperationQueue new]addOperation:op];&#125; 输出结果： 2018-05-19 16:12:00.170053+0800 NSOperation练习[2607:585084] 0 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:12:00.170267+0800 NSOperation练习[2607:585084] 1 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:12:00.170410+0800 NSOperation练习[2607:585084] 2 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:12:00.171319+0800 NSOperation练习[2607:585084] 3 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:12:00.171538+0800 NSOperation练习[2607:585084] 4 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:12:00.171816+0800 NSOperation练习[2607:585083] setCompletionBlock &lt;NSThread: 0x60000027bd40&gt;&#123;number = 4, name = (null)&#125; 自定义NSOperation自定义类继承NSOperation@interface CustomOperation : NSOperation@end - (void)viewDidLoad &#123; [super viewDidLoad]; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; DownloadOperation * op = [[DownloadOperation alloc]init]; [queue addOperation:op];&#125; 重写main方法任何操作在执行时,首先会调用start方法,start方法会更新操作的状态(过滤操作)；经start方法过滤之后，只有正常可执行的操作，就会调用这个main方法，重写操作的入口方法(main方法)，就可以在这个方法里面指定操作执行的任务。main方法默认在子线程中异步执行 - (void)main&#123; //在这个方法中做想要做的操作，即自定义 NSOperation的目的 NSLog(@\"%@\",self.URLString,[NSThread currentThread]);&#125; NSOperationQueue 使用NSOperationQueue只有一种类型，就是并发队列。在开发使用到NSOperationQueue时，建议将其定义为全局队列。 // 定义为属性@property (nonatomic,strong) NSOperationQueue *queue;- (NSOperationQueue * )queue&#123; if (self.queue == nil) &#123; self.queue = [[NSOperationQueue alloc] init]; &#125; return self.queue;&#125; 最大并发数maxConcurrentOperationCount是队列的一个属性，可以限制队列同时执行的任务数量，从而间接的控制了线程数量(线程可以复用)，但队列最大并发数不是线程数。如果队列最大并发数设置为1，那么队列实际上就是一个串行队列了。 // 设置最大并发数 : 每次只能调度两个操作执行queue.maxConcurrentOperationCount = 2; 验证队列的并发性NSOperationQueue &amp; NSInvocationOperation- (void)demo8 &#123; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; for (NSInteger i=0; i&lt;10; ++i) &#123; NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(operationTask:) object:@(i)]; [queue addOperation:op]; &#125;&#125; 输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明NSOperationQueue默认是并发执行 2018-05-19 15:01:47.478515+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;2018-05-19 15:01:47.478518+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;2018-05-19 15:01:47.478519+0800 NSOperation练习[1593:358936] &lt;NSThread: 0x60400047a500&gt;&#123;number = 6, name = (null)&#125;2018-05-19 15:01:47.478572+0800 NSOperation练习[1593:358935] &lt;NSThread: 0x60400047a640&gt;&#123;number = 5, name = (null)&#125;2018-05-19 15:01:47.478740+0800 NSOperation练习[1593:358974] &lt;NSThread: 0x600000263a40&gt;&#123;number = 7, name = (null)&#125;2018-05-19 15:01:47.478881+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;2018-05-19 15:01:47.478902+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;2018-05-19 15:01:47.479084+0800 NSOperation练习[1593:358975] &lt;NSThread: 0x6000002636c0&gt;&#123;number = 8, name = (null)&#125;2018-05-19 15:01:47.479096+0800 NSOperation练习[1593:358976] &lt;NSThread: 0x600000263d00&gt;&#123;number = 10, name = (null)&#125;2018-05-19 15:01:47.479128+0800 NSOperation练习[1593:358977] &lt;NSThread: 0x600000263dc0&gt;&#123;number = 9, name = (null)&#125; NSOperationQueue &amp; NSBlockOperation- (void)demo10 &#123; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; for (NSInteger i=0; i&lt;10; ++i) &#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"%@\",[NSThread currentThread]); &#125;]; [queue addOperation:op]; &#125;&#125; 输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明NSOperationQueue默认是并发执行 2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;2018-05-19 15:26:52.141569+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;2018-05-19 15:26:52.141641+0800 NSOperation练习[1984:456313] &lt;NSThread: 0x604000469d80&gt;&#123;number = 6, name = (null)&#125;2018-05-19 15:26:52.141661+0800 NSOperation练习[1984:456385] &lt;NSThread: 0x60000027ee80&gt;&#123;number = 8, name = (null)&#125;2018-05-19 15:26:52.141676+0800 NSOperation练习[1984:456318] &lt;NSThread: 0x604000469c40&gt;&#123;number = 7, name = (null)&#125;2018-05-19 15:26:52.141928+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;2018-05-19 15:26:52.141945+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;2018-05-19 15:26:52.141954+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;2018-05-19 15:26:52.142048+0800 NSOperation练习[1984:456386] &lt;NSThread: 0x60000027f380&gt;&#123;number = 9, name = (null)&#125; 队列暂停继续和取消全部isSuspended:暂停和继续队列的属性；YES代表暂停队列，NO代表恢复队列。将队列挂起之后，队列中的操作就不会被调度，但是正在执行的操作不受影响operationCount: 操作计数,没有执行和没有执行完的操作,都会计算在操作计数之内 注意 : 如果先暂停队列,再添加操作到队列,队列不会调度操作执行.所以在暂停队列之前要判断队列中有没有任务.如果没有操作就不暂停队列. #pragma mark - 演示队列的暂停- (IBAction)pause:(id)sender&#123; // 暂停队列之前判断队列中有无操作 if (self.queue.operationCount == 0) &#123; return; &#125; // 暂停队列 self.queue.suspended = YES; NSLog(@\"pause %zd\",self.queue.operationCount);&#125; cancelAllOperations:取消队列中的全部操作；旦调用的 cancelAllOperations方法，队列中的操作，都会被移除，正在执行的操作除外；正在执行的操作取消不了，如果要取消，需要自定义NSOperation；队列取消全部操作时，会有一定的时间延迟。 - (IBAction)cancelAll:(id)sender&#123; [self.queue cancelAllOperations]; NSLog(@\"cancelAll %zd\",self.queue.operationCount);&#125; qualityOfService服务质量的枚举： typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; NSQualityOfServiceUserInteractive = 0x21, NSQualityOfServiceUserInitiated = 0x19, NSQualityOfServiceUtility = 0x11, NSQualityOfServiceBackground = 0x09, NSQualityOfServiceDefault = -1&#125; API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0)); operation让队列里面的操作有更多的机会被队列调度执行，类似于线程优先级 - (void)demo11 &#123; NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"op1 block %@\",[NSThread currentThread]); &#125;]; for (NSInteger i=0; i&lt;5; ++i) &#123; [op1 addExecutionBlock:^&#123; NSLog(@\"opt1 %@\",[NSThread currentThread]); &#125;]; &#125; op1.qualityOfService = NSQualityOfServiceBackground; NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"op2 block %@\",[NSThread currentThread]); &#125;]; for (NSInteger i=0; i&lt;5; ++i) &#123; [op2 addExecutionBlock:^&#123; NSLog(@\"opt2 %@\",[NSThread currentThread]); &#125;]; &#125; op2.qualityOfService = NSQualityOfServiceUserInteractive; NSOperationQueue * queue = [[NSOperationQueue alloc]init]; [queue addOperations:@[op1,op2] waitUntilFinished:false];&#125; 输出结果：op2优先于op1执行 2018-05-19 16:05:46.292652+0800 NSOperation练习[2511:564443] op2 block &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;2018-05-19 16:05:46.292656+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;2018-05-19 16:05:46.292654+0800 NSOperation练习[2511:564445] opt2 &lt;NSThread: 0x604000470ac0&gt;&#123;number = 6, name = (null)&#125;2018-05-19 16:05:46.292709+0800 NSOperation练习[2511:564454] opt2 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;2018-05-19 16:05:46.292933+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;2018-05-19 16:05:46.292937+0800 NSOperation练习[2511:564443] opt2 &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;2018-05-19 16:05:46.292944+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;2018-05-19 16:05:46.292960+0800 NSOperation练习[2511:564444] op1 block &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:05:46.293083+0800 NSOperation练习[2511:564454] opt1 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;2018-05-19 16:05:46.293089+0800 NSOperation练习[2511:564453] opt1 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;2018-05-19 16:05:46.294076+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;2018-05-19 16:05:46.294207+0800 NSOperation练习[2511:564444] opt1 &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125; queue- (void)demo12 &#123; NSOperationQueue * q1 = [[NSOperationQueue alloc]init]; NSOperationQueue * q2 = [[NSOperationQueue alloc]init]; q1.qualityOfService = NSQualityOfServiceBackground; q2.qualityOfService = NSQualityOfServiceUserInteractive; for (NSInteger i=0; i&lt;5; ++i) &#123; [q1 addOperationWithBlock:^&#123; NSLog(@\"q1\"); &#125;]; [q2 addOperationWithBlock:^&#123; NSLog(@\"q2\"); &#125;]; &#125;&#125; 输出结果：q2优先于q1执行 2018-05-19 16:05:11.965991+0800 NSOperation练习[2487:561497] q2 &lt;NSThread: 0x604000274e00&gt;&#123;number = 4, name = (null)&#125;2018-05-19 16:05:11.965998+0800 NSOperation练习[2487:561496] q2 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561517] q2 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;2018-05-19 16:05:11.966316+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;2018-05-19 16:05:11.968284+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125;2018-05-19 16:05:11.968303+0800 NSOperation练习[2487:561495] q1 &lt;NSThread: 0x604000275680&gt;&#123;number = 8, name = (null)&#125;2018-05-19 16:05:11.968376+0800 NSOperation练习[2487:561517] q1 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;2018-05-19 16:05:11.968409+0800 NSOperation练习[2487:561496] q1 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;2018-05-19 16:05:11.969839+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125; 支持KVO的属性isCancelled - read-only &#x2F;&#x2F;是否取消isAsynchronous - read-only &#x2F;&#x2F;是否异步isExecuting - read-only &#x2F;&#x2F;是否正在执行isFinished - read-only &#x2F;&#x2F;是否结束isReady - read-only &#x2F;&#x2F;是否就绪dependencies - read-only &#x2F;&#x2F;依赖的其他的操作queuePriority - readable and writable &#x2F;&#x2F;队列优先级completionBlock - readable and writable &#x2F;&#x2F;结束回调 操作间依赖需求实例场景：用户需要先登录-&gt;付费-&gt;下载-&gt;通知用户 - (void)dependency&#123; NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"login %@\",[NSThread currentThread]); &#125;]; NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"pay %@\",[NSThread currentThread]); &#125;]; NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"download %@\",[NSThread currentThread]); &#125;]; NSBlockOperation * op4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"notice user %@\",[NSThread currentThread]); &#125;];&#125; 添加依赖[op2 addDependency:op1]; // 操作2依赖于操作1[op3 addDependency:op2]; // 操作3依赖于操作2[op4 addDependency:op3]; // 操作4依赖于操作3// waitUntilFinished : 是否等到指定的操作执行结束再执行后面的代码[self.queue addOperations:@[op1,op2,op3] waitUntilFinished:NO];// 通知用户的操作在主线程中执行[[NSOperationQueue mainQueue] addOperation:op4];// 验证 waitUntilFinishedNSLog(@\"end\"); 小结 不能循环建立操作间依赖关系.否则,队列不调度操作执行 操作间可以跨队列建立依赖关系 要将操作间的依赖建立好了之后,再添加到队列中（先建立操作依赖关系，再把操作添加到队列） NSOperation和GCD的区别 GCDGCD iOS 4.0 推出，针对多核处理器的并发技术。GCD属于C语言的框架。将任务封装在block中，如果要停止已经加入 队列(queue) 的 任务(block) 需要写复杂的代码。只能设置队列的优先级不能设置任务的优先级。 高级功能 barrier once after group NSOperationNSOperation iOS 2.0 推出，但在苹果推出 GCD 之后，对NSOperation的底层全部重写。NSOperation属于OC 框架，更加面向对象，底层是对 GCD 的封装。支持取消掉队列中的任务(正在执行的除外)，还可以设置队列中每个操作的优先级 高级功能 最大操作并发数(GCD不好做) 继续/暂停/全部取消 跨队列设置操作的依赖关系","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.alphabethub.com/tags/Thread/"},{"name":"NSOperation","slug":"NSOperation","permalink":"https://blog.alphabethub.com/tags/NSOperation/"}]},{"title":"硬币","slug":"daily-2016-0422","date":"2016-04-22T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2016/04/22/daily-2016-0422/","link":"","permalink":"https://blog.alphabethub.com/2016/04/22/daily-2016-0422/","excerpt":"","text":"硬币 你有没有扔过一枚硬币，选择正反面? 为什么就不能踏踏实实的面对这个世界凭什么就非得打破陈规旧世界做救世主你想的要的只不过是平凡日子里的快乐你真没必要对自己如此苛刻你看那奔跑的青春的身影你看这些年，这世界，于你而言多了些什么，又少了些什么是想要的吗是年少时的梦想吗你口口声声说着情怀，念着诗和远方真的还记得起当初为什么出发吗执念你知道它，却不能掌控它你了解它，就像它了解你这样你便成就了它，而放弃了自己有些人生理想，终会伴随着你，缠绕着你，不离不弃而，你永远都没有勇气对它说再见 2016/04/22 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"iOS - NSURLSession","slug":"ios-network-nsurlsession","date":"2016-04-02T11:31:42.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/04/02/ios-network-nsurlsession/","link":"","permalink":"https://blog.alphabethub.com/2016/04/02/ios-network-nsurlsession/","excerpt":"","text":"Apple在 iOS9.0 之后已经放弃了 NSURLConnection，所以在现在的实际开发中，一般使用的是 iOS7.0 之后推出的 NSURLSession。NSURLSession 和 NSURLConnection 都提供了与各种协议，诸如 HTTP 和 HTTPS 进行交互的API。会话对象（NSURLSession 类对象）就是用于管理这种交互过程。它是一个高度可配置的容器，通过使用其提供的API，可进行细粒度的管理控制。它提供了在 NSURLConnection 中的所有特性，此外，它还可以实现 NSURLConnection 不能完成的任务，例如实现私密浏览。 结构图 NSURLSession发送网络请求- (void)viewDidLoad &#123; [super viewDidLoad]; NSURL * URL = [NSURL URLWithString:@\"http://www.baidu.com\"]; NSURLSession * session = [NSURLSession sharedSession]; NSURLSessionDataTask * dataTask = [session dataTaskWithURL:URL completionHandler:^(NSData * data, NSURLResponse * response, NSError * error) &#123; // data : 响应体; response : 响应头; error : 错误信息 if (error == nil &amp;&amp; data != nil)&#123; NSLog(@\"%@ -- %@ -- %@\",response,data,[NSThread currentThread]); &#125; else &#123; NSLog(@\"%@\",error); &#125; &#125;]; [dataTask resume];&#125; HTML字符串反序列化[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 反序列化HTML字符串 NSString * html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; // 展示HTML字符串 [self.webView loadHTMLString:html baseURL:URL];&#125;]; 小结 为了方便程序员使用，NSURLSession提供了一个全局单例 session. 所有的 任务(Task) 都是由 session 发起的. 所有的任务默认是挂起的，需要 resume. 完成回调是异步的 session可以自定义,自定义的时候可以同时设置代理. AFNetworing 底层其实就是对 NSURLSession 的封装","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"Network","slug":"Network","permalink":"https://blog.alphabethub.com/tags/Network/"},{"name":"NSURLSession","slug":"NSURLSession","permalink":"https://blog.alphabethub.com/tags/NSURLSession/"}]},{"title":"iOS - 网络基础 & Http & Https","slug":"ios-networkbase-http-and-https","date":"2016-03-29T09:29:30.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/03/29/ios-networkbase-http-and-https/","link":"","permalink":"https://blog.alphabethub.com/2016/03/29/ios-networkbase-http-and-https/","excerpt":"","text":"HTTPHTTP：Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型 RequestGETGET / HTTP/1.1Host: www.baidu.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8（这里是请求数据） 第一部分：第一行是请求行（request line） 第二部分：请求头（header），用来说明服务器要使用的附加信息 第三部分：空行，请求头后面的空行是必须的 第四部分：请求数据也叫主体，可以添加任意数据 POSTPOST / HTTP1.1Host: www.baidu.comUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行是post请求，以及http1.1版本。 第二部分：请求头部，第二行至第六行。 第三部分：空行，第七行的空行。 第四部分：请求数据，第八行。 GET和POST的区别 GET请求的数据会附在URL之后显示出来（数据放置在http协议头中）而POST把提交的数据放置在是HTTP包的包体中 传输数据的大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但GET请求时特定浏览器和服务器对URL长度有限制（eg:IE限制2083个字节,2k+35） 安全性：POST的安全性要比GET的安全性高（GET提交时，用户名密码会明文出现在URL上） ResponseHTTP/1.1 200 OKDate: Fri, 22 April 2018 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 Http状态码 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 网络通信三要素IP地址（主机名） 网络中设备的标示 本地回环地址：127.0.0.1 主机名：localhost 端口号 用于标示进程的逻辑地址，不同进程的标示 有效端口：0-65535 其中 0-1024由系统使用或者保留端口，开发中不要使用 1024 以下的端口 注意 : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.处理HTTPS请求的端口号是443. 传输协议 UDP(数据报文协议) 只管发送，不确认对方是否接收到 将数据源和目的封装成数据包中，不需要建立连接 每个数据报的大小限制在64K之内 因为无需连接，因此是不可靠协议 不需要建立连接，速度快 应用场景：多媒体教室／网络流媒体 / 视频实时共享 当视频共享时,出现卡屏,就是因为UDP协议在传递数据时出现丢包. TCP(传输控制协议) 建立连接，形成传输数据的通道 在连接中进行大数据传输（数据大小不受限制） 通过三次握手完成连接，是可靠协议 必须建立连接，效率会稍低 TCP协议的传输速度比UDP协议慢 三次握手的描述 图解： 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了 注： 通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据 TCP/IP网络参考模型网络模型（理论） 网络参考模型（现实） 通信过程 应用层 : APP 传输层 : TCP,确定数据如何传输 网络层 : 确定目标计算机的IP地址 链路层 : 硬件,添加帧头帧尾 HTTP网络传输协议在传输层选择的是TCP/IP协议 HTTPS HTTPS : Hyper Text Transfer Protocol over Secure Socket Layer,是以安全为目标的HTTP通道,简单讲是HTTP的安全版.即HTTP下加入SSL层,HTTPS的安全基础是SSL. SSL : Secure Sockets Layer,表示安全套接层. TLS : Transport Layer Security,是SSL的继任者,表示传输层安全. SSL与TLS是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密. HTTPS加密原理 加密科普（对称，非对称，散列 ）HTTPS一般使用的加密与HASH算法如下：非对称加密算法：RSA，DSA/DSS对称加密算法：AES，RC4，3DESHASH算法：MD5，SHA1，SHA256其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。 小结（面试时如何回答) HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。 HTTPS并不是一个单独的协议，是对工作在一个加密连接（SSL/TLS) 上的常规HTTP协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。 SSL/TLS协议加密会使传输速度会变慢，更耗资源，但是更安全 相关文章： https://www.cnblogs.com/Yfling/p/6670495.html http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Network","slug":"Network","permalink":"https://blog.alphabethub.com/tags/Network/"},{"name":"Http","slug":"Http","permalink":"https://blog.alphabethub.com/tags/Http/"},{"name":"Https","slug":"Https","permalink":"https://blog.alphabethub.com/tags/Https/"}]},{"title":"iOS - KVC 和 KVO 的使用和原理","slug":"ios-kvc-and-kvo","date":"2016-03-23T04:55:57.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/03/23/ios-kvc-and-kvo/","link":"","permalink":"https://blog.alphabethub.com/2016/03/23/ios-kvc-and-kvo/","excerpt":"","text":"KVCKVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。 简介KVC（Key-value coding），键值编码；是指在iOS开发中，可以允许开发者通过属性名Key直接访问对象的属性并给属性编码（赋值value），而不是调用对应的getter/setter方法。很多高级的iOS开发技巧都是基于KVC实现，例如修改系统控件内部属性；json-&gt;model的映射框架等。 KVC最重要的四个方法- (nullable id)valueForKey:(NSString * )key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString * )key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString * )keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString * )keyPath; //通过KeyPath来设值 valueForKey 和 valueForKeyPath区别先来看一段代码- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary * dict = @&#123;@\"key1\":@\"value1\", @\"second\":@&#123; @\"k1\":@\"v1\", @\"k2\":@\"v2\", @\"third\":@&#123; @\"t1\":@\"h1\", @\"t2\":@\"h2\" &#125; &#125; &#125;; NSDictionary * second = [dict valueForKey:@\"second\"]; NSDictionary * third1 = [second valueForKey:@\"third\"]; NSLog(@\"%@\",third1); NSDictionary * third2 = [dict valueForKeyPath:@\"second.third\"]; NSLog(@\"%@\",third2);&#125; 输出结果：2018-05-23 13:52:33.430617+0800 KVC-Demo[1584:403407] &#123; t1 = h1; t2 = h2;&#125;2018-05-23 13:52:33.430800+0800 KVC-Demo[1584:403407] &#123; t1 = h1; t2 = h2;&#125; 小结通过代码我们可以看出，我们想要从dict这个字典中获取到third这个key所对应的值得话,使用valueForKey需要通过一层一层的对象才能取到想要的字典，而使用valueForKeyPath则只需要输入third在字典中的路径（path）一次就可以取到third字典。 参考博客https://www.jianshu.com/p/c0e099f72a3bhttps://www.jianshu.com/p/a6a0abac1c4a KVC的使用代替getter/setter@interface Model : NSObject@property (copy, nonatomic) NSString * text;@property (copy, nonatomic) SubModel * subModel;@end@interface SubModel : Model@property (copy, nonatomic) NSString * subText;@end 不使用kvc//赋值Model *model = [[Model alloc]init];model.text = @\"text\";SubModel *subModel = [[SubModel alloc]init];subModel.subText = @\"subText\";model.subModel = subModel;//取值NSString *text = model.text;NSString *subText = model.subModel.subText; 使用kvc//赋值Model *model = [[Model alloc]init];[model setValue:@\"text\" forKey:@\"text\"];[model setValue:@\"subText\" forKeyPath:@\"subModel.subText\"];//取值NSString *text = [model valueForKey:@\"text\"];NSString *subText = [model valueForKeyPath:@\"subModel.subText\"]; 字典转模型（仿YYModel） 创建NSObject的扩展NSObject+Model@interface NSObject (Model)+ (instancetype) tb_modelWithDictionary:(NSDictionary * )dictionary;@end 实现SObject+Model利用Runtime取到对应类的属性列表，在使用kvc对所有属性进行赋值@implementation NSObject (Model)+ (NSArray * )getPropertyList:(Class)cls&#123; NSArray * array = objc_getAssociatedObject(self, `_cmd`); if (array != nil)&#123; return array; &#125; NSMutableArray * arrM = [NSMutableArray array]; //输出个数 unsigned int outCount; //获取属性列表（ objc_property_t * ） objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount); for (NSInteger i=0; i&lt;outCount; ++i) &#123; objc_property_t property = properties[i]; //属性名字 NSString * name = [NSString stringWithUTF8String:property_getName(property)]; [arrM addObject:name]; &#125; objc_setAssociatedObject(self, @selector(getPropertyList:), [arrM copy], OBJC_ASSOCIATION_RETAIN); free(properties); return [arrM copy];&#125;+ (instancetype)tb_modelWithDictionary:(NSDictionary * )dictionary&#123; NSObject * object = [[self alloc]init]; NSArray * array = [self getPropertyList:[self class]]; [dictionary enumerateKeysAndObjectsUsingBlock:^(NSString * key, id value, BOOL * stop) &#123; if ([array containsObject:key])&#123; [object setValue:value forKey:key]; &#125; &#125;]; return object;&#125;@end 使用tb_modelWithDictionary模仿YYModel的字典转模型方式- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary * dict = @&#123; @\"text\":@\"text\" &#125;; Model * model = [Model tb_modelWithDictionary:dict]; NSLog(@\"%@\",model);&#125; 修改系统控件内部属性（runtime+kvc） 需求：修改UIPageControl小圆点的背景图片 查看UIPageControl.h如下 NS_CLASS_AVAILABLE_IOS(2_0) @interface UIPageControl : UIControl@property(nonatomic) NSInteger numberOfPages; // default is 0@property(nonatomic) NSInteger currentPage; // default is 0. value pinned to 0..numberOfPages-1@property(nonatomic) BOOL hidesForSinglePage; // hide the the indicator if there is only one page. default is NO@property(nonatomic) BOOL defersCurrentPageDisplay; // if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO- (void)updateCurrentPageDisplay; // update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; // returns minimum size required to display dots for given page count. can be used to size control if page count could change@property(nullable, nonatomic,strong) UIColor * pageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property(nullable, nonatomic,strong) UIColor * currentPageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@end 没有发现UIPageControl暴露的操作中有设置小圆点背景图片的方法和属性，那么就可以利用runtime遍历UIPageControl类的成员变量（ivar）和属性（property） 利用runtime遍历UIPageControl成员变量 导入头文件： #import &lt;objc/runtime.h&gt; 遍历成员变量： - (void)viewDidLoad &#123; [super viewDidLoad]; UIPageControl * pc = [[UIPageControl alloc]init]; NSArray * array = [self getIvarList:[pc class]]; NSLog(@\"%@\",array);&#125;- (NSArray * )getIvarList:(Class)cls&#123; NSMutableArray * arrM = [NSMutableArray array]; unsigned int outCount; Ivar * ivars = class_copyIvarList(cls, &amp;outCount); for (NSInteger i=0; i&lt;outCount; ++i) &#123; Ivar ivar = ivars[i]; NSString * name = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSString * type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; NSString * str = [name stringByAppendingFormat:@\" -- %@\",type]; [arrM addObject:str]; &#125; free(ivars); return [arrM copy];&#125; 输出结果： 2018-05-23 16:45:18.380346+0800 KVC-Demo[4400:856521] ( \"_lastUserInterfaceIdiom -- q\", \"_indicators -- @\\\"NSMutableArray\\\"\", \"_currentPage -- q\", \"_displayedPage -- q\", \"_pageControlFlags -- &#123;?=\\\"hideForSinglePage\\\"b1\\\"defersCurrentPageDisplay\\\"b1&#125;\", \"_currentPageImage -- @\\\"UIImage\\\"\", \"_pageImage -- @\\\"UIImage\\\"\", \"_currentPageImages -- @\\\"NSMutableArray\\\"\", \"_pageImages -- @\\\"NSMutableArray\\\"\", \"_backgroundVisualEffectView -- @\\\"UIVisualEffectView\\\"\", \"_currentPageIndicatorTintColor -- @\\\"UIColor\\\"\", \"_pageIndicatorTintColor -- @\\\"UIColor\\\"\", \"_legibilitySettings -- @\\\"_UILegibilitySettings\\\"\", \"_numberOfPages -- q\") 利用kvc设置_currentPageImage和_pageImage UIPageControl *pc = [[UIPageControl alloc]init];[pc setValue:[UIImage imageNamed:@\"pageImage\"] forKeyPath:@\"_pageImage\"];[pc setValue:[UIImage imageNamed:@\"currentPageImage\"] forKeyPath:@\"_currentPageImage\"]; XIB/Storyboard在xib/Storyboard中，也可以使用KVC，例如下面是在xib中使用KVC把图片边框设置成圆角。 KVOKVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。 简介KVO 是 Objective-C 对观察者设计模式的一种实现；[另外一种是：通知机制（notification）]。 使用（Swift）需求：UIScrollView内包含一部分原生控件和UIWebView的组合;这种情况下UIWebView的高度无法得知，因为UIWebView写完中包含UIScrollerView，所以需要利用KVO技术监听UIWebView中UIScrollerView的contentSize的变化以达到需求的目的。 addOberver 一般在viewDidLoad中添加监听if let scrollView = mWebView.subviews.first as? UIScrollView &#123; scrollView.alwaysBounceVertical = false scrollView.alwaysBounceHorizontal = false scrollView.bounces = false scrollView.addObserver(self, forKeyPath: \"contentSize\", options: .new, context: nil) &#125; observerValueForkeyPath 当contentSize发生变化时,会回调到observerValueForkeyPath这个方法override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if keyPath == \"contentSize\" &amp;&amp; change != nil &#123; let value = (change![NSKeyValueChangeKey.newKey] as! NSValue).cgSizeValue.height desViewHeightCons.constant = value &#125; &#125; removeObserver 当界面销毁时，移除监听deinit &#123; if let scrollView = mWebView?.subviews.first as? UIScrollView &#123; scrollView.removeObserver(self, forKeyPath: \"contentSize\") &#125; &#125; KVO的原理键值编码(KVC)和键值观察（KVO）是根据isa-swizzling技术来实现的，主要依据runtime的强大动态能力。当某个类第一次被观察时，系统会在运行时期动态的创建一个该类的派生类，在这个派生类中重写任何被观察属性的setter方法。派生类在被重写的setter方法实现真正的通知机制，这么设计是基于设置属性会调用setter方法，而通过重写就获得了KVO需要的通知机制，当然前提是要遵循KVO的属性设置方式来变更属性值，如果直接修改属性对应的成员变量是无法实现KVO的。同时派生类还重写了class方法欺骗外部调用者它就是起初的那个类，然后系统将isa指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因为在该对象上对setter的调用就会调用的重写的setter，从而激活键值通知机制。此外派生类还重写了delloc方法来释放资源。 在Runtime篇章中介绍过，isa指针其实指向的是类的元类，如果添加监听之前的类名为Person,那么添加监听之后被runtime更改以后的类名会变成：NSKVONotifying_Person 新的派生类NSKVONotifying_Person会重写以下方法：增加了监听的属性对应的setter,class,delloc,_isKVOA class重写class方法是为了方便我们调用它的时候，返回跟重写继承类之前同样的内容。 Person *person = [[Person alloc]init];NSLog(@\"before isa:%@ class:%@\",object_getClass(person), [person class]);[person addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:nil];NSLog(@\"end isa:%@ class:%@\",object_getClass(person), [person class]);_person = person; 输出结果： 2018-05-23 19:55:23.430908+0800 KVO-Demo[6395:1312349] before isa:Person class:Person2018-05-23 19:55:23.431456+0800 KVO-Demo[6395:1312349] end isa:NSKVONotifying_Person class:Person 这也是isa指针和class方法的一个区别，使用的时候要特别注意。 setter新的派生类会重写对应的setter方法，其实是为了在setter中增加另外两个方法的调用 - (void)willChangeValueForKey:(NSString * )key - (void)didChangeValueForKey:(NSString * )key 其中 didChangeValueForKey负责触发：observeValueForKeyPath:keyPath :object :change :context方法，这就是kvo的原理。如果没有执行setter之类的调用，那么使用setValue:forKey方法也会直接调用observeValueForKeyPath:keyPath :object :change :context方法再如果既没有调用setter也没有调用setValue:forKey，那么 - (void)willChangeValueForKey:(NSString * )key - (void)didChangeValueForKey:(NSString * )key 我们只需要显示调用上述两个方法，就会触发observeValueForKeyPath:keyPath :object :change :context方法，同样可以使用KVO。 _isKVOA这个私有方法是用来表示该类是一个KVO机制声明的类 小结（触发KVO的三种方法） 使用KVC （运行时会在setValue:forKey中来调用will/didChangeValueForKey:） 使用setter方法（运行时会在setter方法中调用will/didChangeValueForKey:） 显示调用will/didChangeValueForKey:方法 如何更优雅的使用KVO只需要使用 Facebook 开源的 KVOController 框架就可以优雅地解决这些问题了。 [self.KVOController observe:person keyPath:@\"age\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld block:^(id observer, id object, NSDictionary&lt;NSString * , id&gt; * change) &#123; NSLog(@\"%@\", change); &#125;]; 我们可以在任意对象上获得 KVOController 对象，然后调用它的实例方法 -observer:keyPath:options:block: 就可以检测某个对象对应的属性了，该方法传入的参数非常容易理解，在 block 中也可以获得所有与 KVO 有关的参数。 使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题: 不需要手动移除观察者；实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath； 参考文档和博客http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1https://blog.csdn.net/wzzvictory/article/details/9674431https://blog.csdn.net/kesalin/article/details/8194240https://draveness.me/kvocontroller","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"},{"name":"KVC","slug":"KVC","permalink":"https://blog.alphabethub.com/tags/KVC/"},{"name":"KVO","slug":"KVO","permalink":"https://blog.alphabethub.com/tags/KVO/"}]},{"title":"iOS - 零散的小知识点收集","slug":"ios-scatter-point-collect","date":"2016-03-18T02:20:16.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/03/18/ios-scatter-point-collect/","link":"","permalink":"https://blog.alphabethub.com/2016/03/18/ios-scatter-point-collect/","excerpt":"","text":"APP启动程序执行过程main函数执行UIApplicationMain函数 创建UIApplication对象 创建UIApplicationDelegate对象并复制 读取配置文件info.plist，设置程序启动的一些属性 创建应用程序的Main Runloop循环 UIApplicationDelegate对象开始处理监听到的事件1.程序启动成功之后，首先调用application:didFinishLaunchingWithOptions:方法，如果info.plist文件中配置了启动storyboard文件名，则加载storyboard文件。如果没有配置，则根据代码来创建UIWindow—&gt;UIWindow的rootViewController–&gt;显示 类方法initialize 会在类第一次被使用时调用，且只会调用一次 此方法的调用是线程安全的 loadView的注意事项 用于加载指定的视图，一旦重写了这个方法，Storyboard里面就不会去加载根视图了 先于viewDidLoad调用 不可以调用super.loadView() 当self.view == nil时回调用此方法 ViewController的生命周期 loadView：用于加载制定的根试图 viewDidLoad：试图加载完毕 viewWillAppear：界面即将显示在屏幕上 viewDidAppear：界面已经完全渲染在屏幕上 viewWillDisappear：界面即将从屏幕上消失 viewDidDisappear：界面已经完全消失 dealloc：控制器销毁 stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说） +stringWithFormat:类方法，返回一个autorelease的NSString实例，不用手动release，在自动释放池中会自动释放。 -initWithFormat:实例方法，返回一个自己alloc申请内存的NSString实例，根据OC内存管理黄金法则，管杀管埋，它则需要自己手动release。 小结：这两个方法只是在没有使用ARC的时候有所不同，一个需要手动release一个则是自动进入autoreleasepool，所以在使用ARC的时候他们俩几乎没有什么区别。 @synthesize是啥？什么情况下使用？ 首先一旦重写来属性的setter和getter方法后,系统不再自动生成带下划线的成员变量,而这行代码会创造一个带下划线前缀的实例变量名,同时使用这个属性生成getter 和 setter 方法。 使用@synthesize 只有一个目的——给实例变量起个别名,或者说为同一个变量添加两个名字。 如果要阻止自动合成，记得使用 @dynamic 。经典的使用场景是你知道已经在某处实现了getter/setter 方法,而编译器不知道的情况。 如何使用：@synthesize obj = _obj; 栈区/堆区/常量区 操作内存的栈区速度快;栈区存储空间地址是连续的 操作内存的常量区速度快;内存空间只开辟一次 操作内存的堆区速度相对栈区和常量区要慢些;堆区内存空间不连续,需要寻址的过程// 存储在栈区 int num = 10;// 存储在常量区 NSString *str1 = @\"hello\";// 存储在堆区 NSString *str2 = [NSString stringWithFormat:@\"hello_%d\",i]; NSUInteger和NSInteger的区别 NSUInteger 无符号整数(没有负数)用 %tu%tuNSUInteger的占位符，可以适配 NSUInteger的32位设备和64位设备32位设备: NSUInteger是无符号的int (无符号表示没有正负数)64位设备: NSUInteger是无符号的long NSInteger有符号整数(有正负数)用 %zd%zdNSInteger的占位符，可以适配 NSInteger的32位设备和64位设备32位设备: NSInteger是有符号的int (有符号表示有正负数)64位设备: NSInteger是有符号的long 以上这种设计是为了自适应32位和64位CPU的架构.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Objc","slug":"Objc","permalink":"https://blog.alphabethub.com/tags/Objc/"}]},{"title":"iOS - UIWebView & JSContext & WKWebView","slug":"ios-uiwebview-and-jscontext-and-wkwebview","date":"2016-03-08T09:33:53.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/03/08/ios-uiwebview-and-jscontext-and-wkwebview/","link":"","permalink":"https://blog.alphabethub.com/2016/03/08/ios-uiwebview-and-jscontext-and-wkwebview/","excerpt":"","text":"UIWebView A view that embeds web content in your app. UIWebView 的JS注入 案例 : 移除网页的某些不需要展示的标签 准备网页地址 : http://m.dianping.com/tuan/deal/5501525 浏览器终端中演示JS代码删除网页中元素 需要处理的网页 网页处理的步骤以删除导航为例 : 1.先找到该节点 : var headerTag = document.getElementsByTagName('header')[0]; 2.再找到父节点 : headerTag.parentNode 3.最后用它的父节点删除该节点 : headerTag.parentNode.removeChild(headerTag); 合并: var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag); 删除导航var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag); 删除底部悬停按钮var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag); 删除底部布局var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag); 处理之后的网页 OC调用JS 实现 JS注入 OC和JS的交互需要使用UIWebView的代理方法作为桥梁实现 - (void)viewDidLoad &#123; [super viewDidLoad]; NSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]; [self.webView loadRequest:[NSURLRequest requestWithURL:URL]]; // 设置代理 self.webView.delegate = self;&#125; 网页加载完时调用的代理方法- (void)webViewDidFinishLoad:(UIWebView * ) webView; 网页加载完成之后,调用JS代码的OC方法- (nullable NSString * )stringByEvaluatingJavaScriptFromString:(NSString * )script; JS注入的具体实现- (void)webViewDidFinishLoad:(UIWebView * )webView&#123; // 拼接JS的代码 NSMutableString * JSStringM = [NSMutableString string]; // 删除导航 [JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"]; // 删除底部悬停按钮 [JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"]; // 删除底部布局 [JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"]; // OC调用JS代码 [webView stringByEvaluatingJavaScriptFromString:JSStringM];&#125; UIWebView监听网页标签的点击(JS调用OC) 案例 : 点击网页某个标签跳转到苹果原生控制器核心思想 : 拦截webView上所有的网络请求 JS调用OC需要实现的代理方法-(BOOL) webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType; JS注入给标签添加点击事件 网页标签添加点击事件 [JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"]; 标签的点击事件注入到JS - (void)webViewDidFinishLoad:(UIWebView * )webView&#123; // 拼接JS的代码 NSMutableString * JSStringM = [NSMutableString string]; // 删除导航 [JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"]; // 删除底部悬停按钮 [JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"]; // 删除底部布局 [JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"]; // 给标签添加点击事件 [JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"]; // OC调用JS代码 [webView stringByEvaluatingJavaScriptFromString:JSStringM];&#125; 给标签添加点击事件的目的 : 使标签可点击 点击事件发送网络请求的目的 : 可以拦截到标签的点击事件 自定义协议的目的 : 给事件设计一个特殊的标记,如果拦截到请求,就通过特殊的标记来区别要做的事情 拦截webView上所有的网络请求,筛选请求/** 1.JS与OC交互的桥梁 2.可以拦截webView上所有的请求 3.给标签添加点击事件,点击事件主要就是发送请求;发送的请求是自定义协议的,目的是为了做标记. */- (BOOL)webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType&#123; NSLog(@\"%@\",request.URL.absoluteString); // 拿到网页的请求地址 NSString * URLString = request.URL.absoluteString; // 判断网页的请求地址协议是否是我们自定义的那个 NSRange range = [URLString rangeOfString:@\"custom://techbird.me\"]; if (range.length &gt; 0) &#123; // 点击网页中的图片,实现OC原生界面的跳转 TestViewController * VC = [[TestViewController alloc] init]; [self.navigationController pushViewController:VC animated:YES]; return NO; &#125; return YES;&#125; JSContextJSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口 JSContexts实现OC与JS交互 获取上下文JSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; 使用JSContext 实现 JS调用OC- (void)viewDidLoad &#123; [super viewDidLoad]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]]; [self.webView loadRequest:request]; self.webView.delegate = self; // 获取上下文 JSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 监听图片标签点击 context[@\"imgtag\"] = ^ &#123; [self.navigationController pushViewController:[TestViewController new] animated:YES]; &#125;; // 监听购买标签点击 context[@\"buytag\"] = ^ &#123; [self.navigationController pushViewController:[Test1ViewController new] animated:YES]; &#125;;&#125; 使用JSContext 实现 JS注入- (void)webViewDidFinishLoad:(UIWebView * )webView&#123; // 拿到JS的上下文 JSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]; // 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message // 拼接JS的代码 NSMutableString * JSStringM = [NSMutableString string]; // 删除导航 [JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"]; // 删除底部悬停按钮 [JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"]; // 删除底部布局 [JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"]; // 给图片标签添加点击事件 : 自定义协议 [JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function imgtagclick() &#123;imgtag();&#125;;\"]; // 给以过期的购买标签重新添加点击事件 [JSStringM appendString:@\"var buyBtnTag = document.getElementsByClassName('buy-btn btn-gray')[0]; buyBtnTag.onclick = function buybtnclick() &#123;buytag();&#125;;\"]; // 执行这个JS代码 [context evaluateScript:JSStringM];&#125; WKWebView Starting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView. WKWebView的OC和JS交互 使用前导入头文件 #import &lt;WebKit/WebKit.h&gt; 遵守代理协议 webView.navigationDelegate = self; 代理方法介绍 面即将开始加载时调用 (拦截网页的网络请求 : JS调用OC)- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler; 页面开始加载时调用- (void)webView:(WKWebView * )webView didStartProvisionalNavigation:(WKNavigation * )navigation; 收到响应后,决定是否跳转,即是否把这个链接对应的网页加载到WKWebView上- (void)webView:(WKWebView * )webView decidePolicyForNavigationResponse:(WKNavigationResponse * )navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler; 当内容开始返回时调用,即服务器已经在向客户端发送网页数据- (void)webView:(WKWebView * )webView didCommitNavigation:(WKNavigation * )navigation; 页面加载完成之后调用 (OC调用JS : JS注入)- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation; 页面加载失败时调用- (void)webView:(WKWebView * )webView didFailProvisionalNavigation:(WKNavigation * )navigation; 准备WKWebView- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建WKWebView WKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubview:webView]; webView.backgroundColor = [UIColor redColor]; self.webView = webView; // 设置代理 self.webView.navigationDelegate = self; // 加载的网页 NSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]; NSURLRequest * request = [NSURLRequest requestWithURL:URL]; [self.webView loadRequest:request];&#125; OC调用JS : JS注入 (类似UIWebView)// 页面加载完成之后调用- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation&#123; // 拼接JS的代码 NSMutableString * JSStringM = [NSMutableString string]; // 删除导航 [JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"]; // 删除底部悬停按钮 [JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"]; // 删除底部布局 [JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"]; // 给标签添加点击事件 : 自定义协议 [JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"]; // OC调用JS代码 [webView evaluateJavaScript:JSStringM completionHandler:nil];&#125; JS调用OC : (类似UIWebView)// 在发送请求之前，决定是否跳转- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSLog(@\"在发送请求之前，决定是否跳转 decidePolicyForNavigationAction\"); NSString * URLString = navigationAction.request.URL.absoluteString; NSLog(@\"监测到的WKWebView上的请求 %@\",URLString); NSRange range = [URLString rangeOfString:@\"custom://\"]; if (range.length &gt; 0) &#123; [self.navigationController pushViewController:[[TestViewController alloc] init] animated:YES]; // 不允许跳转,即不加载这个链接对应的内容 decisionHandler(WKNavigationActionPolicyCancel); &#125; else &#123; // 允许跳转,即加载这个链接对应的内容 decisionHandler(WKNavigationActionPolicyAllow); &#125;&#125; WKWebView 监听加载进度初始化WKWebView和进度条- (void)viewDidLoad &#123; [super viewDidLoad]; // 创建进度条 self.progress = [[UIProgressView alloc] init]; self.progress.frame = CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, 10); [self.view addSubview:self.progress]; self.progress.progress = 0; // 创建WKWebView WKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.view addSubview:webView]; webView.backgroundColor = [UIColor redColor]; self.webView = webView; // 设置代理 self.webView.navigationDelegate = self; // 加载的网页 NSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]; NSURLRequest * request = [NSURLRequest requestWithURL:URL]; [self.webView loadRequest:request]; // KVO添加进度监听 [webView addObserver:self forKeyPath:@\"estimatedProgress\" options:NSKeyValueObservingOptionNew context:nil];&#125; KVO监听进度- (void)observeValueForKeyPath:(NSString * )keyPath ofObject:(id)object change:(NSDictionary * )change context:(void * )context &#123; if (object == self.webView &amp;&amp; [keyPath isEqualToString:@\"estimatedProgress\"]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; NSLog(@\"进度 %f\",newprogress); if (newprogress != 1.000000) &#123; // 网页加载时就展示进度 self.progress.hidden = NO; self.progress.progress = newprogress; &#125; else &#123; // 网页加载完成就进度 self.progress.hidden = YES; &#125; &#125;&#125; WKWebView 其他WKUIDelegate 创建一个新的WebView-(WKWebView * )webView:(WKWebView * )webView createWebViewWithConfiguration:(WKWebViewConfiguration * )configuration forNavigationAction:(WKNavigationAction * )navigationAction windowFeatures:(WKWindowFeatures * )windowFeatures; 弹出警告的提示框时调用/** * 弹出警告的提示框时调用 * * @param webView 实现该代理的webview * @param message 警告框中的内容 * @param frame 主窗口 * @param completionHandler 警告框消失调用 */-(void)webView:(WKWebView * )webView runJavaScriptAlertPanelWithMessage:(NSString * )message initiatedByFrame:(void (^)())completionHandler; 弹出确认的提示框时调用/** * 弹出确认的提示框时调用 * * @param webView 实现该代理的webview * @param message 确认框中的内容 * @param frame 主窗口 * @param completionHandler 警告框消失调用 */-(void)webView:(WKWebView * )webView runJavaScriptConfirmPanelWithMessage:(NSString * )message initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(BOOL result))completionHandler; 弹出输入提示框时调用/** * 弹出输入提示框时调用 * * @param webView 实现该代理的webview * @param message 确认框中的内容 * @param defaultText 默认的输入框文本信息 * @param frame 主窗口 * @param completionHandler 警告框消失调用 */-(void)webView:(WKWebView * )webView runJavaScriptTextInputPanelWithPrompt:(NSString * )prompt defaultText:(nullable NSString * )defaultText initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(NSString * __nullable result))completionHandler; Bug Tipshttps://github.com/ShingoFukuyama/WKWebViewTips","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"Network","slug":"Network","permalink":"https://blog.alphabethub.com/tags/Network/"},{"name":"WebView","slug":"WebView","permalink":"https://blog.alphabethub.com/tags/WebView/"}]},{"title":"strong、weak、copy、retain和assign的区别","slug":"ios-keywors-of-strong-weak-copy-retain-assign","date":"2016-02-18T06:12:00.000Z","updated":"2021-04-29T11:14:31.995Z","comments":true,"path":"2016/02/18/ios-keywors-of-strong-weak-copy-retain-assign/","link":"","permalink":"https://blog.alphabethub.com/2016/02/18/ios-keywors-of-strong-weak-copy-retain-assign/","excerpt":"","text":"assign：assign一般用来修饰基本的数据类型，包括基础数据类型（NSInteger,CGFloat）和C语言数据类型（int,float,double,char）等等。因为assign声明的属性，是不会增加引用计数的，也就是说声明的属性释放后也就没有了，及时其他对象引用了它也不会保留，只会造成crash。但是及时被释放，指针却还在，成为了野指针，如果新的对象被分配到了这个内存地址上，又会造成crash。所以一般只用来声明基本的数据类型，因为它们会被分配到栈区上，而栈取由系统自动管理，不会造成野指针。 retain：与assign相对，我们要解决对象被其他对象引用后释放造成的问题，就需要用retain来声明。使用retain声明的对象会更改引用计数，每次被引用，引用计数都会+1，释放后就会-1。即使这个对象本身被释放了，只要还有对象在引用它，该对象就会仍然持有，不会出现任何问题。并且只有当引用计数为0时，就会被dealloc析构函数回收进内存。 copy：最常见到的copy的声明使用是 NSString 等。copy与retain的区别在于：retain是拷贝内存指针地址，而copy是拷贝对象本身；也就是说retain是浅复制，copy是深复制；如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在NSString这一类有可变类型对象的身上使用copy关键字，是因为他们有可能和对应的可变类型如 NSMutableString 之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了 NSCopying 协议的对象类型有效。 weak：weak是由ARC新引入的对象变量属性，weak类似于assign，叫弱引用，也是不增加引用计数，不同在于week指向对象类型时，当对象被释放会指向nil，而assign则会造成野指针。一般只有在防止循环引用时候使用；比如父类引用了子类，子类又引用父类；IBOutlet、Delegate等一般就是使用week，这是因为他们可能会在类外部被调用，防止循环应用。 strong：strong也是由ARC新引入的对象变量属性，在ARC下,用strong代替了retain，叫强引用，会增加引用计数。，所有的局部变量代码中我们声明的变量默认都是强引用，不需要再额外使用__strong来修饰。 什么时候用stong/weak 根视图和父视图需要使用strong; 子视图使用weak 没有强指针指向的对象使用strong; 有强指针指向的可以可以weak __strong,__weak,__unsafe_unretained,__autoreleasing 的含义在ARC情况下，对象类型的变量将有所有权修饰符__strong: 是缺省的关键词。__weak: 声明了一个可以自动nil化的引用。__unsafe_unretained: 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。__autoreleasing: 用来修饰一个函数的参数，这个参数在函数返回的时候会被自动释放。 ARC声明属性时，对于基本数据类型默认关键字是 （atomic,readwrite,assign）ARC声明属性时，对于普通的OC对象默认关键字是 （atomic,readwrite,strong） 示例@property (nonatomic) int supportOrientation; 默认是assign，因为是基础数据类型，必须是assign@property (readonly) UIImage* rightImage; 默认是atomic@property (nonatomic) bolo_BasePlayerControlView* ctrlView; 默认是strong@property (nonatomic, weak) id&lt;WatchVideoDetailDelegate&gt; delegate; 代理使用weak 扩展：LLVM官网给出的一些示意，ARC里也可以使用retain等关键字 assign implies __unsafe_unretained ownership.copy implies __strong ownership, as well as the usual behavior of copy semantics on the setter.retain implies __strong ownership.strong implies __strong ownership.unsafe_unretained implies __unsafe_unretained ownership.weak implies __weak ownership. assign 等同于unsafe_retainedcopy的作用和MRC一样，同时又有strong的效果retain等同于strongweak和unsafe_unretained的区别在于：weak降被释放指针赋值为nil，而unsafe_unretained则会成为野指针","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/categories/iOS/"},{"name":"Objc","slug":"iOS/Objc","permalink":"https://blog.alphabethub.com/categories/iOS/Objc/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://blog.alphabethub.com/tags/iOS/"},{"name":"keywords","slug":"keywords","permalink":"https://blog.alphabethub.com/tags/keywords/"}]},{"title":"朋友，去远方吗？","slug":"daily-2016-0212","date":"2016-02-12T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2016/02/12/daily-2016-0212/","link":"","permalink":"https://blog.alphabethub.com/2016/02/12/daily-2016-0212/","excerpt":"","text":"朋友，去远方吗？ 七不出门，八不回家。 窗外的夜沉沉的，浓浓的雾色笼罩着远处偶尔的几声车鸣和人声，初春的雨夹杂着夜晚的微寒透过窗户淅淅沥沥的渗进来，就到了正月初六，这相聚离别时，年年岁岁花相似，岁岁年年人不同，回头一看，好像故乡从此只有冬天、父母、老友。 我想，有些时候，人受不了的恐怕不是离别，更多是怕那种分别的气氛和感伤的情绪，怕那种形式和那种形式所包含的内容。但天下没有不散的宴席，分离是人生很正常的事，还好我们都是为了各自的理想和事业。我们都曾在人生的海洋中相遇，岁月飘忽，必然会改变许多东西。时间会使许多绚烂归于平淡，我只是难以释怀为什么总是如此匆忙？ 我渐习惯离家，喜欢漂泊，常将远方挂于心上。但每当此时，总想来叙叙旧事，把酒杯满上，诉些许思念。朋友，去远方吗？我去远方 2016/02/12 长治","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"租房二三事","slug":"daily-2016-0203","date":"2016-02-03T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2016/02/03/daily-2016-0203/","link":"","permalink":"https://blog.alphabethub.com/2016/02/03/daily-2016-0203/","excerpt":"","text":"租房二三事 人在江湖，就得挨刀。 想抒发一下心里的不快，来北京第三个年头了，还没有因为租房的事情被坑过，风水轮流转，今日轮到我。 房东地主，4500块押金不退。理论了半天，还是没什么结果。当初说好提前30天打招呼就会退房租，到了谈钱的时候，就都变了。 上学的时候，家长老师总会往你的脑海里传输社会上的种种人心善恶美丑，是非黑白。但是却没有告诉，当你面对这些嘴脸的时候，应该如何正确面对和处理。难以想象，我会被这个世界改造成什么样子，现在的自己能不能认识十年后的样子，会不会喜欢，会不会失望？ 我想，在我没有资本的时候别人怎么对我，如果有一天我有幸通过自己的努力获得，我也一定不会对我经历的人和事而怀恨在心，施予他人。钱对我来说，很重要，但不会超过人格，不会泯灭人性和善良。 如果这种坚持能让身边的人多一点点改变，能让自己多一点点韧性，我希望我能一直保持一颗善良的心，不偏不倚，还是满怀希望。 我还年轻，我不愿成为我讨厌的那种人，就是这样！ 2016/02/03 长治","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"昨日旧梦，常记于心","slug":"daily-2015-1204","date":"2015-12-04T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2015/12/04/daily-2015-1204/","link":"","permalink":"https://blog.alphabethub.com/2015/12/04/daily-2015-1204/","excerpt":"","text":"昨日旧梦，常记于心 草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好！——顾城。 昨夜做了很久的梦，梦里与老友做着多年前没有完成的事，最近常常怀念好久以前的同学朋友，对一些过去发生的事情，清晰到像在昨日发生之事，时光匆匆，带走单纯的日子，迎来朝九晚五的生活，我们竭力嘶喊，喉咙都哑了，却还是什么都抓不住。 我不喜欢怀念，我把自己搞成很忙很忙的样子，怀念让人忧伤，怀念让人觉得现在不如从前，怀念让人做出不理智的事情。 我以前住在村里的时候，梦想着考去城里读书，后来全家搬到小城，我便在那里上学，读书，度过了我人生最单纯快乐的十年，虽说伴有偶尔的无病呻吟，矫揉造作以及对人生的种种期许和感慨，但那十年是认真活着，有爱，有理想， 就是有些不接地气。那个十年是我几年前想离开的十年，那个十年是我现在真真切切怀念的十年，而这样就变成了现在过着以前渴望的生活状态，而以前却成了现在的梦想，电影《后悔无期》里的最后一句话说：告别的时候一定要用力一点，多说一句，说不定就成了最后一句，多看一眼，弄不好就是最后一眼。可我还没来得及道一声再见，就再也不见。 我怀念的远方老友，我甚是想念，想的胸中顿涩，想的泪眼婆娑，何时再见，我们推杯换盏，一诉经年。 朴树的歌声里唱到，我曾经跨过山和大海，也穿过人山人海，我曾经拥有这一切，转眼都飘散如烟，我们都平凡，或许你已记不得走了多远的路，但你记得自己经历的人和事，这些东西会在你心头扎根，生长，直至参天。 外面的世界很精彩，外面的世界很无奈。当你觉得外面的世界很精彩，我会在这里衷心的祝福你！ 2015/12/04 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"记天津塘沽爆炸","slug":"daily-2015-0820","date":"2015-08-20T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2015/08/20/daily-2015-0820/","link":"","permalink":"https://blog.alphabethub.com/2015/08/20/daily-2015-0820/","excerpt":"","text":"记天津塘沽爆炸天津塘沽爆炸，到现在没去问责失职的政府部门和官员，却立即开启了感动中国模式，舆论导向几乎全部转向牺牲的消防战士身上，消防战士固然是伟大的值得我们敬仰的，可是新闻媒体作为政府的喉舌，故意去转移社会的舆论导向，目的是让人民生活在感动之中，让人们忘却去问责那些应该承担这起事故责任的政府部门和官员，让年轻的消防战士去送死的指挥部门，让人们失去最后的一点愤怒，政府如果这么愚弄人民，最终只会失去民心。 2015/8/20 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"工体东路的日子","slug":"daily-2015-0702","date":"2015-07-02T02:01:47.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2015/07/02/daily-2015-0702/","link":"","permalink":"https://blog.alphabethub.com/2015/07/02/daily-2015-0702/","excerpt":"","text":"工体东路的日子我会在夏日一小时的午休后，从空军干休所的小院走至大门外的林荫道，林荫道旁有一排黑色的围栏，大概一米多高，我会坐在围栏上惬意的抽根烟，身后是三里屯的酒吧街，这感觉像是我大学时光的篮球场，球场旁边也有遮天的林荫道，和小伙伴打球累了以后，就会坐在林荫道旁看过往裙摆，坐到不想坐，坐到天蒙蒙黑，起来拍拍屁股上的灰尘，搭着肩膀，谈论着谁家女孩儿，去爱吃的二号食堂。 2015/07/02 北京","categories":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/categories/Daily/"}],"tags":[{"name":"Daily","slug":"Daily","permalink":"https://blog.alphabethub.com/tags/Daily/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-04-21T09:29:30.000Z","updated":"2021-04-29T11:14:31.991Z","comments":true,"path":"2014/04/21/hello-world/","link":"","permalink":"https://blog.alphabethub.com/2014/04/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}