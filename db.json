{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/BLOG-QR.png","path":"images/BLOG-QR.png","modified":1,"renderable":0},{"_id":"source/images/code_snippet_dialog.png","path":"images/code_snippet_dialog.png","modified":1,"renderable":0},{"_id":"source/images/code_snippets.png","path":"images/code_snippets.png","modified":1,"renderable":0},{"_id":"source/images/compile_last_one.png","path":"images/compile_last_one.png","modified":1,"renderable":0},{"_id":"source/images/compile_last_two.png","path":"images/compile_last_two.png","modified":1,"renderable":0},{"_id":"source/images/csr_alert.png","path":"images/csr_alert.png","modified":1,"renderable":0},{"_id":"source/images/kvc_layer_cornerradius.png","path":"images/kvc_layer_cornerradius.png","modified":1,"renderable":0},{"_id":"source/images/network_http_commute.png","path":"images/network_http_commute.png","modified":1,"renderable":0},{"_id":"source/images/nsopration_queue_maxium.png","path":"images/nsopration_queue_maxium.png","modified":1,"renderable":0},{"_id":"source/images/objc_runloop.jpg","path":"images/objc_runloop.jpg","modified":1,"renderable":0},{"_id":"source/images/objc_runloop_mode.png","path":"images/objc_runloop_mode.png","modified":1,"renderable":0},{"_id":"source/images/cer_profile_list.png","path":"images/cer_profile_list.png","modified":1,"renderable":0},{"_id":"source/images/cer_create.png","path":"images/cer_create.png","modified":1,"renderable":0},{"_id":"source/images/controller_life_circle.png","path":"images/controller_life_circle.png","modified":1,"renderable":0},{"_id":"source/images/csr_keychain.png","path":"images/csr_keychain.png","modified":1,"renderable":0},{"_id":"source/images/network_commute_progress.png","path":"images/network_commute_progress.png","modified":1,"renderable":0},{"_id":"source/images/network_three_time_hand.png","path":"images/network_three_time_hand.png","modified":1,"renderable":0},{"_id":"source/images/objc_class_relationship.png","path":"images/objc_class_relationship.png","modified":1,"renderable":0},{"_id":"source/images/webpage_process_after.png","path":"images/webpage_process_after.png","modified":1,"renderable":0},{"_id":"source/images/webpage_process_before.png","path":"images/webpage_process_before.png","modified":1,"renderable":0},{"_id":"source/images/318/1255460395.jpg","path":"images/318/1255460395.jpg","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0197.JPG","path":"images/318/IMG_0197.JPG","modified":1,"renderable":0},{"_id":"source/images/daily/2233356333.jpeg","path":"images/daily/2233356333.jpeg","modified":1,"renderable":0},{"_id":"source/images/daily/3122621194.jpeg","path":"images/daily/3122621194.jpeg","modified":1,"renderable":0},{"_id":"source/images/daily/2069527412.jpeg","path":"images/daily/2069527412.jpeg","modified":1,"renderable":0},{"_id":"source/images/daily/2884524888.jpg","path":"images/daily/2884524888.jpg","modified":1,"renderable":0},{"_id":"source/images/csr_create.png","path":"images/csr_create.png","modified":1,"renderable":0},{"_id":"source/images/network_encode_principle.png","path":"images/network_encode_principle.png","modified":1,"renderable":0},{"_id":"source/images/daily/954377808.jpg","path":"images/daily/954377808.jpg","modified":1,"renderable":0},{"_id":"source/images/objc_autoreleasepool.png","path":"images/objc_autoreleasepool.png","modified":1,"renderable":0},{"_id":"source/images/network_theory_model.png","path":"images/network_theory_model.png","modified":1,"renderable":0},{"_id":"source/images/read/read_trjzdlxz.jpg","path":"images/read/read_trjzdlxz.jpg","modified":1,"renderable":0},{"_id":"source/images/read/read_kj.jpg","path":"images/read/read_kj.jpg","modified":1,"renderable":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.png","path":"img/jacman.png","modified":1,"renderable":1},{"_id":"source/images/cer_export_p12.png","path":"images/cer_export_p12.png","modified":1,"renderable":0},{"_id":"source/images/daily/1590392806.jpg","path":"images/daily/1590392806.jpg","modified":1,"renderable":0},{"_id":"source/images/gcd_and_nop_relationship.png","path":"images/gcd_and_nop_relationship.png","modified":1,"renderable":0},{"_id":"source/images/network_class_struct.png","path":"images/network_class_struct.png","modified":1,"renderable":0},{"_id":"source/images/daily/613674261.jpeg","path":"images/daily/613674261.jpeg","modified":1,"renderable":0},{"_id":"source/images/daily/788509444.jpg","path":"images/daily/788509444.jpg","modified":1,"renderable":0},{"_id":"source/images/nsopration_add_to_queue.png","path":"images/nsopration_add_to_queue.png","modified":1,"renderable":0},{"_id":"source/images/uitableviewcell_optimize.png","path":"images/uitableviewcell_optimize.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"source/images/318/IMG_0020.JPG","path":"images/318/IMG_0020.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0039.JPG","path":"images/318/IMG_0039.JPG","modified":1,"renderable":0},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"source/images/318/507311534.png","path":"images/318/507311534.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"source/images/318/DraggedImage-23.png","path":"images/318/DraggedImage-23.png","modified":1,"renderable":0},{"_id":"source/images/network_real_model.png","path":"images/network_real_model.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-11.png","path":"images/318/DraggedImage-11.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-19.png","path":"images/318/DraggedImage-19.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-24.png","path":"images/318/DraggedImage-24.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-7.png","path":"images/318/DraggedImage-7.png","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0184.JPG","path":"images/318/IMG_0184.JPG","modified":1,"renderable":0},{"_id":"source/images/read/read_zcczwxl.JPG","path":"images/read/read_zcczwxl.JPG","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-10.png","path":"images/318/DraggedImage-10.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-14.png","path":"images/318/DraggedImage-14.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-28.png","path":"images/318/DraggedImage-28.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-55.png","path":"images/318/DraggedImage-55.png","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0046.JPG","path":"images/318/IMG_0046.JPG","modified":1,"renderable":0},{"_id":"source/images/daily/824027791-2.png","path":"images/daily/824027791-2.png","modified":1,"renderable":0},{"_id":"source/images/318/2768809826.png","path":"images/318/2768809826.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-15.png","path":"images/318/DraggedImage-15.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-33.png","path":"images/318/DraggedImage-33.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-5.png","path":"images/318/DraggedImage-5.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-61.png","path":"images/318/DraggedImage-61.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-62.png","path":"images/318/DraggedImage-62.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-76.png","path":"images/318/DraggedImage-76.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-82.png","path":"images/318/DraggedImage-82.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-84.png","path":"images/318/DraggedImage-84.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-13.png","path":"images/318/DraggedImage-13.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-16.png","path":"images/318/DraggedImage-16.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-29.png","path":"images/318/DraggedImage-29.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-31.png","path":"images/318/DraggedImage-31.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-42.png","path":"images/318/DraggedImage-42.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-66.png","path":"images/318/DraggedImage-66.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-73.png","path":"images/318/DraggedImage-73.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-85.png","path":"images/318/DraggedImage-85.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-86.png","path":"images/318/DraggedImage-86.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-88.png","path":"images/318/DraggedImage-88.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage.png","path":"images/318/DraggedImage.png","modified":1,"renderable":0},{"_id":"source/images/daily/4245137053.png","path":"images/daily/4245137053.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-17.png","path":"images/318/DraggedImage-17.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-20.png","path":"images/318/DraggedImage-20.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-25.png","path":"images/318/DraggedImage-25.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-32.png","path":"images/318/DraggedImage-32.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-36.png","path":"images/318/DraggedImage-36.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-43.png","path":"images/318/DraggedImage-43.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-45.png","path":"images/318/DraggedImage-45.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-50.png","path":"images/318/DraggedImage-50.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-51.png","path":"images/318/DraggedImage-51.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-58.png","path":"images/318/DraggedImage-58.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-59.png","path":"images/318/DraggedImage-59.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-63.png","path":"images/318/DraggedImage-63.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-69.png","path":"images/318/DraggedImage-69.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-74.png","path":"images/318/DraggedImage-74.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-75.png","path":"images/318/DraggedImage-75.png","modified":1,"renderable":0},{"_id":"source/images/daily/750990835.png","path":"images/daily/750990835.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-1.png","path":"images/318/DraggedImage-1.png","modified":1,"renderable":0},{"_id":"source/images/318/805238010.png","path":"images/318/805238010.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-2.png","path":"images/318/DraggedImage-2.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-34.png","path":"images/318/DraggedImage-34.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-35.png","path":"images/318/DraggedImage-35.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-38.png","path":"images/318/DraggedImage-38.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-46.png","path":"images/318/DraggedImage-46.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-6.png","path":"images/318/DraggedImage-6.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-60.png","path":"images/318/DraggedImage-60.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-81.png","path":"images/318/DraggedImage-81.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-8.png","path":"images/318/DraggedImage-8.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-21.png","path":"images/318/DraggedImage-21.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-3.png","path":"images/318/DraggedImage-3.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-37.png","path":"images/318/DraggedImage-37.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-41.png","path":"images/318/DraggedImage-41.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-47.png","path":"images/318/DraggedImage-47.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-48.png","path":"images/318/DraggedImage-48.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-49.png","path":"images/318/DraggedImage-49.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-67.png","path":"images/318/DraggedImage-67.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-87.png","path":"images/318/DraggedImage-87.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-9.png","path":"images/318/DraggedImage-9.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_det.png","path":"images/linearmaths_det.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-12.png","path":"images/318/DraggedImage-12.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-26.png","path":"images/318/DraggedImage-26.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-30.png","path":"images/318/DraggedImage-30.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-4.png","path":"images/318/DraggedImage-4.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-44.png","path":"images/318/DraggedImage-44.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-53.png","path":"images/318/DraggedImage-53.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-54.png","path":"images/318/DraggedImage-54.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-64.png","path":"images/318/DraggedImage-64.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-72.png","path":"images/318/DraggedImage-72.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-79.png","path":"images/318/DraggedImage-79.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-80.png","path":"images/318/DraggedImage-80.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-83.png","path":"images/318/DraggedImage-83.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_equations.png","path":"images/linearmaths_equations.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-22.png","path":"images/318/DraggedImage-22.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-65.png","path":"images/318/DraggedImage-65.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-77.png","path":"images/318/DraggedImage-77.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-78.png","path":"images/318/DraggedImage-78.png","modified":1,"renderable":0},{"_id":"source/images/network_http_and_https_diff.png","path":"images/network_http_and_https_diff.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-18.png","path":"images/318/DraggedImage-18.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-71.png","path":"images/318/DraggedImage-71.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-56.png","path":"images/318/DraggedImage-56.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-68.png","path":"images/318/DraggedImage-68.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-70.png","path":"images/318/DraggedImage-70.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-52.png","path":"images/318/DraggedImage-52.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_quadratic.png","path":"images/linearmaths_quadratic.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-27.png","path":"images/318/DraggedImage-27.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-40.png","path":"images/318/DraggedImage-40.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-57.png","path":"images/318/DraggedImage-57.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_eigenvalue.png","path":"images/linearmaths_eigenvalue.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_matrix.png","path":"images/linearmaths_matrix.png","modified":1,"renderable":0},{"_id":"source/images/318/DraggedImage-39.png","path":"images/318/DraggedImage-39.png","modified":1,"renderable":0},{"_id":"source/images/linearmaths_vector.png","path":"images/linearmaths_vector.png","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0058.JPG","path":"images/318/IMG_0058.JPG","modified":1,"renderable":0},{"_id":"source/images/read/read_pfdsj.JPG","path":"images/read/read_pfdsj.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0170.JPG","path":"images/318/IMG_0170.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0157.JPG","path":"images/318/IMG_0157.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0097.JPG","path":"images/318/IMG_0097.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0078.JPG","path":"images/318/IMG_0078.JPG","modified":1,"renderable":0},{"_id":"source/images/318/IMG_0200.JPG","path":"images/318/IMG_0200.JPG","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"cf1a2f893bb23800caa2f9aa952696cb5c79ef29","modified":1534825417192},{"_id":"source/CNAME","hash":"a3f70605cea4dbe284e5822fbc83632d270c45df","modified":1534825417192},{"_id":"source/.DS_Store","hash":"f8820e7ae31ce861c99e3fae840fabeb459c879a","modified":1547371443519},{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1527662308174},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1527662308174},{"_id":"themes/jacman/README.md","hash":"098545637b0aeb27b14707c15e429470c603d78d","modified":1527662308175},{"_id":"themes/jacman/README_zh.md","hash":"9c73931bca4883de13eedd4be254da547d4ca52e","modified":1527662308175},{"_id":"themes/jacman/_config.yml","hash":"2708e9a19d3bb4248b9bdc4dc7ebd187c5d4504b","modified":1547358787254},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1534825830700},{"_id":"source/_posts/daily-2014-1024.md","hash":"722a0d15b65062961046a6dce5246dcb5038988e","modified":1547372974004},{"_id":"source/_posts/daily-2015-0820.md","hash":"054782c61896efdf85a3b0c0e56cd65c1e2fb854","modified":1547372976956},{"_id":"source/_posts/daily-2015-0702.md","hash":"52004b16664263ac5a2fff2026b048b0cbf0392b","modified":1547372975683},{"_id":"source/_posts/daily-2015-1204.md","hash":"de7ddc00ecc9007269d53ec57e96b23896ae105a","modified":1547372978333},{"_id":"source/_posts/daily-2016-0203.md","hash":"aa93e4cbbc7a0b0d900fa1dcc7dfbe9f17f1b192","modified":1547372979667},{"_id":"source/_posts/daily-2016-0212.md","hash":"f1fd3a306f1c4c353e2ee34d942cb912f3f6b2a0","modified":1547372981021},{"_id":"source/_posts/daily-2016-0422.md","hash":"d4911b0300c1663f36a47f2dec7aa05e21ff7246","modified":1547372982355},{"_id":"source/_posts/hello-world.md","hash":"b410bf078dab10b3815948728460b3f519ad3601","modified":1547354203344},{"_id":"source/_posts/daily-2017-0221.md","hash":"89a5c8c8656e89822dc99d92917f74efbf13b5f6","modified":1547372983692},{"_id":"source/_posts/daily-kaoyan.md","hash":"60b994db93eb3ebad103f3105374b7684e865c17","modified":1547372986549},{"_id":"source/_posts/ios-category-use-merit-and-demerit.md","hash":"daf866f5aef7a886f7fdf0599b4d2bddf7d8a598","modified":1547356158371},{"_id":"source/_posts/daily-2017-0231.md","hash":"0c1dc7b280593238d42da8a0d77fb77f96ea5cea","modified":1547372985100},{"_id":"source/_posts/ios-keywors-of-strong-weak-copy-retain-assign.md","hash":"deacda3c38303179790f18a63f0fa76ebf8b34c2","modified":1547354200032},{"_id":"source/_posts/ios-kvc-and-kvo.md","hash":"74292d6d50cd6d30735257a1f9c729156fdf5173","modified":1547356167403},{"_id":"source/_posts/ios-network-nsurlsession.md","hash":"13152b6816373ffacda12c101f77a9d7e40a64d3","modified":1547356174916},{"_id":"source/_posts/ios-networkbase-http-and-https.md","hash":"a26c8df20c8c98bf41fad06eb501f131ea142f73","modified":1547356183571},{"_id":"source/_posts/ios-nsthread.md","hash":"fe7db97853888075979e36f47079fcb3cd4e3c0a","modified":1547356189676},{"_id":"source/_posts/ios-nsurlrequest-and-nsurlresponse.md","hash":"5a953cec7a3008bd7a4b7e005c653f532070c131","modified":1547356195253},{"_id":"source/_posts/ios-runloop-and-autoreleasepool.md","hash":"f5505396beb5085d61ae5fbbb985d12449a84f88","modified":1547356200157},{"_id":"source/_posts/ios-scatter-point-collect.md","hash":"4756da05e3da854c0e7ecaf6f4a1e4f8785a2a61","modified":1547356208630},{"_id":"source/_posts/ios-thread-gcd.md","hash":"ee2ad727b088cc1b095c653acb56584cc62f5a40","modified":1547356212931},{"_id":"source/_posts/ios-thread-nsoperation.md","hash":"49cf2708425aa1e7892ed04a274246a31947de0b","modified":1547356217507},{"_id":"source/_posts/ios-thread-use-pthread.md","hash":"f85a3d98958aa0a6d4f936930f6871ba6c3b7898","modified":1547356223501},{"_id":"source/_posts/ios-uitableview-optimize.md","hash":"57bdc9c25ef98e5459812857b8c34e1ebf3ab1dc","modified":1547356227647},{"_id":"source/_posts/ios-uiwebview-and-jscontext-and-wkwebview.md","hash":"e3aaedfd9ae7d9628050e9c50f87b2c23da257c1","modified":1547356232671},{"_id":"source/_posts/linear-maths.md","hash":"303d08cd93ecff4021a3f351d2ba70544cd01c7a","modified":1547356144163},{"_id":"source/_posts/read-kj.md","hash":"002e35a910694c05bef0fc44310c85900d6b57a9","modified":1547373114502},{"_id":"source/_posts/read-pfdsj.md","hash":"a5848bdbdb3522f6a5962a9dfa11e68fb9fdd6d3","modified":1547373089574},{"_id":"source/_posts/read-trjzdlxz.md","hash":"9890a73ea95654dd6653c5e0991ebbbe021a464a","modified":1547373075795},{"_id":"source/_posts/read-zcczwxl.md","hash":"60303699bc687fbd058d7b742c4841a311fcb566","modified":1547373116460},{"_id":"source/_posts/xcode-code-snippets.md","hash":"732a6280c1e77a7636edb604ebd4442e153a704c","modified":1547370140497},{"_id":"source/_posts/xcode-pack-cer-create-process.md","hash":"b28cb24829157740ada161fd0e27ee02e57e1a04","modified":1547356251078},{"_id":"source/_posts/oc-block.md","hash":"a700d41d07a57e74279038ad2388067c862265b9","modified":1547356236470},{"_id":"source/about/index.md","hash":"3c8d0463f1aa48c4f19a34e40bea6316e7ea7e50","modified":1534825417206},{"_id":"source/_posts/oc-class-relationships.md","hash":"01cfe68c3c2a8d1bd1102dea4f9e31220e972888","modified":1547356240733},{"_id":"source/_posts/journey_318.md","hash":"c04fed9cfab2c68253a935819879d16f7cb3103e","modified":1547372692611},{"_id":"source/images/BLOG-QR.png","hash":"7b8fcc00a3ddb4cc4799e4cb08f1b32d2ad2e909","modified":1547353503996},{"_id":"source/images/.DS_Store","hash":"ed0a7cdae29d310529ffaab026e108719fbc0cd0","modified":1547370691441},{"_id":"source/images/README.md","hash":"d240609494e89cae0ec4a974d3e5132d0a94e17e","modified":1547353503996},{"_id":"source/images/code_snippet_dialog.png","hash":"0a230b49e3fc141e3a3e564e89aae791fe43cb8c","modified":1533997878706},{"_id":"source/images/code_snippets.png","hash":"3d783039d0b683ba1268adc779c74f7c6c292f93","modified":1533997881854},{"_id":"source/images/compile_last_one.png","hash":"b028257c5e20782afb2bbc4ace03799aabdcecc9","modified":1533997890805},{"_id":"source/images/compile_last_two.png","hash":"8f1e4a2990ac112d6739f63a8ae41a01b7638325","modified":1533997893298},{"_id":"source/images/csr_alert.png","hash":"7a8daebe61cef3c16566926af87ccebdd7910039","modified":1533997821978},{"_id":"source/images/kvc_layer_cornerradius.png","hash":"0eff61c7577f63f05f9954337c431b7ab1984240","modified":1533997907599},{"_id":"source/images/network_http_commute.png","hash":"f2471056aa1f7b1d22c00bdcd48efcbfefa11f1b","modified":1533997861181},{"_id":"source/images/nsopration_queue_maxium.png","hash":"d9dece317de7656abebb1967816b9b273cf8cfd5","modified":1533997951917},{"_id":"source/images/objc_runloop.jpg","hash":"ee1ceee3a09ec9d9074338d9b7a9552e5101f076","modified":1533997925556},{"_id":"source/images/objc_runloop_mode.png","hash":"f01863ef0a6135c20a9f3af7e13fb19a979ad510","modified":1533997929342},{"_id":"themes/jacman/.git/COMMIT_EDITMSG","hash":"640f6fc3832fc67ffdf17e8a77a76dc226217848","modified":1527662456334},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1527662308168},{"_id":"source/tags/index.md","hash":"59a849793c1afce6fc7a3e6af2ec9f66b3eadb7f","modified":1534825417207},{"_id":"themes/jacman/.git/FETCH_HEAD","hash":"7aedb1bf770bc05f133d31ad84664597d6aae47a","modified":1527663981996},{"_id":"themes/jacman/.git/ORIG_HEAD","hash":"6189d88e94ef059e0e2b9c4f736075816a0f6d32","modified":1527663982010},{"_id":"themes/jacman/.git/config","hash":"e8e43617aeb5a96c48af77bfd244060c1d7633b2","modified":1527662466339},{"_id":"themes/jacman/.git/index","hash":"46c4b4b998ef38a4977d44fadf6896c918d6e8b6","modified":1527662456332},{"_id":"themes/jacman/.git/packed-refs","hash":"2fac29f5765bd05a9386c524a1ce8120f761860d","modified":1527662308164},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1527662308176},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1527662308176},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1527662308177},{"_id":"themes/jacman/.git/sourcetreeconfig","hash":"bca0f1c45db973fe102ea5a9f44691edbc05e704","modified":1527663451324},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1527662308189},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1527662308188},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1527662308189},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1527662308189},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1527662308190},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1527662308189},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1527662308190},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1527662308190},{"_id":"source/images/cer_profile_list.png","hash":"a37c103017330890cc291d1721c4a684c57bfd52","modified":1533997816772},{"_id":"source/images/cer_create.png","hash":"08cf989d10d7f4b77164b448790432058e7e84cd","modified":1533997851860},{"_id":"source/images/controller_life_circle.png","hash":"4845e5df2314c3ca6f36b7a816a232da987ab5d5","modified":1533997948594},{"_id":"source/images/csr_keychain.png","hash":"496f56a787f3686a5c228b037a278355bf943e88","modified":1533997866728},{"_id":"source/images/network_commute_progress.png","hash":"d7f63759f0a96f014c9646c29bab7c5e2d2e37ea","modified":1533997769731},{"_id":"source/images/network_three_time_hand.png","hash":"c85601d5794ab5e3f0b660c49fe95db3c1bf109a","modified":1533997809438},{"_id":"source/images/objc_class_relationship.png","hash":"3055663970b4abed229d445ff4f6ee0b411f42be","modified":1533997923029},{"_id":"source/images/webpage_process_after.png","hash":"0b693693abf8d86ecc0274471ce4113589ccf217","modified":1533997874368},{"_id":"source/images/webpage_process_before.png","hash":"65fc00916ca085b606c4d5e85a14134585ea4e1e","modified":1533997874849},{"_id":"source/images/318/1255460395.jpg","hash":"a61f697c97ddec280998129bf7a094db02e0f004","modified":1516015939000},{"_id":"source/images/318/IMG_0197.JPG","hash":"b10555c7566c8d07e8a056c4c1ac416afb002dc4","modified":1547360864570},{"_id":"source/images/daily/2233356333.jpeg","hash":"3e17b28cb1d2becf6034052de83e61ec4f4a34a6","modified":1516011914000},{"_id":"source/images/daily/3122621194.jpeg","hash":"209ed4bfa525f842988c4732e8713808e9db4777","modified":1516011911000},{"_id":"source/images/daily/2069527412.jpeg","hash":"16b2585774b0cf8b5672b774647851984293010f","modified":1516011555000},{"_id":"source/images/daily/2884524888.jpg","hash":"8742bbb5a589de6d243d6ea208fa6611b6aee21e","modified":1516015682000},{"_id":"source/images/csr_create.png","hash":"5b8905116fe659557a6cbb31b70f62d6cac86e60","modified":1533997804768},{"_id":"source/images/network_encode_principle.png","hash":"141049b4a788214dd24db603b1ae49cdeca457c1","modified":1533997819707},{"_id":"source/images/daily/954377808.jpg","hash":"552930029722a0e38b34b973379527c2ffad504d","modified":1516015586000},{"_id":"source/images/objc_autoreleasepool.png","hash":"53f4e094483574c70ff2d58abdedf0a234bff93d","modified":1533997915979},{"_id":"source/images/network_theory_model.png","hash":"d50ae0195929362da1f3abe4d182d477ff56f7f3","modified":1533997785214},{"_id":"themes/jacman/.git/logs/HEAD","hash":"6b2fcf7bf64d01821960ec72c13cd6f5269bd427","modified":1527662456336},{"_id":"source/images/read/read_trjzdlxz.jpg","hash":"bef9147535adaf5e6144b3b2972157de25f94846","modified":1516015261000},{"_id":"source/images/read/read_kj.jpg","hash":"7ea7eabe0eaabf712456e0f366ff1265d8ce7073","modified":1516015166000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1527662308178},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"3e1f1d8dc38b1e17c523d1176f7ee503fc648045","modified":1527662308177},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1527662308178},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1527662308178},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1527662308179},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1527662308179},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1527662308179},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1527662308180},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1527662308181},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1527662308181},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1527662308180},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1527662308184},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1527662308185},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1527662308185},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1527662308185},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1527662308185},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1527662308186},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1527662308186},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"d49a8d609c5fbafa9e7ad328163565af03306519","modified":1527662308187},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1527662308186},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1527662308187},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1527662308187},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1527662308187},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1527662308188},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1527662308196},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"5922477305ea1aee90fbd1495404eec26d7c1065","modified":1547360261618},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1527662308196},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1527662308197},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1527662308197},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1527662308198},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1527662308200},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1527662308202},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1527662308198},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1527662308199},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1527662308201},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1527662308203},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1527662308204},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1527662308207},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1527662308206},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1527662308207},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1527662308211},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1527662308215},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1527662308212},{"_id":"themes/jacman/source/img/author.jpg","hash":"acdda175a4f367014d079cfb94f172763f8db3eb","modified":1527662308216},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1527662308214},{"_id":"themes/jacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1528429560103},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1527662308219},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1527662308220},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1527662308220},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1527662308220},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1527662308221},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1527662308221},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1527662308221},{"_id":"themes/jacman/source/img/logo.png","hash":"4b8072b842e2466cb1d95d2ea0fe595d0a95e9de","modified":1528427076809},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1527662308225},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1527662308225},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1527662308227},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1527662308227},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1527662308228},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1527662308225},{"_id":"themes/jacman/source/img/jacman.png","hash":"4b8072b842e2466cb1d95d2ea0fe595d0a95e9de","modified":1528427076809},{"_id":"source/images/cer_export_p12.png","hash":"bcf31fb251e2e3013707f61db13016a5a03cfc5c","modified":1533997844564},{"_id":"source/images/daily/1590392806.jpg","hash":"4c9470711a5fc14e4b516c13ae1af6d083d8d8e8","modified":1516012552000},{"_id":"source/images/gcd_and_nop_relationship.png","hash":"77d4ee498c04713fe471f45f47d1a6166511c0c6","modified":1533997859782},{"_id":"source/images/network_class_struct.png","hash":"61d2aa5d0f10eed79655d64d22a2e975e7c93ec2","modified":1533997781816},{"_id":"source/images/daily/613674261.jpeg","hash":"5b05c2db859e43e6663a625e8651feb28ac7826c","modified":1516012056000},{"_id":"source/images/daily/788509444.jpg","hash":"f58f1e3dde25ac53641c71289e6a2c562567c5be","modified":1516012438000},{"_id":"source/images/nsopration_add_to_queue.png","hash":"1f8d130f0f266cffd9a689cc60c08d4f722ed39d","modified":1533997944898},{"_id":"source/images/uitableviewcell_optimize.png","hash":"25a4d0d6c6adc76ca9f8415e218da50d7ca758c3","modified":1533997938151},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1527662308205},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1527662308211},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1527662308214},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1527662308226},{"_id":"themes/jacman/source/img/favicon.ico","hash":"4a75e561ae5a107c125edb20463336745f46299e","modified":1528429027262},{"_id":"source/images/318/IMG_0020.JPG","hash":"9944a639030a080265c9036b94e5349defaa000a","modified":1481991897000},{"_id":"source/images/318/IMG_0039.JPG","hash":"71755535ddddb1e02f2268dfb9a48811712eb83a","modified":1481991897000},{"_id":"themes/jacman/.git/objects/8a/2d666ff266abfc48449fa225c89e2a940d1b16","hash":"e7f4327c58830520640ac84cde55596350a41ab2","modified":1527662456331},{"_id":"themes/jacman/.git/objects/ad/ecc35a35d9898c30945df5a3e50ad06c169663","hash":"29cd6a764a6bb69cf5df3b0cd617459424de5c5b","modified":1527662456335},{"_id":"themes/jacman/.git/refs/heads/master","hash":"6189d88e94ef059e0e2b9c4f736075816a0f6d32","modified":1527662456336},{"_id":"themes/jacman/.git/objects/e6/cacbf68b5e223915c98c947fc60f77befb782b","hash":"2741b8b0438385e8e4999dc409fc8057814c14f7","modified":1527662456331},{"_id":"themes/jacman/.git/objects/pack/pack-c1eb62303caeb2001483f3f36a21b5c6d4147eca.idx","hash":"6fa42d3a81f92e11b94d413218a7f33335db1d65","modified":1527662308154},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"548c69c570d5aac567bc6f088e9ee0c02223b088","modified":1527662308182},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1527662308182},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1527662308182},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1527662308183},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1527662308183},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1527662308183},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1527662308192},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1527662308192},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1527662308191},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1527662308193},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1527662308193},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1527662308194},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1527662308194},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1527662308194},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1527662308195},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1527662308195},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1527662308195},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1527662308199},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1527662308184},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1527662308183},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1527662308194},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1527662308199},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1527662308200},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1527662308199},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1527662308200},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1527662308200},{"_id":"source/images/318/507311534.png","hash":"ad90f89374a8cc91759140f2d5f6261c9c3f08ce","modified":1516016018000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1527662308209},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1527662308218},{"_id":"source/images/318/DraggedImage-23.png","hash":"af738d5413460fd178f5f3673f2bd60327401f60","modified":1523800384666},{"_id":"source/images/network_real_model.png","hash":"125b65a19d63ecfcd9ef16010a488738065910d7","modified":1533997827922},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1527662308191},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1527662308192},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1527662308167},{"_id":"themes/jacman/.git/refs/remotes/origin/master","hash":"6189d88e94ef059e0e2b9c4f736075816a0f6d32","modified":1527662466340},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"6b2fcf7bf64d01821960ec72c13cd6f5269bd427","modified":1527662456336},{"_id":"source/images/318/DraggedImage-11.png","hash":"74eacf430106c1ce1606eed7ecafc366b655b642","modified":1547360851987},{"_id":"source/images/318/DraggedImage-19.png","hash":"9f09c97831797e8d96e39d43921fa1668d6fa4e0","modified":1547360847458},{"_id":"source/images/318/DraggedImage-24.png","hash":"74183f691c5760f0e8ba30eb99492c150ed6a7de","modified":1547360845821},{"_id":"source/images/318/DraggedImage-7.png","hash":"66a5f257378425a10ced9fd4ca97b12252a1dc67","modified":1547360834412},{"_id":"source/images/318/IMG_0184.JPG","hash":"2a4abb358707ca74f6ac98a09ca232cc4ce0beca","modified":1547360864393},{"_id":"source/images/read/read_zcczwxl.JPG","hash":"b7fddfcf47698e6bb8fef963fb8b97c705b74e89","modified":1515726166000},{"_id":"source/images/318/DraggedImage-10.png","hash":"6808756ed3a18380350a339682f12b5adea88a37","modified":1547360854346},{"_id":"source/images/318/DraggedImage-14.png","hash":"f0a8fb75b1700c16746233e02ca23bcea32b32ad","modified":1523800546886},{"_id":"source/images/318/DraggedImage-28.png","hash":"52c0cb3df427b0c2a04b049e8bd39a1651c4c834","modified":1547360846209},{"_id":"source/images/318/DraggedImage-55.png","hash":"7a5bcbcb225485c6c62da757f220cdf3487ee178","modified":1523799627129},{"_id":"source/images/318/IMG_0046.JPG","hash":"503ad8d353bdb517fc3502d191c012370554a0b5","modified":1481991897000},{"_id":"source/images/daily/824027791-2.png","hash":"23ad83e5374aef2f0c9d9566d8f2efea2084592d","modified":1516012285000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"674a71122bd11d9e3681a4c521d28830a5b1f5cf","modified":1527662308167},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/master","hash":"d9aebd6eb01464ccd4520ef021fe9b5c84796b87","modified":1527662466342},{"_id":"source/images/318/2768809826.png","hash":"a042b6c8ee01c3dcf2d3f6f80074f73b31d70ca4","modified":1516016103000},{"_id":"source/images/318/DraggedImage-15.png","hash":"728929049202ef1d733fb2b170736e15955b7403","modified":1523800551321},{"_id":"source/images/318/DraggedImage-33.png","hash":"8c8014bb1dbed0340a47f44b3e7dd34defbe199c","modified":1547360854511},{"_id":"source/images/318/DraggedImage-5.png","hash":"31f57345345c32ead79437444d8a886fbc4cfdc5","modified":1547360853352},{"_id":"source/images/318/DraggedImage-61.png","hash":"6a91fb84d6e29ee5daddcc41de54823db4dd6f90","modified":1547360854888},{"_id":"source/images/318/DraggedImage-62.png","hash":"05da860477295d2441321893826504ce20bcc2d9","modified":1547360855530},{"_id":"source/images/318/DraggedImage-76.png","hash":"4551606d8f90e57502c0f810bf36a6310d12eda3","modified":1547360862696},{"_id":"source/images/318/DraggedImage-82.png","hash":"1d8d0be7fd3a32412aac837146a957fcd6fb0531","modified":1547360863911},{"_id":"source/images/318/DraggedImage-84.png","hash":"457a85d1de56da795783cec4966fc187c7aa8a80","modified":1547360862277},{"_id":"source/images/318/DraggedImage-13.png","hash":"d3e6954725ddb2de191748b623d3a271fc6768c8","modified":1547360853783},{"_id":"source/images/318/DraggedImage-16.png","hash":"035aa5a67f18ab4f47471f2b3efbaccbf35469ac","modified":1523800555723},{"_id":"source/images/318/DraggedImage-29.png","hash":"f1cff3e702e299494dc59fba953da19d3bd89353","modified":1547360855505},{"_id":"source/images/318/DraggedImage-31.png","hash":"ecce7f407c86e08ded134e1b646e24ecb7fbeb50","modified":1547360844409},{"_id":"source/images/318/DraggedImage-42.png","hash":"e3b6262b6b95e1ae23ca241beffbecb0132cecb4","modified":1523799947391},{"_id":"source/images/318/DraggedImage-66.png","hash":"15b066d63822c85f15689549594cb7a1c29e1d7a","modified":1547360854786},{"_id":"source/images/318/DraggedImage-73.png","hash":"b320fad17f12d945ea3dee879b70b5e4c77598fd","modified":1547360861769},{"_id":"source/images/318/DraggedImage-85.png","hash":"4f99130fa1769c47544fb699d45bf09b5b764055","modified":1547360865677},{"_id":"source/images/318/DraggedImage-86.png","hash":"c3fd838aa886e6440f70290b0d95d9ec74e1f508","modified":1547360867131},{"_id":"source/images/318/DraggedImage-88.png","hash":"06208c0569e0f8952a0f252443ba6a04cbfa3ebb","modified":1547360866326},{"_id":"source/images/318/DraggedImage.png","hash":"ad7e95ee9db7685784891eac9c76986db569c708","modified":1547360833637},{"_id":"source/images/daily/4245137053.png","hash":"97135273cf1436b04830f80b0e54fae3baadf743","modified":1516015391000},{"_id":"source/images/318/DraggedImage-17.png","hash":"2fdac033f71e52365c0af04e22bf2722f2aedbcb","modified":1547360849815},{"_id":"source/images/318/DraggedImage-20.png","hash":"11b126734b6eaa0e97a5dbafb85e375b79b5de55","modified":1547360847080},{"_id":"source/images/318/DraggedImage-25.png","hash":"e9782c494266a37c2e4eba846da9b9701253c970","modified":1547360845772},{"_id":"source/images/318/DraggedImage-32.png","hash":"d6ec1cc5114b2286074fe8284f82890e4a58b273","modified":1547360841893},{"_id":"source/images/318/DraggedImage-36.png","hash":"1ab826f774eecf715f4e3ad76e6d27feed9d94e1","modified":1547360849435},{"_id":"source/images/318/DraggedImage-43.png","hash":"fea1a409bc25834537774ac62a441b9d8c4ff5ea","modified":1523799952421},{"_id":"source/images/318/DraggedImage-45.png","hash":"ca89fa8886e1f610f8b7327e59f639b19cf5af5c","modified":1547360840216},{"_id":"source/images/318/DraggedImage-50.png","hash":"ddc11f443bfa96f695792f2aff73ac5c0f178c63","modified":1547360852252},{"_id":"source/images/318/DraggedImage-51.png","hash":"92443199c337d8327c402bfde1c2d3bfe6df0d17","modified":1547360845905},{"_id":"source/images/318/DraggedImage-58.png","hash":"e9017b4e723eab0b0f327a5a3c5485acd65ace06","modified":1523799278388},{"_id":"source/images/318/DraggedImage-59.png","hash":"fd1899c852751354354f961a430f536103a07839","modified":1523799283777},{"_id":"source/images/318/DraggedImage-63.png","hash":"6230b1f69218d3b8d395891f4a780952b68002ce","modified":1547360856321},{"_id":"source/images/318/DraggedImage-69.png","hash":"59d3120d3fe2ee9e19552a67e2605f67988f96f2","modified":1547360856730},{"_id":"source/images/318/DraggedImage-74.png","hash":"d4629e19d8cd8bdde3875b1f010800d8f420a4f2","modified":1547360862808},{"_id":"source/images/318/DraggedImage-75.png","hash":"46ec1f6cec6ef83f4a051410bd803be6570f2ada","modified":1547360862415},{"_id":"source/images/daily/750990835.png","hash":"433cbdd2c1fc8fe208a7e73e2fe9034043a56f95","modified":1516015779000},{"_id":"source/images/318/DraggedImage-1.png","hash":"e1ae9defba972905a7f976ccbbbe274184a49988","modified":1547360855521},{"_id":"source/images/318/805238010.png","hash":"aa64473f6a451952a8923cb19acd1679945d7071","modified":1516016051000},{"_id":"source/images/318/DraggedImage-2.png","hash":"bd5aa5eba314601b3c895b21748d3be3325b8f41","modified":1547360844188},{"_id":"source/images/318/DraggedImage-34.png","hash":"295bfb2fae53aae7d9c832909a7f2bd52a226bcc","modified":1547360846144},{"_id":"source/images/318/DraggedImage-35.png","hash":"f44a63b78530f92c0d188061be189fc6483861f0","modified":1547360836986},{"_id":"source/images/318/DraggedImage-38.png","hash":"0e3e3e46a5797a7228df9fb276c8b999f368cbf7","modified":1547360841508},{"_id":"source/images/318/DraggedImage-46.png","hash":"818bb3abbac4138b28b815fd67b950d997870319","modified":1547360830383},{"_id":"source/images/318/DraggedImage-6.png","hash":"0d622657f02490bae82430b7d72eb4bc1c38bd85","modified":1547360841441},{"_id":"source/images/318/DraggedImage-60.png","hash":"a7967094c69d60d7a3ea1f86c213f2707602a652","modified":1547360857159},{"_id":"source/images/318/DraggedImage-81.png","hash":"9c9ba0efa8394f22ab42d32bf8fd587ecf738620","modified":1547360861520},{"_id":"source/images/318/DraggedImage-8.png","hash":"808e3d72e7d6473f193965abfda72e1165838d9d","modified":1547360838296},{"_id":"source/images/318/DraggedImage-21.png","hash":"95378616de101a1a60f68fb85eaa23ba9e45540e","modified":1547360850446},{"_id":"source/images/318/DraggedImage-3.png","hash":"81bc059921320b91e0619f5b2c1c10bcef8d70a6","modified":1547360838160},{"_id":"source/images/318/DraggedImage-37.png","hash":"0c5eab3962f9f4c622156489035a52c6346ebdd1","modified":1547360850916},{"_id":"source/images/318/DraggedImage-41.png","hash":"9ddd676916ef377d249add7c0b76a122c439de1a","modified":1523799999653},{"_id":"source/images/318/DraggedImage-47.png","hash":"ae70f4101448774a28d610b230162b3692e3d22f","modified":1547360830933},{"_id":"source/images/318/DraggedImage-48.png","hash":"ae70f4101448774a28d610b230162b3692e3d22f","modified":1547360830926},{"_id":"source/images/318/DraggedImage-49.png","hash":"7830582db6b097011a44e43baabdbde08f6c41fe","modified":1547360837001},{"_id":"source/images/318/DraggedImage-67.png","hash":"2dac980981d3bf0c344255edf9406142fc875f25","modified":1547360855939},{"_id":"source/images/318/DraggedImage-87.png","hash":"1e8051873581523bd70ae0b43827bbc7cde1b9e4","modified":1547360864975},{"_id":"source/images/318/DraggedImage-9.png","hash":"f7f3fbdcf71b37cc162db7f6a5d2b4acd6684f5d","modified":1547360830992},{"_id":"source/images/linearmaths_det.png","hash":"fea61499f50a619de591ac39cd280907242df6b5","modified":1533997899609},{"_id":"source/images/318/DraggedImage-12.png","hash":"25af89b2110c03b096e944ad862dd31dcf0c8c76","modified":1547360852996},{"_id":"source/images/318/DraggedImage-26.png","hash":"c856bab7d4ba977cefdde1458aea1410145f1be9","modified":1547360850343},{"_id":"source/images/318/DraggedImage-30.png","hash":"de7b1e8479a1ea00baa8bc01762b716e1870f40a","modified":1547360853198},{"_id":"source/images/318/DraggedImage-4.png","hash":"45ffacf16b6c670ac528c7aa8bec10bb3960e97f","modified":1547360857433},{"_id":"source/images/318/DraggedImage-44.png","hash":"824959d5a7dd235579effe3c936295ef71cf685b","modified":1523799957751},{"_id":"source/images/318/DraggedImage-53.png","hash":"1183b02d93506217f7e84919e4fbcf0f2463aa13","modified":1547360853135},{"_id":"source/images/318/DraggedImage-54.png","hash":"c4e74155dba577bad4875eccb8fe07ccc8b60578","modified":1547360840207},{"_id":"source/images/318/DraggedImage-64.png","hash":"422ef18ad43165518a0667f42ba7fa446fe922dc","modified":1547360854777},{"_id":"source/images/318/DraggedImage-72.png","hash":"88472fba385d26095b5a82bd659d0e18491618d6","modified":1547360863246},{"_id":"source/images/318/DraggedImage-79.png","hash":"6b63d38544ca75da521289ab6eeb31642d96cdaa","modified":1547360862287},{"_id":"source/images/318/DraggedImage-80.png","hash":"33382d088608aec99e046e37716b8817a5105f7e","modified":1547360862759},{"_id":"source/images/318/DraggedImage-83.png","hash":"f2e5384818cacaa47e5f03939678d6e96d1611c5","modified":1547360863360},{"_id":"source/images/linearmaths_equations.png","hash":"9bdd77e79d660d1ce4702590f9fe86293903906b","modified":1533997906084},{"_id":"source/images/318/DraggedImage-22.png","hash":"8f2cc4e99152789d64adf5203db69b8f02d65c6d","modified":1547360851335},{"_id":"source/images/318/DraggedImage-65.png","hash":"648d5317d93e59f336c4787604ebc9fc8f12a435","modified":1547360854997},{"_id":"source/images/318/DraggedImage-77.png","hash":"06225a4dae3d2f7cfc2a4be4bd6f61e23c34f0c3","modified":1547360862089},{"_id":"source/images/318/DraggedImage-78.png","hash":"7c8895058ed593a881294c107c6ced87bb45f12a","modified":1547360863124},{"_id":"source/images/network_http_and_https_diff.png","hash":"5fe5329fcecd72e2f519c075f188a69445f21153","modified":1533997792117},{"_id":"source/images/318/DraggedImage-18.png","hash":"bbbe5b8d9497ae17fc8d486a5072c07bc8db0d7a","modified":1547360849496},{"_id":"source/images/318/DraggedImage-71.png","hash":"978833b70c0a6379ea85a2f5d4c4d36e3845dcde","modified":1547360857942},{"_id":"source/images/318/DraggedImage-56.png","hash":"ac747c684721ac6bc7b38f86c4dc0544f4cb8de4","modified":1523799631834},{"_id":"source/images/318/DraggedImage-68.png","hash":"3aa2871e21a89b0956d4cf4c7c155f84c26dc273","modified":1547360859213},{"_id":"source/images/318/DraggedImage-70.png","hash":"54b600f0339d92716edf427f939a4361198272c7","modified":1547360854951},{"_id":"source/images/318/DraggedImage-52.png","hash":"9c043d8a0ca006da4c00eb7ad70cf4520e242567","modified":1547360851276},{"_id":"source/images/linearmaths_quadratic.png","hash":"63038e9928a4e15403ac6a4552f9ea27c5e598af","modified":1533997935352},{"_id":"source/images/318/DraggedImage-27.png","hash":"149b30328bff26db628b8a0243b2ceb4fb5d74b7","modified":1547360850032},{"_id":"source/images/318/DraggedImage-40.png","hash":"1a7e7886119bd9379fc4dc4e691452f1afa327e6","modified":1547360852068},{"_id":"source/images/318/DraggedImage-57.png","hash":"228a803fbb708f21222301aef301f1dbbd2de988","modified":1523799322327},{"_id":"source/images/linearmaths_eigenvalue.png","hash":"3d06ebfd1b538d0acb5d7a71dfc292f3a8364531","modified":1533997905184},{"_id":"source/images/linearmaths_matrix.png","hash":"8330ba680cb26b82a211534cbc0b5694269c0526","modified":1533997916821},{"_id":"source/images/318/DraggedImage-39.png","hash":"3eba1f25a11e659ba98d9c2a6f02b0e740a969f7","modified":1547360852826},{"_id":"source/images/linearmaths_vector.png","hash":"7e9d630e848ada8859d217c348273d2811f85fc3","modified":1533997945623},{"_id":"source/images/318/IMG_0058.JPG","hash":"f01ace25a075a297600a39a52f60fabc01850286","modified":1547360863511},{"_id":"source/images/read/read_pfdsj.JPG","hash":"38f75c572f17d0b97dcbe0d870cb5562bd429a4a","modified":1515551581000},{"_id":"source/images/318/IMG_0170.JPG","hash":"7e7863e3cc7c91d892253e86beb26ebb98c95a58","modified":1547360865346},{"_id":"source/images/318/IMG_0157.JPG","hash":"6a07c4e591ad436ad70d3c47901758e626c16529","modified":1547360861752},{"_id":"source/images/318/IMG_0097.JPG","hash":"b6b38f0f938ff936de066686cf05af1f902698e6","modified":1547360862682},{"_id":"source/images/318/IMG_0078.JPG","hash":"0a8a4979d6cb7e56121a542dd7f0ec2738745130","modified":1547360863689},{"_id":"themes/jacman/.git/objects/pack/pack-c1eb62303caeb2001483f3f36a21b5c6d4147eca.pack","hash":"1be9a5461fb516cd644f9c16077ae972102574a9","modified":1527662308153},{"_id":"source/images/318/IMG_0200.JPG","hash":"af3b996a9e9ed5fdac8e24c585c97eaa41398371","modified":1547360864493},{"_id":"public/404.html","hash":"072b81c53a08fe0d1b8d71fb580127c1bd426c47","modified":1547373132361},{"_id":"public/atom.xml","hash":"0fc299c2d1bf3582513c763f8f48b6629906f68b","modified":1547373133043},{"_id":"public/about/index.html","hash":"d00ced2f1258460f9cce663801e5fb542e432ab6","modified":1547373133121},{"_id":"public/tags/index.html","hash":"fa2519e7f9dee6a0b90f709eb267496f5773879c","modified":1547373133121},{"_id":"public/images/README.html","hash":"4ad1061b56fdd4b97e3930531ffd3f2ccf194aa2","modified":1547373133122},{"_id":"public/categories/Daily/index.html","hash":"7a3da69a0288a9a9c2928fc3c3674f20c56cd498","modified":1547373133122},{"_id":"public/categories/iOS/index.html","hash":"0a589aa8290e22c51b3429c2a2012a17f5607763","modified":1547373133122},{"_id":"public/categories/iOS/Objc/index.html","hash":"16eea6a8de187b9aa83843c6f658e1dc4cebca92","modified":1547373133122},{"_id":"public/categories/Readed/index.html","hash":"75665627d3ce5956caf638beb6d327784b1116c7","modified":1547373133122},{"_id":"public/categories/Xcode/index.html","hash":"1a02981a9cef7485215732cc596a60b33d29bb19","modified":1547373133122},{"_id":"public/categories/Jurney/index.html","hash":"22e9c526af86f45ce3ef957f00901586716485ec","modified":1547373133122},{"_id":"public/archives/2014/index.html","hash":"5690b2c294b39850452e34f13b785faac3012ae1","modified":1547373133122},{"_id":"public/archives/2014/10/index.html","hash":"323a12315ef2e77fbabe0ee5125700d1a8cf1fa2","modified":1547373133122},{"_id":"public/archives/2015/index.html","hash":"fba7c51c8232db4b7c5bb123fea421ab8ed5e887","modified":1547373133122},{"_id":"public/archives/2015/07/index.html","hash":"3482880a305d91d35bd947ad89de4854f5a62520","modified":1547373133122},{"_id":"public/archives/2015/08/index.html","hash":"fc87935cfd5bbf2889fe63c85006c287ca01a68e","modified":1547373133123},{"_id":"public/archives/2015/12/index.html","hash":"b1d9396636ede62a86ac64e41b584e673508c101","modified":1547373133123},{"_id":"public/archives/2016/index.html","hash":"ef3dba4f48e45ce95eb5029eb93acf0ac6fb9116","modified":1547373133123},{"_id":"public/archives/2016/02/index.html","hash":"f2b37e227109834d9baecdb5ce3ebc2e08b16850","modified":1547373133123},{"_id":"public/archives/2016/04/index.html","hash":"a805d44cbc09b1b0042e5e5cfdfc09c2049e5795","modified":1547373133123},{"_id":"public/archives/2016/05/index.html","hash":"061bcd410fee4e388cf0e496873b23ae33394c74","modified":1547373133123},{"_id":"public/archives/2016/06/index.html","hash":"d383a13b7a2adb403c51e89ebe418d884513d9f7","modified":1547373133123},{"_id":"public/archives/2016/08/index.html","hash":"2e60e628beb5b5be65a85e21702516f5627a75ac","modified":1547373133123},{"_id":"public/archives/2017/index.html","hash":"03e38666dbd3528243afeed69c8c2335d84236b6","modified":1547373133123},{"_id":"public/archives/2017/02/index.html","hash":"34cceb1d8357e56e1b49964ac155c4a92330d53c","modified":1547373133123},{"_id":"public/archives/2017/04/index.html","hash":"55556f9a000c1a61d60efd19a67ea35fd2158b23","modified":1547373133123},{"_id":"public/archives/2017/12/index.html","hash":"9172df8bc1ee5a049075114558e0a1780c913f7e","modified":1547373133123},{"_id":"public/archives/2018/index.html","hash":"0911178af2f87c943f77726682395ab4b46803e4","modified":1547373133123},{"_id":"public/archives/2018/01/index.html","hash":"52c1155e06f922aad8ba32085941964589746ed9","modified":1547373133123},{"_id":"public/archives/2018/04/index.html","hash":"04c4075b6c4125bc97cea3fc72bcc6f611b4252c","modified":1547373133123},{"_id":"public/archives/2018/05/index.html","hash":"f3f41248b9fb9b4c21203efeab9919f8e6c3ad4e","modified":1547373133124},{"_id":"public/archives/2018/06/index.html","hash":"6374864e5432d9adb87a5871c6f43986aa552693","modified":1547373133124},{"_id":"public/archives/2018/07/index.html","hash":"716c588f060c25ed044ed1bf0367a6981cb9dde3","modified":1547373133124},{"_id":"public/page/4/index.html","hash":"9ee75905e257db5c4b21fc31a71dc484a8b5c185","modified":1547373133124},{"_id":"public/tags/Daily/index.html","hash":"947f1e78d45663004316485742d289f42f45abda","modified":1547373133124},{"_id":"public/tags/iOS/index.html","hash":"3bfca3ed0cf139c8d621afe741d1447e9a06dbc5","modified":1547373133124},{"_id":"public/tags/Category/index.html","hash":"8fa3d733349c8af9efc7b20bea241473d5ac0eba","modified":1547373133124},{"_id":"public/tags/keywords/index.html","hash":"38d75915cdd158127eeefe6a58ecf42c26455fcc","modified":1547373133124},{"_id":"public/tags/Objc/index.html","hash":"64361aaa26180f1035ca502ed7ae58778e94fa3f","modified":1547373133124},{"_id":"public/tags/KVC/index.html","hash":"781315bd858818cf0e493e69cce7a5a9542c6b03","modified":1547373133124},{"_id":"public/tags/KVO/index.html","hash":"c03effb0c95542a3853e448120e829cb0d32f113","modified":1547373133124},{"_id":"public/tags/Network/index.html","hash":"8f4bc43013cff85754f5fd779e8c280a2e4f026b","modified":1547373133124},{"_id":"public/tags/NSURLSession/index.html","hash":"5f68b2384864ed6c0b18e660be2fb43c315bf998","modified":1547373133124},{"_id":"public/tags/Http/index.html","hash":"def8881f532be53666cf6fcec726f20694df9132","modified":1547373133124},{"_id":"public/tags/Https/index.html","hash":"230aa27b36e9264a1ca12f7bea9a216a60d8dbd1","modified":1547373133124},{"_id":"public/tags/Thread/index.html","hash":"60b0c10e0111d769b849ad93c0609b2228c09d3e","modified":1547373133125},{"_id":"public/tags/NSThread/index.html","hash":"cedae122287fcff69900f58ddd44acea23e53808","modified":1547373133125},{"_id":"public/tags/NSURLRequest/index.html","hash":"f7cc6fa982d5d0c1b969db9f66101ef75af07d71","modified":1547373133125},{"_id":"public/tags/NSURLResponse/index.html","hash":"f2d00e4611a8b6b11681b584bccb81a8f0d487ec","modified":1547373133125},{"_id":"public/tags/RunLoop/index.html","hash":"0f2fc437ae63a8fbe56335942473fd4c21db612b","modified":1547373133125},{"_id":"public/tags/AutoreleasePool/index.html","hash":"bbcee04b44c83eeab6d7d2bc09c613547b630eb3","modified":1547373133125},{"_id":"public/tags/GCD/index.html","hash":"7cb48245880e654ddbe0512fa5b52b6a4072227d","modified":1547373133125},{"_id":"public/tags/NSOperation/index.html","hash":"5244f2c4310b6747af3462e7fbf92ef328f3de35","modified":1547373133125},{"_id":"public/tags/UITableView/index.html","hash":"b2b5d646ac6c7c19bba426c8e7444ad3c0fa3740","modified":1547373133125},{"_id":"public/tags/WebView/index.html","hash":"483c2b67d695506737937f982be56a159cbb729b","modified":1547373133125},{"_id":"public/tags/Readed/index.html","hash":"901d2e92ab918d1522b9f1d27f6e5c26b8bb2553","modified":1547373133125},{"_id":"public/tags/Xcode/index.html","hash":"77d8c57d2e6f1fb6ff2c23cc0f5ebfbd82c87c93","modified":1547373133125},{"_id":"public/tags/Block/index.html","hash":"fe477c543f7c9843ca90cfb41892620296797868","modified":1547373133125},{"_id":"public/tags/Jurney/index.html","hash":"63c2544eae63bb8c699bf16326fe8dd8455f9d81","modified":1547373133125},{"_id":"public/2018/07/16/linear-maths/index.html","hash":"0b1ce9d55c801682fc784b3c40dc20b1ac7e7ea2","modified":1547373133125},{"_id":"public/2018/06/09/oc-class-relationships/index.html","hash":"ebacb680afbb6b0e1b934e0ac42da034c8d56578","modified":1547373133125},{"_id":"public/2018/05/24/ios-runloop-and-autoreleasepool/index.html","hash":"eebea4fcfd10cb11e5e04f5f76505bba6a2b488e","modified":1547373133125},{"_id":"public/2018/05/23/ios-kvc-and-kvo/index.html","hash":"936e53ab6722ea92457430195981a632dc8c10d8","modified":1547373133125},{"_id":"public/2018/05/18/ios-uitableview-optimize/index.html","hash":"42cb50101c8bcfcd86fadf31f0f9e8e439416afa","modified":1547373133126},{"_id":"public/2018/05/18/ios-thread-use-pthread/index.html","hash":"23db5335e55074881aef9d3e67fccfe84a6c2963","modified":1547373133126},{"_id":"public/2018/05/18/ios-category-use-merit-and-demerit/index.html","hash":"051fd5f57127abd729d274cad24bcb948f9e0c26","modified":1547373133126},{"_id":"public/2018/05/18/ios-keywors-of-strong-weak-copy-retain-assign/index.html","hash":"7da973bb0ee0cc7b731d563c09f6c739c044f497","modified":1547373133126},{"_id":"public/2018/05/18/ios-scatter-point-collect/index.html","hash":"c797eeabdf654e0f2de6985e442bcf47664f1aaa","modified":1547373133126},{"_id":"public/2018/05/10/oc-block/index.html","hash":"2de6e1d4aa5af31114be4929181757c7816e558d","modified":1547373133126},{"_id":"public/2018/05/08/ios-uiwebview-and-jscontext-and-wkwebview/index.html","hash":"4e0470ad4f3b698bf49a9699cb438e01e005436c","modified":1547373133126},{"_id":"public/2018/05/08/xcode-code-snippets/index.html","hash":"434129d16a74b81b8f3079f71955ca9ce95305aa","modified":1547373133126},{"_id":"public/2018/05/02/ios-nsurlrequest-and-nsurlresponse/index.html","hash":"08b8f43a801b2ceb291df7a2c0bd21f338cb423f","modified":1547373133126},{"_id":"public/2018/04/29/ios-network-nsurlsession/index.html","hash":"63700d3188264fbcfd53e6383dfa3f299f0e3af7","modified":1547373133126},{"_id":"public/2018/04/29/ios-networkbase-http-and-https/index.html","hash":"9a7c48b9bbd50d5f988118445bb7d4976a371972","modified":1547373133126},{"_id":"public/2018/04/29/ios-thread-nsoperation/index.html","hash":"db19b5824f91b2ffd2dc0500ff87ea3ea20328a7","modified":1547373133126},{"_id":"public/2018/04/29/ios-thread-gcd/index.html","hash":"9ece01409eff5528843837e026cd8bb4f41f8de4","modified":1547373133126},{"_id":"public/2018/04/29/ios-nsthread/index.html","hash":"26d83bdf2ae12ff8f02094ac32894c31ddf9e842","modified":1547373133127},{"_id":"public/2018/04/29/xcode-pack-cer-create-process/index.html","hash":"422dfaf51115f6dd10a800a49c17987aa993e369","modified":1547373133127},{"_id":"public/2018/01/15/read-zcczwxl/index.html","hash":"7f2e068ad44bc70cc3b94070ca732a2c199a9c0c","modified":1547373133127},{"_id":"public/2018/01/09/read-pfdsj/index.html","hash":"05bb5ebceaa8d26d40127815f03dd30ebe3e4483","modified":1547373133127},{"_id":"public/2017/12/31/daily-2017-0231/index.html","hash":"7facb847d62ed9bb360def831218362a0eaeef69","modified":1547373133127},{"_id":"public/2017/04/29/hello-world/index.html","hash":"8592850b48c4180d0ffe1d05954cae9bcb929ecc","modified":1547373133127},{"_id":"public/2017/02/21/daily-2017-0221/index.html","hash":"2b2f0aec8bd6d5cb497b59619dddc8657fecb2f3","modified":1547373133127},{"_id":"public/2016/08/01/daily-kaoyan/index.html","hash":"d57fc34f213e952503302dcdaa00d81db0e545ec","modified":1547373133127},{"_id":"public/2016/06/10/journey_318/index.html","hash":"6f2c5440f729c5bea71f9100c3f5116ba839eb44","modified":1547373133127},{"_id":"public/2016/06/01/read-kj/index.html","hash":"28e165dc7dba7e9e8879d29938e2d5eb1844b494","modified":1547373133127},{"_id":"public/2016/05/24/read-trjzdlxz/index.html","hash":"6a1f875c4cbc5acfc81482889e7db5d66162e474","modified":1547373133127},{"_id":"public/2016/04/22/daily-2016-0422/index.html","hash":"d6438b65847322459c881e0e85e8ee5645217b38","modified":1547373133128},{"_id":"public/2016/02/12/daily-2016-0212/index.html","hash":"c77a2ea1598bc5e9e6c2dbf89fe97cae6d77ac33","modified":1547373133128},{"_id":"public/2016/02/03/daily-2016-0203/index.html","hash":"ad083ab74e95f51662b20167c18d809fba9bb90a","modified":1547373133128},{"_id":"public/2015/12/04/daily-2015-1204/index.html","hash":"b0b1f8ab5f9b60e4e1055b441f04ceb8750e7e61","modified":1547373133128},{"_id":"public/2015/08/20/daily-2015-0820/index.html","hash":"b0e891a24dd2c4ff73c67572d6308c202d6704a7","modified":1547373133128},{"_id":"public/2015/07/02/daily-2015-0702/index.html","hash":"05256f64aebca67132d6edd4f0a04c696c91990d","modified":1547373133128},{"_id":"public/2014/10/23/daily-2014-1024/index.html","hash":"5e93e603606fe6239a13d5dd09a5d528a5081920","modified":1547373133128},{"_id":"public/archives/index.html","hash":"d119f90295a4a641eec8ade25cb53f9b46914f64","modified":1547373133128},{"_id":"public/index.html","hash":"f56aff8041fb232865ba3633c29bb560c6c8ce20","modified":1547373133128},{"_id":"public/page/2/index.html","hash":"eab5a56b5b264aada1d246c709ba7a2ba553dfe1","modified":1547373133128},{"_id":"public/page/3/index.html","hash":"9966e4df714edd2dd866b48e0e1984f2d662bb47","modified":1547373133128},{"_id":"public/CNAME","hash":"a3f70605cea4dbe284e5822fbc83632d270c45df","modified":1547373133154},{"_id":"public/images/BLOG-QR.png","hash":"7b8fcc00a3ddb4cc4799e4cb08f1b32d2ad2e909","modified":1547373133154},{"_id":"public/images/code_snippet_dialog.png","hash":"0a230b49e3fc141e3a3e564e89aae791fe43cb8c","modified":1547373133154},{"_id":"public/images/code_snippets.png","hash":"3d783039d0b683ba1268adc779c74f7c6c292f93","modified":1547373133154},{"_id":"public/images/compile_last_one.png","hash":"b028257c5e20782afb2bbc4ace03799aabdcecc9","modified":1547373133154},{"_id":"public/images/compile_last_two.png","hash":"8f1e4a2990ac112d6739f63a8ae41a01b7638325","modified":1547373133154},{"_id":"public/images/kvc_layer_cornerradius.png","hash":"0eff61c7577f63f05f9954337c431b7ab1984240","modified":1547373133154},{"_id":"public/images/csr_alert.png","hash":"7a8daebe61cef3c16566926af87ccebdd7910039","modified":1547373133154},{"_id":"public/images/network_http_commute.png","hash":"f2471056aa1f7b1d22c00bdcd48efcbfefa11f1b","modified":1547373133154},{"_id":"public/images/nsopration_queue_maxium.png","hash":"d9dece317de7656abebb1967816b9b273cf8cfd5","modified":1547373133155},{"_id":"public/images/objc_runloop.jpg","hash":"ee1ceee3a09ec9d9074338d9b7a9552e5101f076","modified":1547373133155},{"_id":"public/images/objc_runloop_mode.png","hash":"f01863ef0a6135c20a9f3af7e13fb19a979ad510","modified":1547373133155},{"_id":"public/images/318/1255460395.jpg","hash":"a61f697c97ddec280998129bf7a094db02e0f004","modified":1547373133155},{"_id":"public/images/318/IMG_0197.JPG","hash":"b10555c7566c8d07e8a056c4c1ac416afb002dc4","modified":1547373133155},{"_id":"public/images/daily/2233356333.jpeg","hash":"3e17b28cb1d2becf6034052de83e61ec4f4a34a6","modified":1547373133155},{"_id":"public/images/daily/3122621194.jpeg","hash":"209ed4bfa525f842988c4732e8713808e9db4777","modified":1547373133155},{"_id":"public/images/daily/2069527412.jpeg","hash":"16b2585774b0cf8b5672b774647851984293010f","modified":1547373133155},{"_id":"public/images/daily/2884524888.jpg","hash":"8742bbb5a589de6d243d6ea208fa6611b6aee21e","modified":1547373133155},{"_id":"public/images/daily/954377808.jpg","hash":"552930029722a0e38b34b973379527c2ffad504d","modified":1547373133155},{"_id":"public/images/read/read_trjzdlxz.jpg","hash":"bef9147535adaf5e6144b3b2972157de25f94846","modified":1547373133155},{"_id":"public/images/read/read_kj.jpg","hash":"7ea7eabe0eaabf712456e0f366ff1265d8ce7073","modified":1547373133156},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1547373133156},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1547373133156},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1547373133156},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1547373133156},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1547373133156},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1547373133156},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1547373133156},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1547373133156},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1547373133156},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1547373133157},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1547373133157},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1547373133157},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1547373133157},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1547373133157},{"_id":"public/img/author.jpg","hash":"acdda175a4f367014d079cfb94f172763f8db3eb","modified":1547373133157},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1547373133157},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1547373133157},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1547373133157},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1547373133157},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1547373133157},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1547373133157},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1547373133157},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1547373133157},{"_id":"public/img/logo.png","hash":"4b8072b842e2466cb1d95d2ea0fe595d0a95e9de","modified":1547373133158},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1547373133158},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1547373133158},{"_id":"public/img/jacman.png","hash":"4b8072b842e2466cb1d95d2ea0fe595d0a95e9de","modified":1547373133158},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1547373133158},{"_id":"public/images/cer_profile_list.png","hash":"a37c103017330890cc291d1721c4a684c57bfd52","modified":1547373133722},{"_id":"public/images/cer_create.png","hash":"08cf989d10d7f4b77164b448790432058e7e84cd","modified":1547373133722},{"_id":"public/images/controller_life_circle.png","hash":"4845e5df2314c3ca6f36b7a816a232da987ab5d5","modified":1547373133723},{"_id":"public/images/csr_keychain.png","hash":"496f56a787f3686a5c228b037a278355bf943e88","modified":1547373133724},{"_id":"public/images/network_commute_progress.png","hash":"d7f63759f0a96f014c9646c29bab7c5e2d2e37ea","modified":1547373133724},{"_id":"public/images/network_three_time_hand.png","hash":"c85601d5794ab5e3f0b660c49fe95db3c1bf109a","modified":1547373133724},{"_id":"public/images/objc_class_relationship.png","hash":"3055663970b4abed229d445ff4f6ee0b411f42be","modified":1547373133724},{"_id":"public/images/webpage_process_after.png","hash":"0b693693abf8d86ecc0274471ce4113589ccf217","modified":1547373133724},{"_id":"public/images/webpage_process_before.png","hash":"65fc00916ca085b606c4d5e85a14134585ea4e1e","modified":1547373133724},{"_id":"public/images/daily/1590392806.jpg","hash":"4c9470711a5fc14e4b516c13ae1af6d083d8d8e8","modified":1547373133724},{"_id":"public/images/daily/613674261.jpeg","hash":"5b05c2db859e43e6663a625e8651feb28ac7826c","modified":1547373133724},{"_id":"public/images/daily/788509444.jpg","hash":"f58f1e3dde25ac53641c71289e6a2c562567c5be","modified":1547373133724},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1547373133724},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1547373133724},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1547373133725},{"_id":"public/img/favicon.ico","hash":"4a75e561ae5a107c125edb20463336745f46299e","modified":1547373133725},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1547373133791},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1547373133791},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1547373133791},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1547373133791},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1547373133791},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1547373133792},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1547373133792},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1547373133792},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1547373133792},{"_id":"public/css/style.css","hash":"04c423b5ef6a5d503fb12ef4df70608b1b18d5df","modified":1547373133792},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1547373133792},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1547373133792},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1547373133792},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1547373133792},{"_id":"public/images/csr_create.png","hash":"5b8905116fe659557a6cbb31b70f62d6cac86e60","modified":1547373133792},{"_id":"public/images/network_encode_principle.png","hash":"141049b4a788214dd24db603b1ae49cdeca457c1","modified":1547373133792},{"_id":"public/images/objc_autoreleasepool.png","hash":"53f4e094483574c70ff2d58abdedf0a234bff93d","modified":1547373133793},{"_id":"public/images/network_theory_model.png","hash":"d50ae0195929362da1f3abe4d182d477ff56f7f3","modified":1547373133793},{"_id":"public/images/318/IMG_0020.JPG","hash":"9944a639030a080265c9036b94e5349defaa000a","modified":1547373133793},{"_id":"public/images/318/IMG_0039.JPG","hash":"71755535ddddb1e02f2268dfb9a48811712eb83a","modified":1547373133793},{"_id":"public/images/cer_export_p12.png","hash":"bcf31fb251e2e3013707f61db13016a5a03cfc5c","modified":1547373133827},{"_id":"public/images/gcd_and_nop_relationship.png","hash":"77d4ee498c04713fe471f45f47d1a6166511c0c6","modified":1547373133827},{"_id":"public/images/network_class_struct.png","hash":"61d2aa5d0f10eed79655d64d22a2e975e7c93ec2","modified":1547373133827},{"_id":"public/images/nsopration_add_to_queue.png","hash":"1f8d130f0f266cffd9a689cc60c08d4f722ed39d","modified":1547373133827},{"_id":"public/images/uitableviewcell_optimize.png","hash":"25a4d0d6c6adc76ca9f8415e218da50d7ca758c3","modified":1547373133828},{"_id":"public/images/318/507311534.png","hash":"ad90f89374a8cc91759140f2d5f6261c9c3f08ce","modified":1547373133828},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1547373133829},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1547373133829},{"_id":"public/images/318/DraggedImage-23.png","hash":"af738d5413460fd178f5f3673f2bd60327401f60","modified":1547373133857},{"_id":"public/images/318/DraggedImage-11.png","hash":"74eacf430106c1ce1606eed7ecafc366b655b642","modified":1547373133891},{"_id":"public/images/318/DraggedImage-19.png","hash":"9f09c97831797e8d96e39d43921fa1668d6fa4e0","modified":1547373133891},{"_id":"public/images/318/DraggedImage-24.png","hash":"74183f691c5760f0e8ba30eb99492c150ed6a7de","modified":1547373133891},{"_id":"public/images/318/DraggedImage-7.png","hash":"66a5f257378425a10ced9fd4ca97b12252a1dc67","modified":1547373133891},{"_id":"public/images/318/IMG_0184.JPG","hash":"2a4abb358707ca74f6ac98a09ca232cc4ce0beca","modified":1547373133891},{"_id":"public/images/read/read_zcczwxl.JPG","hash":"b7fddfcf47698e6bb8fef963fb8b97c705b74e89","modified":1547373133892},{"_id":"public/images/network_real_model.png","hash":"125b65a19d63ecfcd9ef16010a488738065910d7","modified":1547373133981},{"_id":"public/images/318/DraggedImage-10.png","hash":"6808756ed3a18380350a339682f12b5adea88a37","modified":1547373133981},{"_id":"public/images/318/DraggedImage-14.png","hash":"f0a8fb75b1700c16746233e02ca23bcea32b32ad","modified":1547373133983},{"_id":"public/images/318/DraggedImage-28.png","hash":"52c0cb3df427b0c2a04b049e8bd39a1651c4c834","modified":1547373133984},{"_id":"public/images/318/DraggedImage-55.png","hash":"7a5bcbcb225485c6c62da757f220cdf3487ee178","modified":1547373133985},{"_id":"public/images/318/IMG_0046.JPG","hash":"503ad8d353bdb517fc3502d191c012370554a0b5","modified":1547373133987},{"_id":"public/images/daily/824027791-2.png","hash":"23ad83e5374aef2f0c9d9566d8f2efea2084592d","modified":1547373133988},{"_id":"public/images/318/2768809826.png","hash":"a042b6c8ee01c3dcf2d3f6f80074f73b31d70ca4","modified":1547373134020},{"_id":"public/images/318/DraggedImage-15.png","hash":"728929049202ef1d733fb2b170736e15955b7403","modified":1547373134020},{"_id":"public/images/318/DraggedImage-33.png","hash":"8c8014bb1dbed0340a47f44b3e7dd34defbe199c","modified":1547373134021},{"_id":"public/images/318/DraggedImage-61.png","hash":"6a91fb84d6e29ee5daddcc41de54823db4dd6f90","modified":1547373134022},{"_id":"public/images/318/DraggedImage-5.png","hash":"31f57345345c32ead79437444d8a886fbc4cfdc5","modified":1547373134022},{"_id":"public/images/318/DraggedImage-62.png","hash":"05da860477295d2441321893826504ce20bcc2d9","modified":1547373134023},{"_id":"public/images/318/DraggedImage-76.png","hash":"4551606d8f90e57502c0f810bf36a6310d12eda3","modified":1547373134024},{"_id":"public/images/318/DraggedImage-82.png","hash":"1d8d0be7fd3a32412aac837146a957fcd6fb0531","modified":1547373134024},{"_id":"public/images/318/DraggedImage-84.png","hash":"457a85d1de56da795783cec4966fc187c7aa8a80","modified":1547373134025},{"_id":"public/images/318/DraggedImage-13.png","hash":"d3e6954725ddb2de191748b623d3a271fc6768c8","modified":1547373134056},{"_id":"public/images/318/DraggedImage-16.png","hash":"035aa5a67f18ab4f47471f2b3efbaccbf35469ac","modified":1547373134056},{"_id":"public/images/318/DraggedImage-31.png","hash":"ecce7f407c86e08ded134e1b646e24ecb7fbeb50","modified":1547373134057},{"_id":"public/images/318/DraggedImage-29.png","hash":"f1cff3e702e299494dc59fba953da19d3bd89353","modified":1547373134057},{"_id":"public/images/318/DraggedImage-66.png","hash":"15b066d63822c85f15689549594cb7a1c29e1d7a","modified":1547373134058},{"_id":"public/images/318/DraggedImage-42.png","hash":"e3b6262b6b95e1ae23ca241beffbecb0132cecb4","modified":1547373134061},{"_id":"public/images/318/DraggedImage-73.png","hash":"b320fad17f12d945ea3dee879b70b5e4c77598fd","modified":1547373134062},{"_id":"public/images/318/DraggedImage-85.png","hash":"4f99130fa1769c47544fb699d45bf09b5b764055","modified":1547373134062},{"_id":"public/images/318/DraggedImage.png","hash":"ad7e95ee9db7685784891eac9c76986db569c708","modified":1547373134063},{"_id":"public/images/318/DraggedImage-86.png","hash":"c3fd838aa886e6440f70290b0d95d9ec74e1f508","modified":1547373134064},{"_id":"public/images/318/DraggedImage-88.png","hash":"06208c0569e0f8952a0f252443ba6a04cbfa3ebb","modified":1547373134065},{"_id":"public/images/daily/4245137053.png","hash":"97135273cf1436b04830f80b0e54fae3baadf743","modified":1547373134065},{"_id":"public/images/318/DraggedImage-17.png","hash":"2fdac033f71e52365c0af04e22bf2722f2aedbcb","modified":1547373134085},{"_id":"public/images/318/DraggedImage-20.png","hash":"11b126734b6eaa0e97a5dbafb85e375b79b5de55","modified":1547373134085},{"_id":"public/images/318/DraggedImage-25.png","hash":"e9782c494266a37c2e4eba846da9b9701253c970","modified":1547373134088},{"_id":"public/images/318/DraggedImage-32.png","hash":"d6ec1cc5114b2286074fe8284f82890e4a58b273","modified":1547373134090},{"_id":"public/images/318/DraggedImage-36.png","hash":"1ab826f774eecf715f4e3ad76e6d27feed9d94e1","modified":1547373134091},{"_id":"public/images/318/DraggedImage-45.png","hash":"ca89fa8886e1f610f8b7327e59f639b19cf5af5c","modified":1547373134092},{"_id":"public/images/318/DraggedImage-50.png","hash":"ddc11f443bfa96f695792f2aff73ac5c0f178c63","modified":1547373134093},{"_id":"public/images/318/DraggedImage-51.png","hash":"92443199c337d8327c402bfde1c2d3bfe6df0d17","modified":1547373134094},{"_id":"public/images/318/DraggedImage-58.png","hash":"e9017b4e723eab0b0f327a5a3c5485acd65ace06","modified":1547373134095},{"_id":"public/images/318/DraggedImage-43.png","hash":"fea1a409bc25834537774ac62a441b9d8c4ff5ea","modified":1547373134096},{"_id":"public/images/318/DraggedImage-69.png","hash":"59d3120d3fe2ee9e19552a67e2605f67988f96f2","modified":1547373134097},{"_id":"public/images/318/DraggedImage-74.png","hash":"d4629e19d8cd8bdde3875b1f010800d8f420a4f2","modified":1547373134098},{"_id":"public/images/318/DraggedImage-59.png","hash":"fd1899c852751354354f961a430f536103a07839","modified":1547373134099},{"_id":"public/images/318/DraggedImage-75.png","hash":"46ec1f6cec6ef83f4a051410bd803be6570f2ada","modified":1547373134100},{"_id":"public/images/318/DraggedImage-63.png","hash":"6230b1f69218d3b8d395891f4a780952b68002ce","modified":1547373134100},{"_id":"public/images/daily/750990835.png","hash":"433cbdd2c1fc8fe208a7e73e2fe9034043a56f95","modified":1547373134101},{"_id":"public/images/318/DraggedImage-1.png","hash":"e1ae9defba972905a7f976ccbbbe274184a49988","modified":1547373134218},{"_id":"public/images/318/805238010.png","hash":"aa64473f6a451952a8923cb19acd1679945d7071","modified":1547373134218},{"_id":"public/images/318/DraggedImage-35.png","hash":"f44a63b78530f92c0d188061be189fc6483861f0","modified":1547373134219},{"_id":"public/images/318/DraggedImage-2.png","hash":"bd5aa5eba314601b3c895b21748d3be3325b8f41","modified":1547373134220},{"_id":"public/images/318/DraggedImage-34.png","hash":"295bfb2fae53aae7d9c832909a7f2bd52a226bcc","modified":1547373134221},{"_id":"public/images/318/DraggedImage-38.png","hash":"0e3e3e46a5797a7228df9fb276c8b999f368cbf7","modified":1547373134222},{"_id":"public/images/318/DraggedImage-6.png","hash":"0d622657f02490bae82430b7d72eb4bc1c38bd85","modified":1547373134223},{"_id":"public/images/318/DraggedImage-60.png","hash":"a7967094c69d60d7a3ea1f86c213f2707602a652","modified":1547373134224},{"_id":"public/images/318/DraggedImage-81.png","hash":"9c9ba0efa8394f22ab42d32bf8fd587ecf738620","modified":1547373134225},{"_id":"public/images/318/DraggedImage-46.png","hash":"818bb3abbac4138b28b815fd67b950d997870319","modified":1547373134226},{"_id":"public/images/318/DraggedImage-8.png","hash":"808e3d72e7d6473f193965abfda72e1165838d9d","modified":1547373134227},{"_id":"public/images/318/DraggedImage-3.png","hash":"81bc059921320b91e0619f5b2c1c10bcef8d70a6","modified":1547373134253},{"_id":"public/images/318/DraggedImage-37.png","hash":"0c5eab3962f9f4c622156489035a52c6346ebdd1","modified":1547373134254},{"_id":"public/images/318/DraggedImage-49.png","hash":"7830582db6b097011a44e43baabdbde08f6c41fe","modified":1547373134255},{"_id":"public/images/318/DraggedImage-41.png","hash":"9ddd676916ef377d249add7c0b76a122c439de1a","modified":1547373134256},{"_id":"public/images/318/DraggedImage-21.png","hash":"95378616de101a1a60f68fb85eaa23ba9e45540e","modified":1547373134257},{"_id":"public/images/318/DraggedImage-9.png","hash":"f7f3fbdcf71b37cc162db7f6a5d2b4acd6684f5d","modified":1547373134259},{"_id":"public/images/318/DraggedImage-48.png","hash":"ae70f4101448774a28d610b230162b3692e3d22f","modified":1547373134260},{"_id":"public/images/318/DraggedImage-47.png","hash":"ae70f4101448774a28d610b230162b3692e3d22f","modified":1547373134261},{"_id":"public/images/318/DraggedImage-67.png","hash":"2dac980981d3bf0c344255edf9406142fc875f25","modified":1547373134264},{"_id":"public/images/318/DraggedImage-87.png","hash":"1e8051873581523bd70ae0b43827bbc7cde1b9e4","modified":1547373134267},{"_id":"public/images/318/DraggedImage-30.png","hash":"de7b1e8479a1ea00baa8bc01762b716e1870f40a","modified":1547373134304},{"_id":"public/images/318/DraggedImage-12.png","hash":"25af89b2110c03b096e944ad862dd31dcf0c8c76","modified":1547373134304},{"_id":"public/images/318/DraggedImage-26.png","hash":"c856bab7d4ba977cefdde1458aea1410145f1be9","modified":1547373134305},{"_id":"public/images/318/DraggedImage-4.png","hash":"45ffacf16b6c670ac528c7aa8bec10bb3960e97f","modified":1547373134306},{"_id":"public/images/318/DraggedImage-44.png","hash":"824959d5a7dd235579effe3c936295ef71cf685b","modified":1547373134307},{"_id":"public/images/318/DraggedImage-53.png","hash":"1183b02d93506217f7e84919e4fbcf0f2463aa13","modified":1547373134309},{"_id":"public/images/318/DraggedImage-72.png","hash":"88472fba385d26095b5a82bd659d0e18491618d6","modified":1547373134310},{"_id":"public/images/318/DraggedImage-54.png","hash":"c4e74155dba577bad4875eccb8fe07ccc8b60578","modified":1547373134326},{"_id":"public/images/318/DraggedImage-80.png","hash":"33382d088608aec99e046e37716b8817a5105f7e","modified":1547373134330},{"_id":"public/images/318/DraggedImage-64.png","hash":"422ef18ad43165518a0667f42ba7fa446fe922dc","modified":1547373134351},{"_id":"public/images/318/DraggedImage-83.png","hash":"f2e5384818cacaa47e5f03939678d6e96d1611c5","modified":1547373134354},{"_id":"public/images/318/DraggedImage-79.png","hash":"6b63d38544ca75da521289ab6eeb31642d96cdaa","modified":1547373134358},{"_id":"public/images/linearmaths_det.png","hash":"fea61499f50a619de591ac39cd280907242df6b5","modified":1547373134437},{"_id":"public/images/318/DraggedImage-22.png","hash":"8f2cc4e99152789d64adf5203db69b8f02d65c6d","modified":1547373134437},{"_id":"public/images/318/DraggedImage-77.png","hash":"06225a4dae3d2f7cfc2a4be4bd6f61e23c34f0c3","modified":1547373134444},{"_id":"public/images/318/DraggedImage-65.png","hash":"648d5317d93e59f336c4787604ebc9fc8f12a435","modified":1547373134445},{"_id":"public/images/318/DraggedImage-78.png","hash":"7c8895058ed593a881294c107c6ced87bb45f12a","modified":1547373134447},{"_id":"public/images/linearmaths_equations.png","hash":"9bdd77e79d660d1ce4702590f9fe86293903906b","modified":1547373134456},{"_id":"public/images/318/DraggedImage-71.png","hash":"978833b70c0a6379ea85a2f5d4c4d36e3845dcde","modified":1547373134456},{"_id":"public/images/318/DraggedImage-18.png","hash":"bbbe5b8d9497ae17fc8d486a5072c07bc8db0d7a","modified":1547373134458},{"_id":"public/images/network_http_and_https_diff.png","hash":"5fe5329fcecd72e2f519c075f188a69445f21153","modified":1547373134465},{"_id":"public/images/318/DraggedImage-56.png","hash":"ac747c684721ac6bc7b38f86c4dc0544f4cb8de4","modified":1547373134465},{"_id":"public/images/318/DraggedImage-68.png","hash":"3aa2871e21a89b0956d4cf4c7c155f84c26dc273","modified":1547373134466},{"_id":"public/images/318/DraggedImage-70.png","hash":"54b600f0339d92716edf427f939a4361198272c7","modified":1547373134481},{"_id":"public/images/318/DraggedImage-52.png","hash":"9c043d8a0ca006da4c00eb7ad70cf4520e242567","modified":1547373134497},{"_id":"public/images/318/DraggedImage-27.png","hash":"149b30328bff26db628b8a0243b2ceb4fb5d74b7","modified":1547373134497},{"_id":"public/images/318/DraggedImage-57.png","hash":"228a803fbb708f21222301aef301f1dbbd2de988","modified":1547373134501},{"_id":"public/images/318/DraggedImage-40.png","hash":"1a7e7886119bd9379fc4dc4e691452f1afa327e6","modified":1547373134505},{"_id":"public/images/linearmaths_quadratic.png","hash":"63038e9928a4e15403ac6a4552f9ea27c5e598af","modified":1547373134511},{"_id":"public/images/318/DraggedImage-39.png","hash":"3eba1f25a11e659ba98d9c2a6f02b0e740a969f7","modified":1547373134514},{"_id":"public/images/linearmaths_eigenvalue.png","hash":"3d06ebfd1b538d0acb5d7a71dfc292f3a8364531","modified":1547373134521},{"_id":"public/images/linearmaths_matrix.png","hash":"8330ba680cb26b82a211534cbc0b5694269c0526","modified":1547373134521},{"_id":"public/images/318/IMG_0058.JPG","hash":"f01ace25a075a297600a39a52f60fabc01850286","modified":1547373134536},{"_id":"public/images/read/read_pfdsj.JPG","hash":"38f75c572f17d0b97dcbe0d870cb5562bd429a4a","modified":1547373134536},{"_id":"public/images/linearmaths_vector.png","hash":"7e9d630e848ada8859d217c348273d2811f85fc3","modified":1547373134545},{"_id":"public/images/318/IMG_0170.JPG","hash":"7e7863e3cc7c91d892253e86beb26ebb98c95a58","modified":1547373134558},{"_id":"public/images/318/IMG_0157.JPG","hash":"6a07c4e591ad436ad70d3c47901758e626c16529","modified":1547373134568},{"_id":"public/images/318/IMG_0097.JPG","hash":"b6b38f0f938ff936de066686cf05af1f902698e6","modified":1547373134578},{"_id":"public/images/318/IMG_0078.JPG","hash":"0a8a4979d6cb7e56121a542dd7f0ec2738745130","modified":1547373134582},{"_id":"public/images/318/IMG_0200.JPG","hash":"af3b996a9e9ed5fdac8e24c585c97eaa41398371","modified":1547373134589}],"Category":[{"name":"Daily","_id":"cjquq0d1u0004l1fqok6nqd7g"},{"name":"iOS","_id":"cjquq0d2f000ul1fq8p8sn7gt"},{"name":"Objc","parent":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d2m001al1fqpnrr1tby"},{"name":"Readed","_id":"cjquq0d35002dl1fqb6ke03af"},{"name":"Xcode","_id":"cjquq0d3f0030l1fqlfonqeb9"},{"name":"Jurney","_id":"cjquq0d3h003cl1fqdle6axf9"}],"Data":[],"Page":[{"layout":"false","comments":0,"_content":"<html>\n<head>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://techbird.me\" homePageName=\"返回主页\"></script>\n</body>\n</html>\n","source":"404.md","raw":"layout: false \ncomments: false\npermalink: /404.html\n---\n<html>\n<head>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"https://techbird.me\" homePageName=\"返回主页\"></script>\n</body>\n</html>\n","date":"2018-08-21T04:23:37.192Z","updated":"2018-08-21T04:23:37.192Z","path":"/404.html","title":"","_id":"cjquq0cyt0000l1fqljux8mky","content":"<html><br><head><br></head><br><body><br><script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://techbird.me\" homepagename=\"返回主页\"></script><br></body><br></html>\n","site":{"data":{}},"excerpt":"","more":"<html><br><head><br></head><br><body><br><script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"https://techbird.me\" homepagename=\"返回主页\"></script><br></body><br></html>\n"},{"title":"关于博主","date":"2018-04-23T02:15:17.000Z","_content":"\n\n## 简介\n\n``` swift\nProgrammer{\n    name = \"仇邓强\"\n    gender = \"Male\"\n    born = \"1994\"\n    hobby = \"Read，Run，Code\"\n    skills = \"iOS，Android\"\n}\n```\n\n## 更多信息\n\n``` swift\nextention{\n    description = \"\n    欢迎来到我的站 :)\n    也许你在这里能读到的\n    只是中国千千万工科生中最普通的一员\n    在面对万千事物时\n    所能写下的茫然和转化\n    只想多年以后\n    读起年青时写下的憋足文字时\n    是别样的思绪万千\n    只因这里真实的记录了我的生活，我的成长...\n    \"\n}\n```\n\n","source":"about/index.md","raw":"---\ntitle: 关于博主\ndate: 2018-04-23 10:15:17\n---\n\n\n## 简介\n\n``` swift\nProgrammer{\n    name = \"仇邓强\"\n    gender = \"Male\"\n    born = \"1994\"\n    hobby = \"Read，Run，Code\"\n    skills = \"iOS，Android\"\n}\n```\n\n## 更多信息\n\n``` swift\nextention{\n    description = \"\n    欢迎来到我的站 :)\n    也许你在这里能读到的\n    只是中国千千万工科生中最普通的一员\n    在面对万千事物时\n    所能写下的茫然和转化\n    只想多年以后\n    读起年青时写下的憋足文字时\n    是别样的思绪万千\n    只因这里真实的记录了我的生活，我的成长...\n    \"\n}\n```\n\n","updated":"2018-08-21T04:23:37.206Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjquq0d1r0002l1fqeyuommpu","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Programmer</span>&#123;</span><br><span class=\"line\">    name = <span class=\"string\">\"仇邓强\"</span></span><br><span class=\"line\">    gender = <span class=\"string\">\"Male\"</span></span><br><span class=\"line\">    born = <span class=\"string\">\"1994\"</span></span><br><span class=\"line\">    hobby = <span class=\"string\">\"Read，Run，Code\"</span></span><br><span class=\"line\">    skills = <span class=\"string\">\"iOS，Android\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更多信息\"><a href=\"#更多信息\" class=\"headerlink\" title=\"更多信息\"></a>更多信息</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extention&#123;</span><br><span class=\"line\">    description = <span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    欢迎来到我的站 :)</span></span><br><span class=\"line\"><span class=\"string\">    也许你在这里能读到的</span></span><br><span class=\"line\"><span class=\"string\">    只是中国千千万工科生中最普通的一员</span></span><br><span class=\"line\"><span class=\"string\">    在面对万千事物时</span></span><br><span class=\"line\"><span class=\"string\">    所能写下的茫然和转化</span></span><br><span class=\"line\"><span class=\"string\">    只想多年以后</span></span><br><span class=\"line\"><span class=\"string\">    读起年青时写下的憋足文字时</span></span><br><span class=\"line\"><span class=\"string\">    是别样的思绪万千</span></span><br><span class=\"line\"><span class=\"string\">    只因这里真实的记录了我的生活，我的成长...</span></span><br><span class=\"line\"><span class=\"string\">    \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Programmer</span>&#123;</span><br><span class=\"line\">    name = <span class=\"string\">\"仇邓强\"</span></span><br><span class=\"line\">    gender = <span class=\"string\">\"Male\"</span></span><br><span class=\"line\">    born = <span class=\"string\">\"1994\"</span></span><br><span class=\"line\">    hobby = <span class=\"string\">\"Read，Run，Code\"</span></span><br><span class=\"line\">    skills = <span class=\"string\">\"iOS，Android\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"更多信息\"><a href=\"#更多信息\" class=\"headerlink\" title=\"更多信息\"></a>更多信息</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extention&#123;</span><br><span class=\"line\">    description = <span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">    欢迎来到我的站 :)</span></span><br><span class=\"line\"><span class=\"string\">    也许你在这里能读到的</span></span><br><span class=\"line\"><span class=\"string\">    只是中国千千万工科生中最普通的一员</span></span><br><span class=\"line\"><span class=\"string\">    在面对万千事物时</span></span><br><span class=\"line\"><span class=\"string\">    所能写下的茫然和转化</span></span><br><span class=\"line\"><span class=\"string\">    只想多年以后</span></span><br><span class=\"line\"><span class=\"string\">    读起年青时写下的憋足文字时</span></span><br><span class=\"line\"><span class=\"string\">    是别样的思绪万千</span></span><br><span class=\"line\"><span class=\"string\">    只因这里真实的记录了我的生活，我的成长...</span></span><br><span class=\"line\"><span class=\"string\">    \"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"tags","date":"2018-04-26T14:44:22.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-26 22:44:22\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-08-21T04:23:37.207Z","path":"tags/index.html","layout":"page","_id":"cjquq0d4n005vl1fqw3bh1199","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# blog-images\n用于存放博客图片\n","source":"images/README.md","raw":"# blog-images\n用于存放博客图片\n","date":"2019-01-13T05:00:19.500Z","updated":"2019-01-13T04:25:03.996Z","path":"images/README.html","title":"","comments":1,"layout":"page","_id":"cjquq0d4o005wl1fqiik9qet7","content":"<h1 id=\"blog-images\"><a href=\"#blog-images\" class=\"headerlink\" title=\"blog-images\"></a>blog-images</h1><p>用于存放博客图片</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"blog-images\"><a href=\"#blog-images\" class=\"headerlink\" title=\"blog-images\"></a>blog-images</h1><p>用于存放博客图片</p>\n"}],"Post":[{"title":"纪念北漂一周年","date":"2014-10-23T02:01:47.000Z","_content":"\n\n## 纪念北漂一周年\n\n![](/images/daily/4245137053.png)\n> 生活就是日子叠着日子，问题叠着问题。到今天，北漂整整一年了。\n\n当身上的衣裳日渐厚实，雾霾再次弥漫整个北京城的时候，在北京的第二个冬天就要来了，新奇的不再是西二旗那二里地的长长队，和加班到很晚地铁窗外那霓虹的城，我会释怀的笑一笑，跟自己说，这就是北京，这是自己选的路。\n然后日子叠着日子，继续然后。\n\n很想念潍坊，想念学校的日子，但又觉得那是上辈子的事一样。人就是这样，自己就这样。\n\n成长就是想法越来越少，对身边的小事情理解越来越多，会坚持做一些事儿，能看开一些得失，年轻时候总是要吃些苦，就像我们总说以后会感谢现在拼命的自己，是啊，生存不就是这样么。\n\n生活总是不能一成不变，和经历一样，不抛弃，不放弃，继续走，做一棵树，枝枝蔓蔓。\n\n加班之余，还是要抽出时间，想想写写，翻翻一年前的照片，回忆回忆这两年。\n不再那么想证明自己，不再那么想活给谁看，这两年把自己活得太干了，一点水分都没有，像一袋干水泥，整个人搓罢挫罢就能当导火索，要感谢这两年，能在肩上加些沉重的东西。明白了啥叫平常心平常心。\n\n饭要一口一口吃，事得一件一件办，只要一天比一天好，这不就是希望么。\n记得来时的路，带着今天的经历和明天的希望，不忘初心，就能得始终。\n\n后记: 写给自己，写给一起走过这一年的三个兄弟。\n2014/10/23 北京","source":"_posts/daily-2014-1024.md","raw":"---\ntitle: 纪念北漂一周年\ndate: 2014-10-23 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n\n## 纪念北漂一周年\n\n![](/images/daily/4245137053.png)\n> 生活就是日子叠着日子，问题叠着问题。到今天，北漂整整一年了。\n\n当身上的衣裳日渐厚实，雾霾再次弥漫整个北京城的时候，在北京的第二个冬天就要来了，新奇的不再是西二旗那二里地的长长队，和加班到很晚地铁窗外那霓虹的城，我会释怀的笑一笑，跟自己说，这就是北京，这是自己选的路。\n然后日子叠着日子，继续然后。\n\n很想念潍坊，想念学校的日子，但又觉得那是上辈子的事一样。人就是这样，自己就这样。\n\n成长就是想法越来越少，对身边的小事情理解越来越多，会坚持做一些事儿，能看开一些得失，年轻时候总是要吃些苦，就像我们总说以后会感谢现在拼命的自己，是啊，生存不就是这样么。\n\n生活总是不能一成不变，和经历一样，不抛弃，不放弃，继续走，做一棵树，枝枝蔓蔓。\n\n加班之余，还是要抽出时间，想想写写，翻翻一年前的照片，回忆回忆这两年。\n不再那么想证明自己，不再那么想活给谁看，这两年把自己活得太干了，一点水分都没有，像一袋干水泥，整个人搓罢挫罢就能当导火索，要感谢这两年，能在肩上加些沉重的东西。明白了啥叫平常心平常心。\n\n饭要一口一口吃，事得一件一件办，只要一天比一天好，这不就是希望么。\n记得来时的路，带着今天的经历和明天的希望，不忘初心，就能得始终。\n\n后记: 写给自己，写给一起走过这一年的三个兄弟。\n2014/10/23 北京","slug":"daily-2014-1024","published":1,"updated":"2019-01-13T09:49:34.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d1n0001l1fqgimzw2u3","content":"<h2 id=\"纪念北漂一周年\"><a href=\"#纪念北漂一周年\" class=\"headerlink\" title=\"纪念北漂一周年\"></a>纪念北漂一周年</h2><p><img src=\"/images/daily/4245137053.png\" alt=\"\"></p>\n<blockquote>\n<p>生活就是日子叠着日子，问题叠着问题。到今天，北漂整整一年了。</p>\n</blockquote>\n<p>当身上的衣裳日渐厚实，雾霾再次弥漫整个北京城的时候，在北京的第二个冬天就要来了，新奇的不再是西二旗那二里地的长长队，和加班到很晚地铁窗外那霓虹的城，我会释怀的笑一笑，跟自己说，这就是北京，这是自己选的路。<br>然后日子叠着日子，继续然后。</p>\n<p>很想念潍坊，想念学校的日子，但又觉得那是上辈子的事一样。人就是这样，自己就这样。</p>\n<p>成长就是想法越来越少，对身边的小事情理解越来越多，会坚持做一些事儿，能看开一些得失，年轻时候总是要吃些苦，就像我们总说以后会感谢现在拼命的自己，是啊，生存不就是这样么。</p>\n<p>生活总是不能一成不变，和经历一样，不抛弃，不放弃，继续走，做一棵树，枝枝蔓蔓。</p>\n<p>加班之余，还是要抽出时间，想想写写，翻翻一年前的照片，回忆回忆这两年。<br>不再那么想证明自己，不再那么想活给谁看，这两年把自己活得太干了，一点水分都没有，像一袋干水泥，整个人搓罢挫罢就能当导火索，要感谢这两年，能在肩上加些沉重的东西。明白了啥叫平常心平常心。</p>\n<p>饭要一口一口吃，事得一件一件办，只要一天比一天好，这不就是希望么。<br>记得来时的路，带着今天的经历和明天的希望，不忘初心，就能得始终。</p>\n<p>后记: 写给自己，写给一起走过这一年的三个兄弟。<br>2014/10/23 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"纪念北漂一周年\"><a href=\"#纪念北漂一周年\" class=\"headerlink\" title=\"纪念北漂一周年\"></a>纪念北漂一周年</h2><p><img src=\"/images/daily/4245137053.png\" alt=\"\"></p>\n<blockquote>\n<p>生活就是日子叠着日子，问题叠着问题。到今天，北漂整整一年了。</p>\n</blockquote>\n<p>当身上的衣裳日渐厚实，雾霾再次弥漫整个北京城的时候，在北京的第二个冬天就要来了，新奇的不再是西二旗那二里地的长长队，和加班到很晚地铁窗外那霓虹的城，我会释怀的笑一笑，跟自己说，这就是北京，这是自己选的路。<br>然后日子叠着日子，继续然后。</p>\n<p>很想念潍坊，想念学校的日子，但又觉得那是上辈子的事一样。人就是这样，自己就这样。</p>\n<p>成长就是想法越来越少，对身边的小事情理解越来越多，会坚持做一些事儿，能看开一些得失，年轻时候总是要吃些苦，就像我们总说以后会感谢现在拼命的自己，是啊，生存不就是这样么。</p>\n<p>生活总是不能一成不变，和经历一样，不抛弃，不放弃，继续走，做一棵树，枝枝蔓蔓。</p>\n<p>加班之余，还是要抽出时间，想想写写，翻翻一年前的照片，回忆回忆这两年。<br>不再那么想证明自己，不再那么想活给谁看，这两年把自己活得太干了，一点水分都没有，像一袋干水泥，整个人搓罢挫罢就能当导火索，要感谢这两年，能在肩上加些沉重的东西。明白了啥叫平常心平常心。</p>\n<p>饭要一口一口吃，事得一件一件办，只要一天比一天好，这不就是希望么。<br>记得来时的路，带着今天的经历和明天的希望，不忘初心，就能得始终。</p>\n<p>后记: 写给自己，写给一起走过这一年的三个兄弟。<br>2014/10/23 北京</p>\n"},{"title":"工体东路的日子","date":"2015-07-02T02:01:47.000Z","_content":"\n## 工体东路的日子\n\n我会在夏日一小时的午休后，从空军干休所的小院走至大门外的林荫道，  \n林荫道旁有一排黑色的围栏，大概一米多高，我会坐在围栏上惬意的抽根烟，  \n身后是三里屯的酒吧街，这感觉像是我大学时光的篮球场，  \n球场旁边也有遮天的林荫道，和小伙伴打球累了以后，  \n就会坐在林荫道旁看过往裙摆，坐到不想坐，坐到天蒙蒙黑，  \n起来拍拍屁股上的灰尘，搭着肩膀，  \n谈论着谁家女孩儿，去爱吃的二号食堂。\n\n2015/07/02 北京","source":"_posts/daily-2015-0702.md","raw":"---\ntitle: 工体东路的日子\ndate: 2015-07-02 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 工体东路的日子\n\n我会在夏日一小时的午休后，从空军干休所的小院走至大门外的林荫道，  \n林荫道旁有一排黑色的围栏，大概一米多高，我会坐在围栏上惬意的抽根烟，  \n身后是三里屯的酒吧街，这感觉像是我大学时光的篮球场，  \n球场旁边也有遮天的林荫道，和小伙伴打球累了以后，  \n就会坐在林荫道旁看过往裙摆，坐到不想坐，坐到天蒙蒙黑，  \n起来拍拍屁股上的灰尘，搭着肩膀，  \n谈论着谁家女孩儿，去爱吃的二号食堂。\n\n2015/07/02 北京","slug":"daily-2015-0702","published":1,"updated":"2019-01-13T09:49:35.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d1s0003l1fqzuyhnn8d","content":"<h2 id=\"工体东路的日子\"><a href=\"#工体东路的日子\" class=\"headerlink\" title=\"工体东路的日子\"></a>工体东路的日子</h2><p>我会在夏日一小时的午休后，从空军干休所的小院走至大门外的林荫道，<br>林荫道旁有一排黑色的围栏，大概一米多高，我会坐在围栏上惬意的抽根烟，<br>身后是三里屯的酒吧街，这感觉像是我大学时光的篮球场，<br>球场旁边也有遮天的林荫道，和小伙伴打球累了以后，<br>就会坐在林荫道旁看过往裙摆，坐到不想坐，坐到天蒙蒙黑，<br>起来拍拍屁股上的灰尘，搭着肩膀，<br>谈论着谁家女孩儿，去爱吃的二号食堂。</p>\n<p>2015/07/02 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工体东路的日子\"><a href=\"#工体东路的日子\" class=\"headerlink\" title=\"工体东路的日子\"></a>工体东路的日子</h2><p>我会在夏日一小时的午休后，从空军干休所的小院走至大门外的林荫道，<br>林荫道旁有一排黑色的围栏，大概一米多高，我会坐在围栏上惬意的抽根烟，<br>身后是三里屯的酒吧街，这感觉像是我大学时光的篮球场，<br>球场旁边也有遮天的林荫道，和小伙伴打球累了以后，<br>就会坐在林荫道旁看过往裙摆，坐到不想坐，坐到天蒙蒙黑，<br>起来拍拍屁股上的灰尘，搭着肩膀，<br>谈论着谁家女孩儿，去爱吃的二号食堂。</p>\n<p>2015/07/02 北京</p>\n"},{"title":"记天津塘沽爆炸","date":"2015-08-20T02:01:47.000Z","_content":"\n## 记天津塘沽爆炸\n\n天津塘沽爆炸，到现在没去问责失职的政府部门和官员，却立即开启了感动中国模式，舆论导向几乎全部转向牺牲的消防战士身上，消防战士固然是伟大的值得我们敬仰的，可是新闻媒体作为政府的喉舌，故意去转移社会的舆论导向，目的是让人民生活在感动之中，让人们忘却去问责那些应该承担这起事故责任的政府部门和官员，让年轻的消防战士去送死的指挥部门，让人们失去最后的一点愤怒，政府如果这么愚弄人民，最终只会失去民心。\n\n2015/8/20 北京","source":"_posts/daily-2015-0820.md","raw":"---\ntitle: 记天津塘沽爆炸\ndate: 2015-08-20 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 记天津塘沽爆炸\n\n天津塘沽爆炸，到现在没去问责失职的政府部门和官员，却立即开启了感动中国模式，舆论导向几乎全部转向牺牲的消防战士身上，消防战士固然是伟大的值得我们敬仰的，可是新闻媒体作为政府的喉舌，故意去转移社会的舆论导向，目的是让人民生活在感动之中，让人们忘却去问责那些应该承担这起事故责任的政府部门和官员，让年轻的消防战士去送死的指挥部门，让人们失去最后的一点愤怒，政府如果这么愚弄人民，最终只会失去民心。\n\n2015/8/20 北京","slug":"daily-2015-0820","published":1,"updated":"2019-01-13T09:49:36.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d1x0006l1fqdi7885do","content":"<h2 id=\"记天津塘沽爆炸\"><a href=\"#记天津塘沽爆炸\" class=\"headerlink\" title=\"记天津塘沽爆炸\"></a>记天津塘沽爆炸</h2><p>天津塘沽爆炸，到现在没去问责失职的政府部门和官员，却立即开启了感动中国模式，舆论导向几乎全部转向牺牲的消防战士身上，消防战士固然是伟大的值得我们敬仰的，可是新闻媒体作为政府的喉舌，故意去转移社会的舆论导向，目的是让人民生活在感动之中，让人们忘却去问责那些应该承担这起事故责任的政府部门和官员，让年轻的消防战士去送死的指挥部门，让人们失去最后的一点愤怒，政府如果这么愚弄人民，最终只会失去民心。</p>\n<p>2015/8/20 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"记天津塘沽爆炸\"><a href=\"#记天津塘沽爆炸\" class=\"headerlink\" title=\"记天津塘沽爆炸\"></a>记天津塘沽爆炸</h2><p>天津塘沽爆炸，到现在没去问责失职的政府部门和官员，却立即开启了感动中国模式，舆论导向几乎全部转向牺牲的消防战士身上，消防战士固然是伟大的值得我们敬仰的，可是新闻媒体作为政府的喉舌，故意去转移社会的舆论导向，目的是让人民生活在感动之中，让人们忘却去问责那些应该承担这起事故责任的政府部门和官员，让年轻的消防战士去送死的指挥部门，让人们失去最后的一点愤怒，政府如果这么愚弄人民，最终只会失去民心。</p>\n<p>2015/8/20 北京</p>\n"},{"title":"昨日旧梦，常记于心","date":"2015-12-04T02:01:47.000Z","_content":"\n## 昨日旧梦，常记于心\n\n> 草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好！——顾城。\n\n昨夜做了很久的梦，梦里与老友做着多年前没有完成的事，最近常常怀念好久以前的同学朋友，对一些过去发生的事情，清晰到像在昨日发生之事，时光匆匆，带走单纯的日子，迎来朝九晚五的生活，我们竭力嘶喊，喉咙都哑了，却还是什么都抓不住。\n\n我不喜欢怀念，我把自己搞成很忙很忙的样子，怀念让人忧伤，怀念让人觉得现在不如从前，怀念让人做出不理智的事情。\n\n我以前住在村里的时候，梦想着考去城里读书，后来全家搬到小城，我便在那里上学，读书，度过了我人生最单纯快乐的十年，虽说伴有偶尔的无病呻吟，矫揉造作以及对人生的种种期许和感慨，但那十年是认真活着，有爱，有理想， 就是有些不接地气。那个十年是我几年前想离开的十年，那个十年是我现在真真切切怀念的十年，而这样就变成了现在过着以前渴望的生活状态，而以前却成了现在的梦想，电影《后悔无期》里的最后一句话说：告别的时候一定要用力一点，多说一句，说不定就成了最后一句，多看一眼，弄不好就是最后一眼。可我还没来得及道一声再见，就再也不见。\n\n我怀念的远方老友，我甚是想念，想的胸中顿涩，想的泪眼婆娑，何时再见，我们推杯换盏，一诉经年。\n\n朴树的歌声里唱到，我曾经跨过山和大海，也穿过人山人海，我曾经拥有这一切，转眼都飘散如烟，我们都平凡，或许你已记不得走了多远的路，但你记得自己经历的人和事，这些东西会在你心头扎根，生长，直至参天。\n\n外面的世界很精彩，外面的世界很无奈。当你觉得外面的世界很精彩，我会在这里衷心的祝福你！\n\n2015/12/04 北京","source":"_posts/daily-2015-1204.md","raw":"---\ntitle: 昨日旧梦，常记于心\ndate: 2015-12-04 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 昨日旧梦，常记于心\n\n> 草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好！——顾城。\n\n昨夜做了很久的梦，梦里与老友做着多年前没有完成的事，最近常常怀念好久以前的同学朋友，对一些过去发生的事情，清晰到像在昨日发生之事，时光匆匆，带走单纯的日子，迎来朝九晚五的生活，我们竭力嘶喊，喉咙都哑了，却还是什么都抓不住。\n\n我不喜欢怀念，我把自己搞成很忙很忙的样子，怀念让人忧伤，怀念让人觉得现在不如从前，怀念让人做出不理智的事情。\n\n我以前住在村里的时候，梦想着考去城里读书，后来全家搬到小城，我便在那里上学，读书，度过了我人生最单纯快乐的十年，虽说伴有偶尔的无病呻吟，矫揉造作以及对人生的种种期许和感慨，但那十年是认真活着，有爱，有理想， 就是有些不接地气。那个十年是我几年前想离开的十年，那个十年是我现在真真切切怀念的十年，而这样就变成了现在过着以前渴望的生活状态，而以前却成了现在的梦想，电影《后悔无期》里的最后一句话说：告别的时候一定要用力一点，多说一句，说不定就成了最后一句，多看一眼，弄不好就是最后一眼。可我还没来得及道一声再见，就再也不见。\n\n我怀念的远方老友，我甚是想念，想的胸中顿涩，想的泪眼婆娑，何时再见，我们推杯换盏，一诉经年。\n\n朴树的歌声里唱到，我曾经跨过山和大海，也穿过人山人海，我曾经拥有这一切，转眼都飘散如烟，我们都平凡，或许你已记不得走了多远的路，但你记得自己经历的人和事，这些东西会在你心头扎根，生长，直至参天。\n\n外面的世界很精彩，外面的世界很无奈。当你觉得外面的世界很精彩，我会在这里衷心的祝福你！\n\n2015/12/04 北京","slug":"daily-2015-1204","published":1,"updated":"2019-01-13T09:49:38.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d1y0007l1fqs7uubg6c","content":"<h2 id=\"昨日旧梦，常记于心\"><a href=\"#昨日旧梦，常记于心\" class=\"headerlink\" title=\"昨日旧梦，常记于心\"></a>昨日旧梦，常记于心</h2><blockquote>\n<p>草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好！——顾城。</p>\n</blockquote>\n<p>昨夜做了很久的梦，梦里与老友做着多年前没有完成的事，最近常常怀念好久以前的同学朋友，对一些过去发生的事情，清晰到像在昨日发生之事，时光匆匆，带走单纯的日子，迎来朝九晚五的生活，我们竭力嘶喊，喉咙都哑了，却还是什么都抓不住。</p>\n<p>我不喜欢怀念，我把自己搞成很忙很忙的样子，怀念让人忧伤，怀念让人觉得现在不如从前，怀念让人做出不理智的事情。</p>\n<p>我以前住在村里的时候，梦想着考去城里读书，后来全家搬到小城，我便在那里上学，读书，度过了我人生最单纯快乐的十年，虽说伴有偶尔的无病呻吟，矫揉造作以及对人生的种种期许和感慨，但那十年是认真活着，有爱，有理想， 就是有些不接地气。那个十年是我几年前想离开的十年，那个十年是我现在真真切切怀念的十年，而这样就变成了现在过着以前渴望的生活状态，而以前却成了现在的梦想，电影《后悔无期》里的最后一句话说：告别的时候一定要用力一点，多说一句，说不定就成了最后一句，多看一眼，弄不好就是最后一眼。可我还没来得及道一声再见，就再也不见。</p>\n<p>我怀念的远方老友，我甚是想念，想的胸中顿涩，想的泪眼婆娑，何时再见，我们推杯换盏，一诉经年。</p>\n<p>朴树的歌声里唱到，我曾经跨过山和大海，也穿过人山人海，我曾经拥有这一切，转眼都飘散如烟，我们都平凡，或许你已记不得走了多远的路，但你记得自己经历的人和事，这些东西会在你心头扎根，生长，直至参天。</p>\n<p>外面的世界很精彩，外面的世界很无奈。当你觉得外面的世界很精彩，我会在这里衷心的祝福你！</p>\n<p>2015/12/04 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"昨日旧梦，常记于心\"><a href=\"#昨日旧梦，常记于心\" class=\"headerlink\" title=\"昨日旧梦，常记于心\"></a>昨日旧梦，常记于心</h2><blockquote>\n<p>草在结它的种子，风在摇它的叶子。我们站着，不说话，就十分美好！——顾城。</p>\n</blockquote>\n<p>昨夜做了很久的梦，梦里与老友做着多年前没有完成的事，最近常常怀念好久以前的同学朋友，对一些过去发生的事情，清晰到像在昨日发生之事，时光匆匆，带走单纯的日子，迎来朝九晚五的生活，我们竭力嘶喊，喉咙都哑了，却还是什么都抓不住。</p>\n<p>我不喜欢怀念，我把自己搞成很忙很忙的样子，怀念让人忧伤，怀念让人觉得现在不如从前，怀念让人做出不理智的事情。</p>\n<p>我以前住在村里的时候，梦想着考去城里读书，后来全家搬到小城，我便在那里上学，读书，度过了我人生最单纯快乐的十年，虽说伴有偶尔的无病呻吟，矫揉造作以及对人生的种种期许和感慨，但那十年是认真活着，有爱，有理想， 就是有些不接地气。那个十年是我几年前想离开的十年，那个十年是我现在真真切切怀念的十年，而这样就变成了现在过着以前渴望的生活状态，而以前却成了现在的梦想，电影《后悔无期》里的最后一句话说：告别的时候一定要用力一点，多说一句，说不定就成了最后一句，多看一眼，弄不好就是最后一眼。可我还没来得及道一声再见，就再也不见。</p>\n<p>我怀念的远方老友，我甚是想念，想的胸中顿涩，想的泪眼婆娑，何时再见，我们推杯换盏，一诉经年。</p>\n<p>朴树的歌声里唱到，我曾经跨过山和大海，也穿过人山人海，我曾经拥有这一切，转眼都飘散如烟，我们都平凡，或许你已记不得走了多远的路，但你记得自己经历的人和事，这些东西会在你心头扎根，生长，直至参天。</p>\n<p>外面的世界很精彩，外面的世界很无奈。当你觉得外面的世界很精彩，我会在这里衷心的祝福你！</p>\n<p>2015/12/04 北京</p>\n"},{"title":"租房二三事","date":"2016-02-03T02:01:47.000Z","_content":"\n## 租房二三事\n\n![](/images/daily/954377808.jpg)\n> 人在江湖，就得挨刀。\n\n想抒发一下心里的不快，来北京第三个年头了，还没有因为租房的事情被坑过，风水轮流转，今日轮到我。\n\n房东地主，4500块押金不退。理论了半天，还是没什么结果。当初说好提前30天打招呼就会退房租，到了谈钱的时候，就都变了。\n\n上学的时候，家长老师总会往你的脑海里传输社会上的种种人心善恶美丑，是非黑白。但是却没有告诉，当你面对这些嘴脸的时候，应该如何正确面对和处理。\n难以想象，我会被这个世界改造成什么样子，现在的自己能不能认识十年后的样子，会不会喜欢，会不会失望？\n\n我想，在我没有资本的时候别人怎么对我，如果有一天我有幸通过自己的努力获得，我也一定不会对我经历的人和事而怀恨在心，施予他人。钱对我来说，很重要，但不会超过人格，不会泯灭人性和善良。\n\n如果这种坚持能让身边的人多一点点改变，能让自己多一点点韧性，我希望我能一直保持一颗善良的心，不偏不倚，还是满怀希望。\n\n我还年轻，我不愿成为我讨厌的那种人，就是这样！\n\n2016/02/03 长治","source":"_posts/daily-2016-0203.md","raw":"---\ntitle: 租房二三事\ndate: 2016-02-03 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 租房二三事\n\n![](/images/daily/954377808.jpg)\n> 人在江湖，就得挨刀。\n\n想抒发一下心里的不快，来北京第三个年头了，还没有因为租房的事情被坑过，风水轮流转，今日轮到我。\n\n房东地主，4500块押金不退。理论了半天，还是没什么结果。当初说好提前30天打招呼就会退房租，到了谈钱的时候，就都变了。\n\n上学的时候，家长老师总会往你的脑海里传输社会上的种种人心善恶美丑，是非黑白。但是却没有告诉，当你面对这些嘴脸的时候，应该如何正确面对和处理。\n难以想象，我会被这个世界改造成什么样子，现在的自己能不能认识十年后的样子，会不会喜欢，会不会失望？\n\n我想，在我没有资本的时候别人怎么对我，如果有一天我有幸通过自己的努力获得，我也一定不会对我经历的人和事而怀恨在心，施予他人。钱对我来说，很重要，但不会超过人格，不会泯灭人性和善良。\n\n如果这种坚持能让身边的人多一点点改变，能让自己多一点点韧性，我希望我能一直保持一颗善良的心，不偏不倚，还是满怀希望。\n\n我还年轻，我不愿成为我讨厌的那种人，就是这样！\n\n2016/02/03 长治","slug":"daily-2016-0203","published":1,"updated":"2019-01-13T09:49:39.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d200008l1fqnv5xlcfo","content":"<h2 id=\"租房二三事\"><a href=\"#租房二三事\" class=\"headerlink\" title=\"租房二三事\"></a>租房二三事</h2><p><img src=\"/images/daily/954377808.jpg\" alt=\"\"></p>\n<blockquote>\n<p>人在江湖，就得挨刀。</p>\n</blockquote>\n<p>想抒发一下心里的不快，来北京第三个年头了，还没有因为租房的事情被坑过，风水轮流转，今日轮到我。</p>\n<p>房东地主，4500块押金不退。理论了半天，还是没什么结果。当初说好提前30天打招呼就会退房租，到了谈钱的时候，就都变了。</p>\n<p>上学的时候，家长老师总会往你的脑海里传输社会上的种种人心善恶美丑，是非黑白。但是却没有告诉，当你面对这些嘴脸的时候，应该如何正确面对和处理。<br>难以想象，我会被这个世界改造成什么样子，现在的自己能不能认识十年后的样子，会不会喜欢，会不会失望？</p>\n<p>我想，在我没有资本的时候别人怎么对我，如果有一天我有幸通过自己的努力获得，我也一定不会对我经历的人和事而怀恨在心，施予他人。钱对我来说，很重要，但不会超过人格，不会泯灭人性和善良。</p>\n<p>如果这种坚持能让身边的人多一点点改变，能让自己多一点点韧性，我希望我能一直保持一颗善良的心，不偏不倚，还是满怀希望。</p>\n<p>我还年轻，我不愿成为我讨厌的那种人，就是这样！</p>\n<p>2016/02/03 长治</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"租房二三事\"><a href=\"#租房二三事\" class=\"headerlink\" title=\"租房二三事\"></a>租房二三事</h2><p><img src=\"/images/daily/954377808.jpg\" alt=\"\"></p>\n<blockquote>\n<p>人在江湖，就得挨刀。</p>\n</blockquote>\n<p>想抒发一下心里的不快，来北京第三个年头了，还没有因为租房的事情被坑过，风水轮流转，今日轮到我。</p>\n<p>房东地主，4500块押金不退。理论了半天，还是没什么结果。当初说好提前30天打招呼就会退房租，到了谈钱的时候，就都变了。</p>\n<p>上学的时候，家长老师总会往你的脑海里传输社会上的种种人心善恶美丑，是非黑白。但是却没有告诉，当你面对这些嘴脸的时候，应该如何正确面对和处理。<br>难以想象，我会被这个世界改造成什么样子，现在的自己能不能认识十年后的样子，会不会喜欢，会不会失望？</p>\n<p>我想，在我没有资本的时候别人怎么对我，如果有一天我有幸通过自己的努力获得，我也一定不会对我经历的人和事而怀恨在心，施予他人。钱对我来说，很重要，但不会超过人格，不会泯灭人性和善良。</p>\n<p>如果这种坚持能让身边的人多一点点改变，能让自己多一点点韧性，我希望我能一直保持一颗善良的心，不偏不倚，还是满怀希望。</p>\n<p>我还年轻，我不愿成为我讨厌的那种人，就是这样！</p>\n<p>2016/02/03 长治</p>\n"},{"title":"朋友，去远方吗？","date":"2016-02-12T02:01:47.000Z","_content":"\n## 朋友，去远方吗？\n\n![](/images/daily/750990835.png)\n> 七不出门，八不回家。\n\n窗外的夜沉沉的，浓浓的雾色笼罩着远处偶尔的几声车鸣和人声，初春的雨夹杂着夜晚的微寒透过窗户淅淅沥沥的渗进来，就到了正月初六，这相聚离别时，年年岁岁花相似，岁岁年年人不同，回头一看，好像故乡从此只有冬天、父母、老友。\n\n我想，有些时候，人受不了的恐怕不是离别，更多是怕那种分别的气氛和感伤的情绪，怕那种形式和那种形式所包含的内容。但天下没有不散的宴席，分离是人生很正常的事，还好我们都是为了各自的理想和事业。我们都曾在人生的海洋中相遇，岁月飘忽，必然会改变许多东西。时间会使许多绚烂归于平淡，我只是难以释怀为什么总是如此匆忙？\n\n我渐习惯离家，喜欢漂泊，常将远方挂于心上。\n但每当此时，总想来叙叙旧事，把酒杯满上，诉些许思念。\n朋友，去远方吗？\n我去远方\n\n2016/02/12 长治","source":"_posts/daily-2016-0212.md","raw":"---\ntitle: 朋友，去远方吗？\ndate: 2016-02-12 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 朋友，去远方吗？\n\n![](/images/daily/750990835.png)\n> 七不出门，八不回家。\n\n窗外的夜沉沉的，浓浓的雾色笼罩着远处偶尔的几声车鸣和人声，初春的雨夹杂着夜晚的微寒透过窗户淅淅沥沥的渗进来，就到了正月初六，这相聚离别时，年年岁岁花相似，岁岁年年人不同，回头一看，好像故乡从此只有冬天、父母、老友。\n\n我想，有些时候，人受不了的恐怕不是离别，更多是怕那种分别的气氛和感伤的情绪，怕那种形式和那种形式所包含的内容。但天下没有不散的宴席，分离是人生很正常的事，还好我们都是为了各自的理想和事业。我们都曾在人生的海洋中相遇，岁月飘忽，必然会改变许多东西。时间会使许多绚烂归于平淡，我只是难以释怀为什么总是如此匆忙？\n\n我渐习惯离家，喜欢漂泊，常将远方挂于心上。\n但每当此时，总想来叙叙旧事，把酒杯满上，诉些许思念。\n朋友，去远方吗？\n我去远方\n\n2016/02/12 长治","slug":"daily-2016-0212","published":1,"updated":"2019-01-13T09:49:41.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d23000cl1fqb89j0t36","content":"<h2 id=\"朋友，去远方吗？\"><a href=\"#朋友，去远方吗？\" class=\"headerlink\" title=\"朋友，去远方吗？\"></a>朋友，去远方吗？</h2><p><img src=\"/images/daily/750990835.png\" alt=\"\"></p>\n<blockquote>\n<p>七不出门，八不回家。</p>\n</blockquote>\n<p>窗外的夜沉沉的，浓浓的雾色笼罩着远处偶尔的几声车鸣和人声，初春的雨夹杂着夜晚的微寒透过窗户淅淅沥沥的渗进来，就到了正月初六，这相聚离别时，年年岁岁花相似，岁岁年年人不同，回头一看，好像故乡从此只有冬天、父母、老友。</p>\n<p>我想，有些时候，人受不了的恐怕不是离别，更多是怕那种分别的气氛和感伤的情绪，怕那种形式和那种形式所包含的内容。但天下没有不散的宴席，分离是人生很正常的事，还好我们都是为了各自的理想和事业。我们都曾在人生的海洋中相遇，岁月飘忽，必然会改变许多东西。时间会使许多绚烂归于平淡，我只是难以释怀为什么总是如此匆忙？</p>\n<p>我渐习惯离家，喜欢漂泊，常将远方挂于心上。<br>但每当此时，总想来叙叙旧事，把酒杯满上，诉些许思念。<br>朋友，去远方吗？<br>我去远方</p>\n<p>2016/02/12 长治</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"朋友，去远方吗？\"><a href=\"#朋友，去远方吗？\" class=\"headerlink\" title=\"朋友，去远方吗？\"></a>朋友，去远方吗？</h2><p><img src=\"/images/daily/750990835.png\" alt=\"\"></p>\n<blockquote>\n<p>七不出门，八不回家。</p>\n</blockquote>\n<p>窗外的夜沉沉的，浓浓的雾色笼罩着远处偶尔的几声车鸣和人声，初春的雨夹杂着夜晚的微寒透过窗户淅淅沥沥的渗进来，就到了正月初六，这相聚离别时，年年岁岁花相似，岁岁年年人不同，回头一看，好像故乡从此只有冬天、父母、老友。</p>\n<p>我想，有些时候，人受不了的恐怕不是离别，更多是怕那种分别的气氛和感伤的情绪，怕那种形式和那种形式所包含的内容。但天下没有不散的宴席，分离是人生很正常的事，还好我们都是为了各自的理想和事业。我们都曾在人生的海洋中相遇，岁月飘忽，必然会改变许多东西。时间会使许多绚烂归于平淡，我只是难以释怀为什么总是如此匆忙？</p>\n<p>我渐习惯离家，喜欢漂泊，常将远方挂于心上。<br>但每当此时，总想来叙叙旧事，把酒杯满上，诉些许思念。<br>朋友，去远方吗？<br>我去远方</p>\n<p>2016/02/12 长治</p>\n"},{"title":"Hello World","date":"2017-04-29T09:29:30.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-04-29 17:29:30\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-01-13T04:36:43.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d26000el1fqai3jxyqp","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"群哥结婚了","date":"2017-02-21T02:01:47.000Z","_content":"\n## 群哥结婚了\n\n ![](/images/daily/2069527412.jpeg)\n是的，卢群，我们大伙儿管他叫群哥，我的大学舍友，是潍坊不多的哥们之一。\n是的，群哥在今天领证儿了！我也只是通过空间看到他晒出的照片。\n\n认识群哥快五年了，此时，我在北京，他在济南，千里之遥，正值春雪覆满大地之时，多想与他举杯恭喜，分享他的幸福之情...\n\n群哥，真不好意思，好久不见了，现在的你我在忙着各自的事情，已经有很久没有坐在一起了，还记得大学时我们一起讨论技术，一起努力，一起挥洒汗水的球场，还有一起在晚自习后去吃的南湖的兰州拉面吗？当我在空间看到你结婚的消息时，我高兴啊！高兴你终于把爱情修成正果。还是要祝福你啊，也希望你在新的起点肩负起新的责任，充满信心和热情去迎接人生的下一个阶段...\n\n群哥，想你了，相信你也想我了，话如泉涌啊，不说了，办事儿的时候叫我喝喜酒啊...\n\n2017/02/21 北京","source":"_posts/daily-2017-0221.md","raw":"---\ntitle: 群哥结婚了\ndate: 2017-02-21 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 群哥结婚了\n\n ![](/images/daily/2069527412.jpeg)\n是的，卢群，我们大伙儿管他叫群哥，我的大学舍友，是潍坊不多的哥们之一。\n是的，群哥在今天领证儿了！我也只是通过空间看到他晒出的照片。\n\n认识群哥快五年了，此时，我在北京，他在济南，千里之遥，正值春雪覆满大地之时，多想与他举杯恭喜，分享他的幸福之情...\n\n群哥，真不好意思，好久不见了，现在的你我在忙着各自的事情，已经有很久没有坐在一起了，还记得大学时我们一起讨论技术，一起努力，一起挥洒汗水的球场，还有一起在晚自习后去吃的南湖的兰州拉面吗？当我在空间看到你结婚的消息时，我高兴啊！高兴你终于把爱情修成正果。还是要祝福你啊，也希望你在新的起点肩负起新的责任，充满信心和热情去迎接人生的下一个阶段...\n\n群哥，想你了，相信你也想我了，话如泉涌啊，不说了，办事儿的时候叫我喝喜酒啊...\n\n2017/02/21 北京","slug":"daily-2017-0221","published":1,"updated":"2019-01-13T09:49:43.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d29000jl1fqeaqd7uc8","content":"<h2 id=\"群哥结婚了\"><a href=\"#群哥结婚了\" class=\"headerlink\" title=\"群哥结婚了\"></a>群哥结婚了</h2><p> <img src=\"/images/daily/2069527412.jpeg\" alt=\"\"><br>是的，卢群，我们大伙儿管他叫群哥，我的大学舍友，是潍坊不多的哥们之一。<br>是的，群哥在今天领证儿了！我也只是通过空间看到他晒出的照片。</p>\n<p>认识群哥快五年了，此时，我在北京，他在济南，千里之遥，正值春雪覆满大地之时，多想与他举杯恭喜，分享他的幸福之情…</p>\n<p>群哥，真不好意思，好久不见了，现在的你我在忙着各自的事情，已经有很久没有坐在一起了，还记得大学时我们一起讨论技术，一起努力，一起挥洒汗水的球场，还有一起在晚自习后去吃的南湖的兰州拉面吗？当我在空间看到你结婚的消息时，我高兴啊！高兴你终于把爱情修成正果。还是要祝福你啊，也希望你在新的起点肩负起新的责任，充满信心和热情去迎接人生的下一个阶段…</p>\n<p>群哥，想你了，相信你也想我了，话如泉涌啊，不说了，办事儿的时候叫我喝喜酒啊…</p>\n<p>2017/02/21 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"群哥结婚了\"><a href=\"#群哥结婚了\" class=\"headerlink\" title=\"群哥结婚了\"></a>群哥结婚了</h2><p> <img src=\"/images/daily/2069527412.jpeg\" alt=\"\"><br>是的，卢群，我们大伙儿管他叫群哥，我的大学舍友，是潍坊不多的哥们之一。<br>是的，群哥在今天领证儿了！我也只是通过空间看到他晒出的照片。</p>\n<p>认识群哥快五年了，此时，我在北京，他在济南，千里之遥，正值春雪覆满大地之时，多想与他举杯恭喜，分享他的幸福之情…</p>\n<p>群哥，真不好意思，好久不见了，现在的你我在忙着各自的事情，已经有很久没有坐在一起了，还记得大学时我们一起讨论技术，一起努力，一起挥洒汗水的球场，还有一起在晚自习后去吃的南湖的兰州拉面吗？当我在空间看到你结婚的消息时，我高兴啊！高兴你终于把爱情修成正果。还是要祝福你啊，也希望你在新的起点肩负起新的责任，充满信心和热情去迎接人生的下一个阶段…</p>\n<p>群哥，想你了，相信你也想我了，话如泉涌啊，不说了，办事儿的时候叫我喝喜酒啊…</p>\n<p>2017/02/21 北京</p>\n"},{"title":"考研日记","date":"2016-08-01T02:01:47.000Z","_content":"\n## 考研日记（四）\n\n￼![](/images/daily/613674261.jpeg)\n> 老罗说，所有的失败都是因为半途而废。\n当自习室里越来越多的人弃考，大多数人进入极度的疲惫期，午休的时间比之前都加长，我一定会坚持到最后，在绝望中寻找希望!\n\n如果当你全身心努力去付出后，结果不像理想中那样，还是会很难以接受，毅力根本不是问题，坚持也根本不是问题，只是时间问题。\n换个角度，努力和经历本身就是一种收获。\n洗把脸吧，继续奔赴下一个黎明。\n\n2016/11/01 北京\n\n## 考研日记（三）\n\n![](/images/daily/824027791-2.png)\n> 因为你选择了考研，所以你就已经成了你想成为的模样。\n9月2日，北师开学的日子，迎来新的面孔，送走旧的脸庞，悬挂的横幅上写着：欢迎2016级新同学。这让我想起2012年，在送别父亲的车站，你流着眼泪，带着微笑，穿过熙熙攘攘的人群，在心里和曾经说再见时的希望所向。\n\n9月15日，中秋节的自习室有一丝空旷，不，是空空荡荡。晚上的时候我在木铎下和你说：没事儿，这不过是万千思绪中的一种，你要去的是大海的方向，风浪必然会是你的衣裳，你乘着它，便是远方。\n\n9月26日，平日里温暖的自习室，参加司考的同学结束了最后的审判，低头收拾铺着的行囊的时候，不经意间在这个秋日的午后，剩下一地的考研er依然坚强。隔墙的走廊变得只有偶尔能听见的几簇上下课走动的声响。你忽地觉得孤单，忽又觉得仓促而又漫长。并不是因为你太容易过于感伤，也不是因为日子就这样一天天成为过往。\n\n9月30日，在你来不及回望的每个清晨，在东门你驻脚等候的620的站牌旁，你抬头看漫天星辰的时候，你的背影满目八月的模样。\n\n2016/10/01 北京\n\n## 考研日记（二）\n\n![](/images/daily/788509444.jpg)\n> 选择考研，就如同选择种下一粒种子，坚持就会生长，直至参天。\n\n嘿，九月，你好啊！\n嘿，时光，能不能别走的这么快啊！\n\n当我背起书包出门，乘着620穿过安立路去了又回，这两个简单的场景便能勾勒出八月的每一个日出和日落。九月的北京，秋天在睡醒一觉后就慕地来临，在清晨睁开眼透过窗外看北五环楼林的时候，彼时天空是那种迷人的蓝，你忽地觉得：岁月如此静好！如此静好！\n\n原谅我总是要在说正事之前煽情一番。因为，我也总是认为：当一个人在做自己认为值得和有意义的事情的过程中，有必要去记录某些时刻思想的经历和感悟。这样如果多年以后读起年青时写下的文字也定会是别样的思绪万千！努力做一个精神世界美好而富有的人嗬，虽然现实所经历的从不曾如想象那般尽如人意，但这也更能显得弥足珍贵。\n\nSteve Jobs 说：“We can not connect the dots looking forward; We can only connect them looking backwards.”(我们不能把现在的每个点连接起来去看到未来，但是当我们回头看时，却能把它们串连起来看到对于过去的意义) 。对于一个已经离开校园漂泊很长时间的人来说，离开其实已经是一种勇气，而我理解中的考研过程本身也已变成是一个人内心和精神的修炼。彷徨与痛苦，挫折与欣喜，线条化的生活让人与世隔绝，人生失去颜色却又充满另一种芬芳。\n\n话说如果你爱一个人，就让他考研，因为那里是天堂，又说如果你恨一个人，也让他考研，因为那里是地狱，当然我考研的动机既不是为了探寻生的理由和存在的意义，自然也不曾爱一个人或恨一个人到要和他一同考研的地步。我选择考研，只是想和一些时期的作为和不作为做个了断，只愿不再自我纠缠。而且这件事啊，非如此不可！非如此不可！我很喜欢戈麦的这首诗，因为有朝一日，真像终将大白于天下。\n\n> 有朝一日，我会赢得整个世界\n> 有朝一日，我将挽回我的损失\n> 有朝一日，我将不停地将过去摔打\n> 珍视我的人，你没有伪装\n> 我将把血肉做成黄金，做成粮食\n> 献给你们庄重与博大\n> 爱我的人啊，我没有叫你失望\n> 你们的等待，虽然灰冷而渺茫\n> 但有朝一日，真相将大白于天下\n> 辛酸所凝铸的汗水将一一得到补偿\n\n同样也很喜欢《功夫熊猫2》里面师傅对熊猫说的这句话：\n> “Your story may not have such a happy beginning, but that doesn't make who your are. It is the rest of your story, who you choose to be.”（你人生故事的开头也许不那么快乐，但这并不影响你成为什么样的人。关键看后来的人生路，你选择怎么走下去。）\n\n2016/09/01 北京\n\n## 考研日记（一）\n\n![](/images/daily/1590392806.jpg)\n今天，就算是这段旅程的开始\n我仍习惯性地把它称之为旅程\n我静坐于北师教九的一间教室\n试着去规划未来五个月的日子\n\n我将重新开始\n沿着地平线\n努力拥抱每一个黎明和黄昏\n\n我将再次出发\n指着大海的方向\n虔诚迎接每一个日出和日落\n\n如果\n你在途中和我迎面走来\n请对我报以善意的鼓励和微笑\n并祝我一路顺风\n\n2016/08/01 北京\n\n## 考研于我\n\n![](/images/daily/2884524888.jpg)\n> 所谓的光辉岁月，并不是后来闪耀的日子，而是无人问津时，你对梦想的偏执。\n\n2016，我想考研。\n毕业和离开，投身人海和朝九晚五之后，这个想法已经在心底愈来愈强烈。\n\n总是被一个想法羁绊着，你无法描述那种感觉，但是，你一定会选择在某个时间去做，去实现它。那个想法像是一棵树，可能是因为一些是经历，慢慢生根，发芽，悄然直至有天你发现它已参天蔽日，枝枝蔓蔓充斥你的一切，然后，当决定了要去做的时候，一定要狠狠做，加倍做。\n\n老妈说，出了社会还想回来难啊，是啊，我说人越成长就越少了想法，所以我想趁着我还有点想法，又有点年轻任性资本的时候，多做点想做的事情，想考研，就当是对梦想的偏执吧。\n\n2016/02/10 长治","source":"_posts/daily-kaoyan.md","raw":"---\ntitle: 考研日记\ndate: 2016-08-01 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 考研日记（四）\n\n￼![](/images/daily/613674261.jpeg)\n> 老罗说，所有的失败都是因为半途而废。\n当自习室里越来越多的人弃考，大多数人进入极度的疲惫期，午休的时间比之前都加长，我一定会坚持到最后，在绝望中寻找希望!\n\n如果当你全身心努力去付出后，结果不像理想中那样，还是会很难以接受，毅力根本不是问题，坚持也根本不是问题，只是时间问题。\n换个角度，努力和经历本身就是一种收获。\n洗把脸吧，继续奔赴下一个黎明。\n\n2016/11/01 北京\n\n## 考研日记（三）\n\n![](/images/daily/824027791-2.png)\n> 因为你选择了考研，所以你就已经成了你想成为的模样。\n9月2日，北师开学的日子，迎来新的面孔，送走旧的脸庞，悬挂的横幅上写着：欢迎2016级新同学。这让我想起2012年，在送别父亲的车站，你流着眼泪，带着微笑，穿过熙熙攘攘的人群，在心里和曾经说再见时的希望所向。\n\n9月15日，中秋节的自习室有一丝空旷，不，是空空荡荡。晚上的时候我在木铎下和你说：没事儿，这不过是万千思绪中的一种，你要去的是大海的方向，风浪必然会是你的衣裳，你乘着它，便是远方。\n\n9月26日，平日里温暖的自习室，参加司考的同学结束了最后的审判，低头收拾铺着的行囊的时候，不经意间在这个秋日的午后，剩下一地的考研er依然坚强。隔墙的走廊变得只有偶尔能听见的几簇上下课走动的声响。你忽地觉得孤单，忽又觉得仓促而又漫长。并不是因为你太容易过于感伤，也不是因为日子就这样一天天成为过往。\n\n9月30日，在你来不及回望的每个清晨，在东门你驻脚等候的620的站牌旁，你抬头看漫天星辰的时候，你的背影满目八月的模样。\n\n2016/10/01 北京\n\n## 考研日记（二）\n\n![](/images/daily/788509444.jpg)\n> 选择考研，就如同选择种下一粒种子，坚持就会生长，直至参天。\n\n嘿，九月，你好啊！\n嘿，时光，能不能别走的这么快啊！\n\n当我背起书包出门，乘着620穿过安立路去了又回，这两个简单的场景便能勾勒出八月的每一个日出和日落。九月的北京，秋天在睡醒一觉后就慕地来临，在清晨睁开眼透过窗外看北五环楼林的时候，彼时天空是那种迷人的蓝，你忽地觉得：岁月如此静好！如此静好！\n\n原谅我总是要在说正事之前煽情一番。因为，我也总是认为：当一个人在做自己认为值得和有意义的事情的过程中，有必要去记录某些时刻思想的经历和感悟。这样如果多年以后读起年青时写下的文字也定会是别样的思绪万千！努力做一个精神世界美好而富有的人嗬，虽然现实所经历的从不曾如想象那般尽如人意，但这也更能显得弥足珍贵。\n\nSteve Jobs 说：“We can not connect the dots looking forward; We can only connect them looking backwards.”(我们不能把现在的每个点连接起来去看到未来，但是当我们回头看时，却能把它们串连起来看到对于过去的意义) 。对于一个已经离开校园漂泊很长时间的人来说，离开其实已经是一种勇气，而我理解中的考研过程本身也已变成是一个人内心和精神的修炼。彷徨与痛苦，挫折与欣喜，线条化的生活让人与世隔绝，人生失去颜色却又充满另一种芬芳。\n\n话说如果你爱一个人，就让他考研，因为那里是天堂，又说如果你恨一个人，也让他考研，因为那里是地狱，当然我考研的动机既不是为了探寻生的理由和存在的意义，自然也不曾爱一个人或恨一个人到要和他一同考研的地步。我选择考研，只是想和一些时期的作为和不作为做个了断，只愿不再自我纠缠。而且这件事啊，非如此不可！非如此不可！我很喜欢戈麦的这首诗，因为有朝一日，真像终将大白于天下。\n\n> 有朝一日，我会赢得整个世界\n> 有朝一日，我将挽回我的损失\n> 有朝一日，我将不停地将过去摔打\n> 珍视我的人，你没有伪装\n> 我将把血肉做成黄金，做成粮食\n> 献给你们庄重与博大\n> 爱我的人啊，我没有叫你失望\n> 你们的等待，虽然灰冷而渺茫\n> 但有朝一日，真相将大白于天下\n> 辛酸所凝铸的汗水将一一得到补偿\n\n同样也很喜欢《功夫熊猫2》里面师傅对熊猫说的这句话：\n> “Your story may not have such a happy beginning, but that doesn't make who your are. It is the rest of your story, who you choose to be.”（你人生故事的开头也许不那么快乐，但这并不影响你成为什么样的人。关键看后来的人生路，你选择怎么走下去。）\n\n2016/09/01 北京\n\n## 考研日记（一）\n\n![](/images/daily/1590392806.jpg)\n今天，就算是这段旅程的开始\n我仍习惯性地把它称之为旅程\n我静坐于北师教九的一间教室\n试着去规划未来五个月的日子\n\n我将重新开始\n沿着地平线\n努力拥抱每一个黎明和黄昏\n\n我将再次出发\n指着大海的方向\n虔诚迎接每一个日出和日落\n\n如果\n你在途中和我迎面走来\n请对我报以善意的鼓励和微笑\n并祝我一路顺风\n\n2016/08/01 北京\n\n## 考研于我\n\n![](/images/daily/2884524888.jpg)\n> 所谓的光辉岁月，并不是后来闪耀的日子，而是无人问津时，你对梦想的偏执。\n\n2016，我想考研。\n毕业和离开，投身人海和朝九晚五之后，这个想法已经在心底愈来愈强烈。\n\n总是被一个想法羁绊着，你无法描述那种感觉，但是，你一定会选择在某个时间去做，去实现它。那个想法像是一棵树，可能是因为一些是经历，慢慢生根，发芽，悄然直至有天你发现它已参天蔽日，枝枝蔓蔓充斥你的一切，然后，当决定了要去做的时候，一定要狠狠做，加倍做。\n\n老妈说，出了社会还想回来难啊，是啊，我说人越成长就越少了想法，所以我想趁着我还有点想法，又有点年轻任性资本的时候，多做点想做的事情，想考研，就当是对梦想的偏执吧。\n\n2016/02/10 长治","slug":"daily-kaoyan","published":1,"updated":"2019-01-13T09:49:46.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2b000ml1fqikbl55hx","content":"<h2 id=\"考研日记（四）\"><a href=\"#考研日记（四）\" class=\"headerlink\" title=\"考研日记（四）\"></a>考研日记（四）</h2><p>￼<img src=\"/images/daily/613674261.jpeg\" alt=\"\"></p>\n<blockquote>\n<p>老罗说，所有的失败都是因为半途而废。<br>当自习室里越来越多的人弃考，大多数人进入极度的疲惫期，午休的时间比之前都加长，我一定会坚持到最后，在绝望中寻找希望!</p>\n</blockquote>\n<p>如果当你全身心努力去付出后，结果不像理想中那样，还是会很难以接受，毅力根本不是问题，坚持也根本不是问题，只是时间问题。<br>换个角度，努力和经历本身就是一种收获。<br>洗把脸吧，继续奔赴下一个黎明。</p>\n<p>2016/11/01 北京</p>\n<h2 id=\"考研日记（三）\"><a href=\"#考研日记（三）\" class=\"headerlink\" title=\"考研日记（三）\"></a>考研日记（三）</h2><p><img src=\"/images/daily/824027791-2.png\" alt=\"\"></p>\n<blockquote>\n<p>因为你选择了考研，所以你就已经成了你想成为的模样。<br>9月2日，北师开学的日子，迎来新的面孔，送走旧的脸庞，悬挂的横幅上写着：欢迎2016级新同学。这让我想起2012年，在送别父亲的车站，你流着眼泪，带着微笑，穿过熙熙攘攘的人群，在心里和曾经说再见时的希望所向。</p>\n</blockquote>\n<p>9月15日，中秋节的自习室有一丝空旷，不，是空空荡荡。晚上的时候我在木铎下和你说：没事儿，这不过是万千思绪中的一种，你要去的是大海的方向，风浪必然会是你的衣裳，你乘着它，便是远方。</p>\n<p>9月26日，平日里温暖的自习室，参加司考的同学结束了最后的审判，低头收拾铺着的行囊的时候，不经意间在这个秋日的午后，剩下一地的考研er依然坚强。隔墙的走廊变得只有偶尔能听见的几簇上下课走动的声响。你忽地觉得孤单，忽又觉得仓促而又漫长。并不是因为你太容易过于感伤，也不是因为日子就这样一天天成为过往。</p>\n<p>9月30日，在你来不及回望的每个清晨，在东门你驻脚等候的620的站牌旁，你抬头看漫天星辰的时候，你的背影满目八月的模样。</p>\n<p>2016/10/01 北京</p>\n<h2 id=\"考研日记（二）\"><a href=\"#考研日记（二）\" class=\"headerlink\" title=\"考研日记（二）\"></a>考研日记（二）</h2><p><img src=\"/images/daily/788509444.jpg\" alt=\"\"></p>\n<blockquote>\n<p>选择考研，就如同选择种下一粒种子，坚持就会生长，直至参天。</p>\n</blockquote>\n<p>嘿，九月，你好啊！<br>嘿，时光，能不能别走的这么快啊！</p>\n<p>当我背起书包出门，乘着620穿过安立路去了又回，这两个简单的场景便能勾勒出八月的每一个日出和日落。九月的北京，秋天在睡醒一觉后就慕地来临，在清晨睁开眼透过窗外看北五环楼林的时候，彼时天空是那种迷人的蓝，你忽地觉得：岁月如此静好！如此静好！</p>\n<p>原谅我总是要在说正事之前煽情一番。因为，我也总是认为：当一个人在做自己认为值得和有意义的事情的过程中，有必要去记录某些时刻思想的经历和感悟。这样如果多年以后读起年青时写下的文字也定会是别样的思绪万千！努力做一个精神世界美好而富有的人嗬，虽然现实所经历的从不曾如想象那般尽如人意，但这也更能显得弥足珍贵。</p>\n<p>Steve Jobs 说：“We can not connect the dots looking forward; We can only connect them looking backwards.”(我们不能把现在的每个点连接起来去看到未来，但是当我们回头看时，却能把它们串连起来看到对于过去的意义) 。对于一个已经离开校园漂泊很长时间的人来说，离开其实已经是一种勇气，而我理解中的考研过程本身也已变成是一个人内心和精神的修炼。彷徨与痛苦，挫折与欣喜，线条化的生活让人与世隔绝，人生失去颜色却又充满另一种芬芳。</p>\n<p>话说如果你爱一个人，就让他考研，因为那里是天堂，又说如果你恨一个人，也让他考研，因为那里是地狱，当然我考研的动机既不是为了探寻生的理由和存在的意义，自然也不曾爱一个人或恨一个人到要和他一同考研的地步。我选择考研，只是想和一些时期的作为和不作为做个了断，只愿不再自我纠缠。而且这件事啊，非如此不可！非如此不可！我很喜欢戈麦的这首诗，因为有朝一日，真像终将大白于天下。</p>\n<blockquote>\n<p>有朝一日，我会赢得整个世界<br>有朝一日，我将挽回我的损失<br>有朝一日，我将不停地将过去摔打<br>珍视我的人，你没有伪装<br>我将把血肉做成黄金，做成粮食<br>献给你们庄重与博大<br>爱我的人啊，我没有叫你失望<br>你们的等待，虽然灰冷而渺茫<br>但有朝一日，真相将大白于天下<br>辛酸所凝铸的汗水将一一得到补偿</p>\n</blockquote>\n<p>同样也很喜欢《功夫熊猫2》里面师傅对熊猫说的这句话：</p>\n<blockquote>\n<p>“Your story may not have such a happy beginning, but that doesn’t make who your are. It is the rest of your story, who you choose to be.”（你人生故事的开头也许不那么快乐，但这并不影响你成为什么样的人。关键看后来的人生路，你选择怎么走下去。）</p>\n</blockquote>\n<p>2016/09/01 北京</p>\n<h2 id=\"考研日记（一）\"><a href=\"#考研日记（一）\" class=\"headerlink\" title=\"考研日记（一）\"></a>考研日记（一）</h2><p><img src=\"/images/daily/1590392806.jpg\" alt=\"\"><br>今天，就算是这段旅程的开始<br>我仍习惯性地把它称之为旅程<br>我静坐于北师教九的一间教室<br>试着去规划未来五个月的日子</p>\n<p>我将重新开始<br>沿着地平线<br>努力拥抱每一个黎明和黄昏</p>\n<p>我将再次出发<br>指着大海的方向<br>虔诚迎接每一个日出和日落</p>\n<p>如果<br>你在途中和我迎面走来<br>请对我报以善意的鼓励和微笑<br>并祝我一路顺风</p>\n<p>2016/08/01 北京</p>\n<h2 id=\"考研于我\"><a href=\"#考研于我\" class=\"headerlink\" title=\"考研于我\"></a>考研于我</h2><p><img src=\"/images/daily/2884524888.jpg\" alt=\"\"></p>\n<blockquote>\n<p>所谓的光辉岁月，并不是后来闪耀的日子，而是无人问津时，你对梦想的偏执。</p>\n</blockquote>\n<p>2016，我想考研。<br>毕业和离开，投身人海和朝九晚五之后，这个想法已经在心底愈来愈强烈。</p>\n<p>总是被一个想法羁绊着，你无法描述那种感觉，但是，你一定会选择在某个时间去做，去实现它。那个想法像是一棵树，可能是因为一些是经历，慢慢生根，发芽，悄然直至有天你发现它已参天蔽日，枝枝蔓蔓充斥你的一切，然后，当决定了要去做的时候，一定要狠狠做，加倍做。</p>\n<p>老妈说，出了社会还想回来难啊，是啊，我说人越成长就越少了想法，所以我想趁着我还有点想法，又有点年轻任性资本的时候，多做点想做的事情，想考研，就当是对梦想的偏执吧。</p>\n<p>2016/02/10 长治</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"考研日记（四）\"><a href=\"#考研日记（四）\" class=\"headerlink\" title=\"考研日记（四）\"></a>考研日记（四）</h2><p>￼<img src=\"/images/daily/613674261.jpeg\" alt=\"\"></p>\n<blockquote>\n<p>老罗说，所有的失败都是因为半途而废。<br>当自习室里越来越多的人弃考，大多数人进入极度的疲惫期，午休的时间比之前都加长，我一定会坚持到最后，在绝望中寻找希望!</p>\n</blockquote>\n<p>如果当你全身心努力去付出后，结果不像理想中那样，还是会很难以接受，毅力根本不是问题，坚持也根本不是问题，只是时间问题。<br>换个角度，努力和经历本身就是一种收获。<br>洗把脸吧，继续奔赴下一个黎明。</p>\n<p>2016/11/01 北京</p>\n<h2 id=\"考研日记（三）\"><a href=\"#考研日记（三）\" class=\"headerlink\" title=\"考研日记（三）\"></a>考研日记（三）</h2><p><img src=\"/images/daily/824027791-2.png\" alt=\"\"></p>\n<blockquote>\n<p>因为你选择了考研，所以你就已经成了你想成为的模样。<br>9月2日，北师开学的日子，迎来新的面孔，送走旧的脸庞，悬挂的横幅上写着：欢迎2016级新同学。这让我想起2012年，在送别父亲的车站，你流着眼泪，带着微笑，穿过熙熙攘攘的人群，在心里和曾经说再见时的希望所向。</p>\n</blockquote>\n<p>9月15日，中秋节的自习室有一丝空旷，不，是空空荡荡。晚上的时候我在木铎下和你说：没事儿，这不过是万千思绪中的一种，你要去的是大海的方向，风浪必然会是你的衣裳，你乘着它，便是远方。</p>\n<p>9月26日，平日里温暖的自习室，参加司考的同学结束了最后的审判，低头收拾铺着的行囊的时候，不经意间在这个秋日的午后，剩下一地的考研er依然坚强。隔墙的走廊变得只有偶尔能听见的几簇上下课走动的声响。你忽地觉得孤单，忽又觉得仓促而又漫长。并不是因为你太容易过于感伤，也不是因为日子就这样一天天成为过往。</p>\n<p>9月30日，在你来不及回望的每个清晨，在东门你驻脚等候的620的站牌旁，你抬头看漫天星辰的时候，你的背影满目八月的模样。</p>\n<p>2016/10/01 北京</p>\n<h2 id=\"考研日记（二）\"><a href=\"#考研日记（二）\" class=\"headerlink\" title=\"考研日记（二）\"></a>考研日记（二）</h2><p><img src=\"/images/daily/788509444.jpg\" alt=\"\"></p>\n<blockquote>\n<p>选择考研，就如同选择种下一粒种子，坚持就会生长，直至参天。</p>\n</blockquote>\n<p>嘿，九月，你好啊！<br>嘿，时光，能不能别走的这么快啊！</p>\n<p>当我背起书包出门，乘着620穿过安立路去了又回，这两个简单的场景便能勾勒出八月的每一个日出和日落。九月的北京，秋天在睡醒一觉后就慕地来临，在清晨睁开眼透过窗外看北五环楼林的时候，彼时天空是那种迷人的蓝，你忽地觉得：岁月如此静好！如此静好！</p>\n<p>原谅我总是要在说正事之前煽情一番。因为，我也总是认为：当一个人在做自己认为值得和有意义的事情的过程中，有必要去记录某些时刻思想的经历和感悟。这样如果多年以后读起年青时写下的文字也定会是别样的思绪万千！努力做一个精神世界美好而富有的人嗬，虽然现实所经历的从不曾如想象那般尽如人意，但这也更能显得弥足珍贵。</p>\n<p>Steve Jobs 说：“We can not connect the dots looking forward; We can only connect them looking backwards.”(我们不能把现在的每个点连接起来去看到未来，但是当我们回头看时，却能把它们串连起来看到对于过去的意义) 。对于一个已经离开校园漂泊很长时间的人来说，离开其实已经是一种勇气，而我理解中的考研过程本身也已变成是一个人内心和精神的修炼。彷徨与痛苦，挫折与欣喜，线条化的生活让人与世隔绝，人生失去颜色却又充满另一种芬芳。</p>\n<p>话说如果你爱一个人，就让他考研，因为那里是天堂，又说如果你恨一个人，也让他考研，因为那里是地狱，当然我考研的动机既不是为了探寻生的理由和存在的意义，自然也不曾爱一个人或恨一个人到要和他一同考研的地步。我选择考研，只是想和一些时期的作为和不作为做个了断，只愿不再自我纠缠。而且这件事啊，非如此不可！非如此不可！我很喜欢戈麦的这首诗，因为有朝一日，真像终将大白于天下。</p>\n<blockquote>\n<p>有朝一日，我会赢得整个世界<br>有朝一日，我将挽回我的损失<br>有朝一日，我将不停地将过去摔打<br>珍视我的人，你没有伪装<br>我将把血肉做成黄金，做成粮食<br>献给你们庄重与博大<br>爱我的人啊，我没有叫你失望<br>你们的等待，虽然灰冷而渺茫<br>但有朝一日，真相将大白于天下<br>辛酸所凝铸的汗水将一一得到补偿</p>\n</blockquote>\n<p>同样也很喜欢《功夫熊猫2》里面师傅对熊猫说的这句话：</p>\n<blockquote>\n<p>“Your story may not have such a happy beginning, but that doesn’t make who your are. It is the rest of your story, who you choose to be.”（你人生故事的开头也许不那么快乐，但这并不影响你成为什么样的人。关键看后来的人生路，你选择怎么走下去。）</p>\n</blockquote>\n<p>2016/09/01 北京</p>\n<h2 id=\"考研日记（一）\"><a href=\"#考研日记（一）\" class=\"headerlink\" title=\"考研日记（一）\"></a>考研日记（一）</h2><p><img src=\"/images/daily/1590392806.jpg\" alt=\"\"><br>今天，就算是这段旅程的开始<br>我仍习惯性地把它称之为旅程<br>我静坐于北师教九的一间教室<br>试着去规划未来五个月的日子</p>\n<p>我将重新开始<br>沿着地平线<br>努力拥抱每一个黎明和黄昏</p>\n<p>我将再次出发<br>指着大海的方向<br>虔诚迎接每一个日出和日落</p>\n<p>如果<br>你在途中和我迎面走来<br>请对我报以善意的鼓励和微笑<br>并祝我一路顺风</p>\n<p>2016/08/01 北京</p>\n<h2 id=\"考研于我\"><a href=\"#考研于我\" class=\"headerlink\" title=\"考研于我\"></a>考研于我</h2><p><img src=\"/images/daily/2884524888.jpg\" alt=\"\"></p>\n<blockquote>\n<p>所谓的光辉岁月，并不是后来闪耀的日子，而是无人问津时，你对梦想的偏执。</p>\n</blockquote>\n<p>2016，我想考研。<br>毕业和离开，投身人海和朝九晚五之后，这个想法已经在心底愈来愈强烈。</p>\n<p>总是被一个想法羁绊着，你无法描述那种感觉，但是，你一定会选择在某个时间去做，去实现它。那个想法像是一棵树，可能是因为一些是经历，慢慢生根，发芽，悄然直至有天你发现它已参天蔽日，枝枝蔓蔓充斥你的一切，然后，当决定了要去做的时候，一定要狠狠做，加倍做。</p>\n<p>老妈说，出了社会还想回来难啊，是啊，我说人越成长就越少了想法，所以我想趁着我还有点想法，又有点年轻任性资本的时候，多做点想做的事情，想考研，就当是对梦想的偏执吧。</p>\n<p>2016/02/10 长治</p>\n"},{"title":"iOS - Category 的使用和优缺点","date":"2018-05-18T06:30:47.000Z","_content":"## 什么是Category?\n分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求；在实际开发中我们都会对系统的一些常用类进行扩展，例如：NSString,Button,Label等；简单来说类别是一种为现有的类添加新方法的方式。利用OC的动态运行时分配机制，category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象的子类就能为现有的类添加新的方法，category可以为任何已经存在的类添加方法，包括系统的框架UIKit等。\n\n## Category的优点：\n- 可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理；也可以对框架提供类的扩展，把不同的功能组织到不同的category里，从而按需加载想要的category。\n- 创建对私有方法的前向引用：如果其他类中的方法未实现时，或者在访问该类私有方法时编译器报错时；在类别中声明这些方法（不必提供方法实现）从而绕过编译器不会再产生警告或者错误。\n- 向对象添加非正式协议：创建一个NSObject的类别成为“创建一个非正式协议”，因为可以作为任何类的委托对象使用（声明私有方法）。\n\napple的SDK中就大面积的使用了category这一特性。比如UIKit中的UIView。apple把不同的功能API进行了分类，这些分类包括UIViewGeometry、UIViewHierarchy、UIViewRendering等。\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\t1. 模拟多继承（另外可以模拟多继承的还有protocol）\n\t2. 把framework的私有方法公开\n\n## Category的局限性：\n- category只能给某个已有的类扩充方法，不能扩充成员变量。\n- category中也可以添加属性，只不过@property只会生成`setter`和`getter`的声明，不会生成实现以及成员变量。\n- 如果category中的方法和类中原有的方法同名，运行时会优先调用category中的方法。也就是，category中的方法会`覆盖`掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同;避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如`category_xxx`。\n- 如果多个category中存在同名的方法，运行时到底调用那个方法由编译器决定，最后一个参与编译的方法会被调用。\n\n如下：给UIView添加两个category（one和two）并且给这两个分类都添加了名为log的方法\n- UIView+One\n``` objc\n#import \"UIView+One.h\"\n\n@implementation UIView (One)\n- (void)log {\n    NSLog(@\"调用One分类的方法\");\n}\n@end\n```\n- UIView+Two\n``` objc\n#import \"UIView+Two.h\"\n\n@implementation UIView (Two)\n- (void)log {\n    NSLog(@\"调用One分类的方法\");\n}\n@end\n```\n- 在UIViewController中引用这两个分类的头文件并调用log方法\n```objc\n#import \"UIView+One.h\"\n#import \"UIView+Two.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIView * view = [UIView new];\n    [view log];\n}\n@end\n```\n\n- 当编译顺序如下图时输出：\n![](/images/compile_last_one.png)\n``` console\n2018-05-18 15:23:13.379081+0800 CategoryDemo[2373:700484] 调用One分类的方法\n```\n- 将UIView+One.m移动到UIView+Two.m上面，编译顺序如下图时输出：\n![](/images/compile_last_two.png)\n``` console\n2018-05-18 15:27:25.008682+0800 CategoryDemo[2441:715950] 调用Two分类的方法\n```\n\n## 调用优先级\nCategory->本类->父类\n\n## 为什么Category不能添加成员变量？\nObjective-C的类是由`Class`类型来表示的，它实际上是一个指向`objc_class`结构体的指针\n```C\ntypedef struct objc_class * Class;\n```\nobjc_class结构体的定义如下：\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                       OBJC2_UNAVAILABLE;  // 父类\n    const char *name                        OBJC2_UNAVAILABLE;  // 类名\n    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表\n    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存\n    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n} OBJC2_UNAVAILABLE;\n```\n在上面的`objc_class`结构体中，`ivars`是`objc_ivar_list`（成员变量列表）指针；`methodLists`是指向`objc_method_list`指针的指针。\n在`Runtime`中，`objc_class`的大小是`固定`的，不可能往这个结构体中添加数据，只能修改。所以`ivars`指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。\n`methodLists`是一个`二维数组`，所以可以修改`*methodLists`的值来增加成员变量方法，虽然没办法扩展`methodLists`指向的内存区域，却可以改变这个内存区域的值（存储的是指针），因此可以动态添加方法，不能添加成员变量。\n\n## Category中能添加属性吗？\nCategory中不能直接添加成员变量，那么可以添加属性吗？\n需要从Category的结构体开始分析：\n```\ntypedef struct category_t {\n    const char *name;  //类的名字\n    classref_t cls;  //类\n    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表\n    struct method_list_t *classMethods;  //category中所有添加的类方法的列表\n    struct protocol_list_t *protocols;  //category实现的所有协议的列表\n    struct property_list_t *instanceProperties;  //category中添加的所有属性\n} category_t;\n```\n从Category的结构体定义`也`可以看出:Category可以添加`实例方法`、`类方法`、`协议`、`属性`，但不能添加`成员变量`（实例变量）\n\n### 为什么网上很多人说Category不可以添加属性?\n实际上，category是可以添加属性的，同样可以使用`@property`，但是不会生成带下划线的成员变量也不会生成属性getter和setter方法的实现。所以，尽管添加了属性，也无法使用点语法调用getter和setter方法（实际上，点语法是可以写的，只不过在运行时调用到这个方法的时候会报Unrecognised selector send to instance的错误），但可以使用Runtime去实现Category为已有的类添加新的属性并生成getter和setter方法\n### 为什么不能为Category手动添加一个下划线开头的成员变量\n成员变量是一个类的东西，而分类本身就不是一个类，它并没有自己的isa指针，分类本来就是OC里通过运行时动态的为一个类添加属性和方法等，不是一个真正的类无法添加成员变量。\n\n>可以使用Runtime技术中的关联对象可以为类别添加属性\n\n## 两点注意：\n1. 当category中的方法和原类中的方法同名时，category中的方法并没有完全替换掉原类中的方法，也就是说如果category和原类中都有一个methodA方法，那么category附加完成之后，类的方法里面会有两个methodA，实际上category的方法只是被放到新方法列表的前面，而原来类的方法只是被放到了新方法列表的后面，这也就是通常说的`覆盖同名方法`；这是因为运行时在查找方法的时候是顺着方法列表顺序查找的，它只要已找到对应名字的方法，就直接调用不会再往后面找了。\n2. 由于category的实现原理，和Objc的动态绑定有很强的关系，所以实际上类的扩展比较占用启动时间，因尽量合并一些在工程，架构上没有太大意义的扩展，会对启动有一定的优化作用。\n\n## 扩展：成员变量和属性的区别？\n@property声明的属性默认会生成一个以下划线开头的成员变量，同事也会生成getter/setter方法。但这仅仅是在iOS5之后，苹果才推出的一个机制。在一些比较老的项目经常可以看到一大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用了@synthesize方法。\n``` Objc\n@interface ViewController ()\n{\n   // 1.声明成员变量\n    NSString * myString;  \n }\n //2.在用@property\n@property(nonatomic, copy) NSString * myString;  \n@end\n\n@implementation ViewController\n//3.最后在@implementation中用synthesize生成set方法\n@synthesize myString;   \n@end\n```\n实际上，发生这种状况的根本原因是苹果将默认编译器从GCC转换为LLVM（low level virtual machine）后，才不再需要为属性声明实例变量了。\n在没有更改之前，属性的正常写法需要 `成员变量 + @property + @synthesize成员变量`三个步骤\n如果我们只写成员变量+@property\n```Objc\n@interface GBViewController :UIViewController\n{\n    NSString * myString;\n}\n@property (nonatomic, strong) NSString * myString;\n@end\n```\n这时，编译器会警告：\n```bash\nAutosynthesized property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString'\n```\n但更换为`LLVM`之后，编译器在编译过程中发现没有生成实例变量时，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量（**注意**：是不必要，不是不可以）\n对于`@synthesize`我们要明白，`@synthesize`不仅可以帮助生成setter/getter方法；同时还有一个作用就是可以指定与属性对应的实例变量\n```Objc\n@synthesize myString = _xxx；\n```\n那么`self.myString`其实是操作的实例变量_xxx，而不是`_myString`了。\n","source":"_posts/ios-category-use-merit-and-demerit.md","raw":"---\ntitle: iOS - Category 的使用和优缺点\ndate: 2018-05-18 14:30:47\ntags: [iOS,Category]\ncategories: [iOS,Objc]\n---\n## 什么是Category?\n分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求；在实际开发中我们都会对系统的一些常用类进行扩展，例如：NSString,Button,Label等；简单来说类别是一种为现有的类添加新方法的方式。利用OC的动态运行时分配机制，category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象的子类就能为现有的类添加新的方法，category可以为任何已经存在的类添加方法，包括系统的框架UIKit等。\n\n## Category的优点：\n- 可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理；也可以对框架提供类的扩展，把不同的功能组织到不同的category里，从而按需加载想要的category。\n- 创建对私有方法的前向引用：如果其他类中的方法未实现时，或者在访问该类私有方法时编译器报错时；在类别中声明这些方法（不必提供方法实现）从而绕过编译器不会再产生警告或者错误。\n- 向对象添加非正式协议：创建一个NSObject的类别成为“创建一个非正式协议”，因为可以作为任何类的委托对象使用（声明私有方法）。\n\napple的SDK中就大面积的使用了category这一特性。比如UIKit中的UIView。apple把不同的功能API进行了分类，这些分类包括UIViewGeometry、UIViewHierarchy、UIViewRendering等。\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\t1. 模拟多继承（另外可以模拟多继承的还有protocol）\n\t2. 把framework的私有方法公开\n\n## Category的局限性：\n- category只能给某个已有的类扩充方法，不能扩充成员变量。\n- category中也可以添加属性，只不过@property只会生成`setter`和`getter`的声明，不会生成实现以及成员变量。\n- 如果category中的方法和类中原有的方法同名，运行时会优先调用category中的方法。也就是，category中的方法会`覆盖`掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同;避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如`category_xxx`。\n- 如果多个category中存在同名的方法，运行时到底调用那个方法由编译器决定，最后一个参与编译的方法会被调用。\n\n如下：给UIView添加两个category（one和two）并且给这两个分类都添加了名为log的方法\n- UIView+One\n``` objc\n#import \"UIView+One.h\"\n\n@implementation UIView (One)\n- (void)log {\n    NSLog(@\"调用One分类的方法\");\n}\n@end\n```\n- UIView+Two\n``` objc\n#import \"UIView+Two.h\"\n\n@implementation UIView (Two)\n- (void)log {\n    NSLog(@\"调用One分类的方法\");\n}\n@end\n```\n- 在UIViewController中引用这两个分类的头文件并调用log方法\n```objc\n#import \"UIView+One.h\"\n#import \"UIView+Two.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIView * view = [UIView new];\n    [view log];\n}\n@end\n```\n\n- 当编译顺序如下图时输出：\n![](/images/compile_last_one.png)\n``` console\n2018-05-18 15:23:13.379081+0800 CategoryDemo[2373:700484] 调用One分类的方法\n```\n- 将UIView+One.m移动到UIView+Two.m上面，编译顺序如下图时输出：\n![](/images/compile_last_two.png)\n``` console\n2018-05-18 15:27:25.008682+0800 CategoryDemo[2441:715950] 调用Two分类的方法\n```\n\n## 调用优先级\nCategory->本类->父类\n\n## 为什么Category不能添加成员变量？\nObjective-C的类是由`Class`类型来表示的，它实际上是一个指向`objc_class`结构体的指针\n```C\ntypedef struct objc_class * Class;\n```\nobjc_class结构体的定义如下：\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class super_class                       OBJC2_UNAVAILABLE;  // 父类\n    const char *name                        OBJC2_UNAVAILABLE;  // 类名\n    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表\n    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存\n    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n} OBJC2_UNAVAILABLE;\n```\n在上面的`objc_class`结构体中，`ivars`是`objc_ivar_list`（成员变量列表）指针；`methodLists`是指向`objc_method_list`指针的指针。\n在`Runtime`中，`objc_class`的大小是`固定`的，不可能往这个结构体中添加数据，只能修改。所以`ivars`指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。\n`methodLists`是一个`二维数组`，所以可以修改`*methodLists`的值来增加成员变量方法，虽然没办法扩展`methodLists`指向的内存区域，却可以改变这个内存区域的值（存储的是指针），因此可以动态添加方法，不能添加成员变量。\n\n## Category中能添加属性吗？\nCategory中不能直接添加成员变量，那么可以添加属性吗？\n需要从Category的结构体开始分析：\n```\ntypedef struct category_t {\n    const char *name;  //类的名字\n    classref_t cls;  //类\n    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表\n    struct method_list_t *classMethods;  //category中所有添加的类方法的列表\n    struct protocol_list_t *protocols;  //category实现的所有协议的列表\n    struct property_list_t *instanceProperties;  //category中添加的所有属性\n} category_t;\n```\n从Category的结构体定义`也`可以看出:Category可以添加`实例方法`、`类方法`、`协议`、`属性`，但不能添加`成员变量`（实例变量）\n\n### 为什么网上很多人说Category不可以添加属性?\n实际上，category是可以添加属性的，同样可以使用`@property`，但是不会生成带下划线的成员变量也不会生成属性getter和setter方法的实现。所以，尽管添加了属性，也无法使用点语法调用getter和setter方法（实际上，点语法是可以写的，只不过在运行时调用到这个方法的时候会报Unrecognised selector send to instance的错误），但可以使用Runtime去实现Category为已有的类添加新的属性并生成getter和setter方法\n### 为什么不能为Category手动添加一个下划线开头的成员变量\n成员变量是一个类的东西，而分类本身就不是一个类，它并没有自己的isa指针，分类本来就是OC里通过运行时动态的为一个类添加属性和方法等，不是一个真正的类无法添加成员变量。\n\n>可以使用Runtime技术中的关联对象可以为类别添加属性\n\n## 两点注意：\n1. 当category中的方法和原类中的方法同名时，category中的方法并没有完全替换掉原类中的方法，也就是说如果category和原类中都有一个methodA方法，那么category附加完成之后，类的方法里面会有两个methodA，实际上category的方法只是被放到新方法列表的前面，而原来类的方法只是被放到了新方法列表的后面，这也就是通常说的`覆盖同名方法`；这是因为运行时在查找方法的时候是顺着方法列表顺序查找的，它只要已找到对应名字的方法，就直接调用不会再往后面找了。\n2. 由于category的实现原理，和Objc的动态绑定有很强的关系，所以实际上类的扩展比较占用启动时间，因尽量合并一些在工程，架构上没有太大意义的扩展，会对启动有一定的优化作用。\n\n## 扩展：成员变量和属性的区别？\n@property声明的属性默认会生成一个以下划线开头的成员变量，同事也会生成getter/setter方法。但这仅仅是在iOS5之后，苹果才推出的一个机制。在一些比较老的项目经常可以看到一大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用了@synthesize方法。\n``` Objc\n@interface ViewController ()\n{\n   // 1.声明成员变量\n    NSString * myString;  \n }\n //2.在用@property\n@property(nonatomic, copy) NSString * myString;  \n@end\n\n@implementation ViewController\n//3.最后在@implementation中用synthesize生成set方法\n@synthesize myString;   \n@end\n```\n实际上，发生这种状况的根本原因是苹果将默认编译器从GCC转换为LLVM（low level virtual machine）后，才不再需要为属性声明实例变量了。\n在没有更改之前，属性的正常写法需要 `成员变量 + @property + @synthesize成员变量`三个步骤\n如果我们只写成员变量+@property\n```Objc\n@interface GBViewController :UIViewController\n{\n    NSString * myString;\n}\n@property (nonatomic, strong) NSString * myString;\n@end\n```\n这时，编译器会警告：\n```bash\nAutosynthesized property 'myString' will use synthesized instance variable '_myString', not existing instance variable 'myString'\n```\n但更换为`LLVM`之后，编译器在编译过程中发现没有生成实例变量时，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量（**注意**：是不必要，不是不可以）\n对于`@synthesize`我们要明白，`@synthesize`不仅可以帮助生成setter/getter方法；同时还有一个作用就是可以指定与属性对应的实例变量\n```Objc\n@synthesize myString = _xxx；\n```\n那么`self.myString`其实是操作的实例变量_xxx，而不是`_myString`了。\n","slug":"ios-category-use-merit-and-demerit","published":1,"updated":"2019-01-13T05:09:18.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2d000pl1fq0pmsisae","content":"<h2 id=\"什么是Category\"><a href=\"#什么是Category\" class=\"headerlink\" title=\"什么是Category?\"></a>什么是Category?</h2><p>分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求；在实际开发中我们都会对系统的一些常用类进行扩展，例如：NSString,Button,Label等；简单来说类别是一种为现有的类添加新方法的方式。利用OC的动态运行时分配机制，category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象的子类就能为现有的类添加新的方法，category可以为任何已经存在的类添加方法，包括系统的框架UIKit等。</p>\n<h2 id=\"Category的优点：\"><a href=\"#Category的优点：\" class=\"headerlink\" title=\"Category的优点：\"></a>Category的优点：</h2><ul>\n<li>可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理；也可以对框架提供类的扩展，把不同的功能组织到不同的category里，从而按需加载想要的category。</li>\n<li>创建对私有方法的前向引用：如果其他类中的方法未实现时，或者在访问该类私有方法时编译器报错时；在类别中声明这些方法（不必提供方法实现）从而绕过编译器不会再产生警告或者错误。</li>\n<li>向对象添加非正式协议：创建一个NSObject的类别成为“创建一个非正式协议”，因为可以作为任何类的委托对象使用（声明私有方法）。</li>\n</ul>\n<p>apple的SDK中就大面积的使用了category这一特性。比如UIKit中的UIView。apple把不同的功能API进行了分类，这些分类包括UIViewGeometry、UIViewHierarchy、UIViewRendering等。<br>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>\n<pre><code>1. 模拟多继承（另外可以模拟多继承的还有protocol）\n2. 把framework的私有方法公开\n</code></pre><h2 id=\"Category的局限性：\"><a href=\"#Category的局限性：\" class=\"headerlink\" title=\"Category的局限性：\"></a>Category的局限性：</h2><ul>\n<li>category只能给某个已有的类扩充方法，不能扩充成员变量。</li>\n<li>category中也可以添加属性，只不过@property只会生成<code>setter</code>和<code>getter</code>的声明，不会生成实现以及成员变量。</li>\n<li>如果category中的方法和类中原有的方法同名，运行时会优先调用category中的方法。也就是，category中的方法会<code>覆盖</code>掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同;避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如<code>category_xxx</code>。</li>\n<li>如果多个category中存在同名的方法，运行时到底调用那个方法由编译器决定，最后一个参与编译的方法会被调用。</li>\n</ul>\n<p>如下：给UIView添加两个category（one和two）并且给这两个分类都添加了名为log的方法</p>\n<ul>\n<li><p>UIView+One</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+One.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIView</span> (<span class=\"title\">One</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)log &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用One分类的方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>UIView+Two</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+Two.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIView</span> (<span class=\"title\">Two</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)log &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用One分类的方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在UIViewController中引用这两个分类的头文件并调用log方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+One.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+Two.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">UIView</span> * view = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">    [view log];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当编译顺序如下图时输出：<br><img src=\"/images/compile_last_one.png\" alt=\"\"></p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-18 15:23:13.379081+0800 CategoryDemo[2373:700484] 调用One分类的方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将UIView+One.m移动到UIView+Two.m上面，编译顺序如下图时输出：<br><img src=\"/images/compile_last_two.png\" alt=\"\"></p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-18 15:27:25.008682+0800 CategoryDemo[2441:715950] 调用Two分类的方法</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"调用优先级\"><a href=\"#调用优先级\" class=\"headerlink\" title=\"调用优先级\"></a>调用优先级</h2><p>Category-&gt;本类-&gt;父类</p>\n<h2 id=\"为什么Category不能添加成员变量？\"><a href=\"#为什么Category不能添加成员变量？\" class=\"headerlink\" title=\"为什么Category不能添加成员变量？\"></a>为什么Category不能添加成员变量？</h2><p>Objective-C的类是由<code>Class</code>类型来表示的，它实际上是一个指向<code>objc_class</code>结构体的指针<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> * <span class=\"title\">Class</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>objc_class结构体的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">    Class super_class                       OBJC2_UNAVAILABLE;  // 父类</span><br><span class=\"line\">    const char *name                        OBJC2_UNAVAILABLE;  // 类名</span><br><span class=\"line\">    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class=\"line\">    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class=\"line\">    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class=\"line\">    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class=\"line\">    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class=\"line\">    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class=\"line\">    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的<code>objc_class</code>结构体中，<code>ivars</code>是<code>objc_ivar_list</code>（成员变量列表）指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。<br>在<code>Runtime</code>中，<code>objc_class</code>的大小是<code>固定</code>的，不可能往这个结构体中添加数据，只能修改。所以<code>ivars</code>指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。<br><code>methodLists</code>是一个<code>二维数组</code>，所以可以修改<code>*methodLists</code>的值来增加成员变量方法，虽然没办法扩展<code>methodLists</code>指向的内存区域，却可以改变这个内存区域的值（存储的是指针），因此可以动态添加方法，不能添加成员变量。</p>\n<h2 id=\"Category中能添加属性吗？\"><a href=\"#Category中能添加属性吗？\" class=\"headerlink\" title=\"Category中能添加属性吗？\"></a>Category中能添加属性吗？</h2><p>Category中不能直接添加成员变量，那么可以添加属性吗？<br>需要从Category的结构体开始分析：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct category_t &#123;</span><br><span class=\"line\">    const char *name;  //类的名字</span><br><span class=\"line\">    classref_t cls;  //类</span><br><span class=\"line\">    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表</span><br><span class=\"line\">    struct method_list_t *classMethods;  //category中所有添加的类方法的列表</span><br><span class=\"line\">    struct protocol_list_t *protocols;  //category实现的所有协议的列表</span><br><span class=\"line\">    struct property_list_t *instanceProperties;  //category中添加的所有属性</span><br><span class=\"line\">&#125; category_t;</span><br></pre></td></tr></table></figure></p>\n<p>从Category的结构体定义<code>也</code>可以看出:Category可以添加<code>实例方法</code>、<code>类方法</code>、<code>协议</code>、<code>属性</code>，但不能添加<code>成员变量</code>（实例变量）</p>\n<h3 id=\"为什么网上很多人说Category不可以添加属性\"><a href=\"#为什么网上很多人说Category不可以添加属性\" class=\"headerlink\" title=\"为什么网上很多人说Category不可以添加属性?\"></a>为什么网上很多人说Category不可以添加属性?</h3><p>实际上，category是可以添加属性的，同样可以使用<code>@property</code>，但是不会生成带下划线的成员变量也不会生成属性getter和setter方法的实现。所以，尽管添加了属性，也无法使用点语法调用getter和setter方法（实际上，点语法是可以写的，只不过在运行时调用到这个方法的时候会报Unrecognised selector send to instance的错误），但可以使用Runtime去实现Category为已有的类添加新的属性并生成getter和setter方法</p>\n<h3 id=\"为什么不能为Category手动添加一个下划线开头的成员变量\"><a href=\"#为什么不能为Category手动添加一个下划线开头的成员变量\" class=\"headerlink\" title=\"为什么不能为Category手动添加一个下划线开头的成员变量\"></a>为什么不能为Category手动添加一个下划线开头的成员变量</h3><p>成员变量是一个类的东西，而分类本身就不是一个类，它并没有自己的isa指针，分类本来就是OC里通过运行时动态的为一个类添加属性和方法等，不是一个真正的类无法添加成员变量。</p>\n<blockquote>\n<p>可以使用Runtime技术中的关联对象可以为类别添加属性</p>\n</blockquote>\n<h2 id=\"两点注意：\"><a href=\"#两点注意：\" class=\"headerlink\" title=\"两点注意：\"></a>两点注意：</h2><ol>\n<li>当category中的方法和原类中的方法同名时，category中的方法并没有完全替换掉原类中的方法，也就是说如果category和原类中都有一个methodA方法，那么category附加完成之后，类的方法里面会有两个methodA，实际上category的方法只是被放到新方法列表的前面，而原来类的方法只是被放到了新方法列表的后面，这也就是通常说的<code>覆盖同名方法</code>；这是因为运行时在查找方法的时候是顺着方法列表顺序查找的，它只要已找到对应名字的方法，就直接调用不会再往后面找了。</li>\n<li>由于category的实现原理，和Objc的动态绑定有很强的关系，所以实际上类的扩展比较占用启动时间，因尽量合并一些在工程，架构上没有太大意义的扩展，会对启动有一定的优化作用。</li>\n</ol>\n<h2 id=\"扩展：成员变量和属性的区别？\"><a href=\"#扩展：成员变量和属性的区别？\" class=\"headerlink\" title=\"扩展：成员变量和属性的区别？\"></a>扩展：成员变量和属性的区别？</h2><p>@property声明的属性默认会生成一个以下划线开头的成员变量，同事也会生成getter/setter方法。但这仅仅是在iOS5之后，苹果才推出的一个机制。在一些比较老的项目经常可以看到一大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用了@synthesize方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.声明成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * myString;  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//2.在用@property</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> * myString;  </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"><span class=\"comment\">//3.最后在@implementation中用synthesize生成set方法</span></span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> myString;   </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>实际上，发生这种状况的根本原因是苹果将默认编译器从GCC转换为LLVM（low level virtual machine）后，才不再需要为属性声明实例变量了。<br>在没有更改之前，属性的正常写法需要 <code>成员变量 + @property + @synthesize成员变量</code>三个步骤<br>如果我们只写成员变量+@property<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GBViewController</span> :<span class=\"title\">UIViewController</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * myString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> * myString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>这时，编译器会警告：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Autosynthesized property <span class=\"string\">'myString'</span> will use synthesized instance variable <span class=\"string\">'_myString'</span>, not existing instance variable <span class=\"string\">'myString'</span></span><br></pre></td></tr></table></figure></p>\n<p>但更换为<code>LLVM</code>之后，编译器在编译过程中发现没有生成实例变量时，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量（<strong>注意</strong>：是不必要，不是不可以）<br>对于<code>@synthesize</code>我们要明白，<code>@synthesize</code>不仅可以帮助生成setter/getter方法；同时还有一个作用就是可以指定与属性对应的实例变量<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synthesize</span> myString = _xxx；</span><br></pre></td></tr></table></figure></p>\n<p>那么<code>self.myString</code>其实是操作的实例变量_xxx，而不是<code>_myString</code>了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Category\"><a href=\"#什么是Category\" class=\"headerlink\" title=\"什么是Category?\"></a>什么是Category?</h2><p>分类就是对一个类的功能进行扩展，让这个类能够适应不同情况的需求；在实际开发中我们都会对系统的一些常用类进行扩展，例如：NSString,Button,Label等；简单来说类别是一种为现有的类添加新方法的方式。利用OC的动态运行时分配机制，category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象的子类就能为现有的类添加新的方法，category可以为任何已经存在的类添加方法，包括系统的框架UIKit等。</p>\n<h2 id=\"Category的优点：\"><a href=\"#Category的优点：\" class=\"headerlink\" title=\"Category的优点：\"></a>Category的优点：</h2><ul>\n<li>可以将类的实现分散到多个不同的文件或者不同的框架中，方便代码的管理；也可以对框架提供类的扩展，把不同的功能组织到不同的category里，从而按需加载想要的category。</li>\n<li>创建对私有方法的前向引用：如果其他类中的方法未实现时，或者在访问该类私有方法时编译器报错时；在类别中声明这些方法（不必提供方法实现）从而绕过编译器不会再产生警告或者错误。</li>\n<li>向对象添加非正式协议：创建一个NSObject的类别成为“创建一个非正式协议”，因为可以作为任何类的委托对象使用（声明私有方法）。</li>\n</ul>\n<p>apple的SDK中就大面积的使用了category这一特性。比如UIKit中的UIView。apple把不同的功能API进行了分类，这些分类包括UIViewGeometry、UIViewHierarchy、UIViewRendering等。<br>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>\n<pre><code>1. 模拟多继承（另外可以模拟多继承的还有protocol）\n2. 把framework的私有方法公开\n</code></pre><h2 id=\"Category的局限性：\"><a href=\"#Category的局限性：\" class=\"headerlink\" title=\"Category的局限性：\"></a>Category的局限性：</h2><ul>\n<li>category只能给某个已有的类扩充方法，不能扩充成员变量。</li>\n<li>category中也可以添加属性，只不过@property只会生成<code>setter</code>和<code>getter</code>的声明，不会生成实现以及成员变量。</li>\n<li>如果category中的方法和类中原有的方法同名，运行时会优先调用category中的方法。也就是，category中的方法会<code>覆盖</code>掉类中原有的方法。所以开发中尽量保证不要让分类中的方法和原有类中的方法名相同;避免出现这种情况的解决方案是给分类的方法名统一添加前缀。比如<code>category_xxx</code>。</li>\n<li>如果多个category中存在同名的方法，运行时到底调用那个方法由编译器决定，最后一个参与编译的方法会被调用。</li>\n</ul>\n<p>如下：给UIView添加两个category（one和two）并且给这两个分类都添加了名为log的方法</p>\n<ul>\n<li><p>UIView+One</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+One.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIView</span> (<span class=\"title\">One</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)log &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用One分类的方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>UIView+Two</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+Two.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIView</span> (<span class=\"title\">Two</span>)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)log &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"调用One分类的方法\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在UIViewController中引用这两个分类的头文件并调用log方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+One.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIView+Two.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">UIView</span> * view = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">    [view log];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当编译顺序如下图时输出：<br><img src=\"/images/compile_last_one.png\" alt=\"\"></p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-18 15:23:13.379081+0800 CategoryDemo[2373:700484] 调用One分类的方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将UIView+One.m移动到UIView+Two.m上面，编译顺序如下图时输出：<br><img src=\"/images/compile_last_two.png\" alt=\"\"></p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-18 15:27:25.008682+0800 CategoryDemo[2441:715950] 调用Two分类的方法</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"调用优先级\"><a href=\"#调用优先级\" class=\"headerlink\" title=\"调用优先级\"></a>调用优先级</h2><p>Category-&gt;本类-&gt;父类</p>\n<h2 id=\"为什么Category不能添加成员变量？\"><a href=\"#为什么Category不能添加成员变量？\" class=\"headerlink\" title=\"为什么Category不能添加成员变量？\"></a>为什么Category不能添加成员变量？</h2><p>Objective-C的类是由<code>Class</code>类型来表示的，它实际上是一个指向<code>objc_class</code>结构体的指针<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> * <span class=\"title\">Class</span>;</span></span><br></pre></td></tr></table></figure></p>\n<p>objc_class结构体的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">    Class super_class                       OBJC2_UNAVAILABLE;  // 父类</span><br><span class=\"line\">    const char *name                        OBJC2_UNAVAILABLE;  // 类名</span><br><span class=\"line\">    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class=\"line\">    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class=\"line\">    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class=\"line\">    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class=\"line\">    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class=\"line\">    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class=\"line\">    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的<code>objc_class</code>结构体中，<code>ivars</code>是<code>objc_ivar_list</code>（成员变量列表）指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。<br>在<code>Runtime</code>中，<code>objc_class</code>的大小是<code>固定</code>的，不可能往这个结构体中添加数据，只能修改。所以<code>ivars</code>指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。<br><code>methodLists</code>是一个<code>二维数组</code>，所以可以修改<code>*methodLists</code>的值来增加成员变量方法，虽然没办法扩展<code>methodLists</code>指向的内存区域，却可以改变这个内存区域的值（存储的是指针），因此可以动态添加方法，不能添加成员变量。</p>\n<h2 id=\"Category中能添加属性吗？\"><a href=\"#Category中能添加属性吗？\" class=\"headerlink\" title=\"Category中能添加属性吗？\"></a>Category中能添加属性吗？</h2><p>Category中不能直接添加成员变量，那么可以添加属性吗？<br>需要从Category的结构体开始分析：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct category_t &#123;</span><br><span class=\"line\">    const char *name;  //类的名字</span><br><span class=\"line\">    classref_t cls;  //类</span><br><span class=\"line\">    struct method_list_t *instanceMethods;  //category中所有给类添加的实例方法的列表</span><br><span class=\"line\">    struct method_list_t *classMethods;  //category中所有添加的类方法的列表</span><br><span class=\"line\">    struct protocol_list_t *protocols;  //category实现的所有协议的列表</span><br><span class=\"line\">    struct property_list_t *instanceProperties;  //category中添加的所有属性</span><br><span class=\"line\">&#125; category_t;</span><br></pre></td></tr></table></figure></p>\n<p>从Category的结构体定义<code>也</code>可以看出:Category可以添加<code>实例方法</code>、<code>类方法</code>、<code>协议</code>、<code>属性</code>，但不能添加<code>成员变量</code>（实例变量）</p>\n<h3 id=\"为什么网上很多人说Category不可以添加属性\"><a href=\"#为什么网上很多人说Category不可以添加属性\" class=\"headerlink\" title=\"为什么网上很多人说Category不可以添加属性?\"></a>为什么网上很多人说Category不可以添加属性?</h3><p>实际上，category是可以添加属性的，同样可以使用<code>@property</code>，但是不会生成带下划线的成员变量也不会生成属性getter和setter方法的实现。所以，尽管添加了属性，也无法使用点语法调用getter和setter方法（实际上，点语法是可以写的，只不过在运行时调用到这个方法的时候会报Unrecognised selector send to instance的错误），但可以使用Runtime去实现Category为已有的类添加新的属性并生成getter和setter方法</p>\n<h3 id=\"为什么不能为Category手动添加一个下划线开头的成员变量\"><a href=\"#为什么不能为Category手动添加一个下划线开头的成员变量\" class=\"headerlink\" title=\"为什么不能为Category手动添加一个下划线开头的成员变量\"></a>为什么不能为Category手动添加一个下划线开头的成员变量</h3><p>成员变量是一个类的东西，而分类本身就不是一个类，它并没有自己的isa指针，分类本来就是OC里通过运行时动态的为一个类添加属性和方法等，不是一个真正的类无法添加成员变量。</p>\n<blockquote>\n<p>可以使用Runtime技术中的关联对象可以为类别添加属性</p>\n</blockquote>\n<h2 id=\"两点注意：\"><a href=\"#两点注意：\" class=\"headerlink\" title=\"两点注意：\"></a>两点注意：</h2><ol>\n<li>当category中的方法和原类中的方法同名时，category中的方法并没有完全替换掉原类中的方法，也就是说如果category和原类中都有一个methodA方法，那么category附加完成之后，类的方法里面会有两个methodA，实际上category的方法只是被放到新方法列表的前面，而原来类的方法只是被放到了新方法列表的后面，这也就是通常说的<code>覆盖同名方法</code>；这是因为运行时在查找方法的时候是顺着方法列表顺序查找的，它只要已找到对应名字的方法，就直接调用不会再往后面找了。</li>\n<li>由于category的实现原理，和Objc的动态绑定有很强的关系，所以实际上类的扩展比较占用启动时间，因尽量合并一些在工程，架构上没有太大意义的扩展，会对启动有一定的优化作用。</li>\n</ol>\n<h2 id=\"扩展：成员变量和属性的区别？\"><a href=\"#扩展：成员变量和属性的区别？\" class=\"headerlink\" title=\"扩展：成员变量和属性的区别？\"></a>扩展：成员变量和属性的区别？</h2><p>@property声明的属性默认会生成一个以下划线开头的成员变量，同事也会生成getter/setter方法。但这仅仅是在iOS5之后，苹果才推出的一个机制。在一些比较老的项目经常可以看到一大括号里面定义了成员变量，同时用了@property声明，而且还在@implementation中使用了@synthesize方法。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 1.声明成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * myString;  </span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//2.在用@property</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> * myString;  </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"><span class=\"comment\">//3.最后在@implementation中用synthesize生成set方法</span></span><br><span class=\"line\"><span class=\"keyword\">@synthesize</span> myString;   </span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>实际上，发生这种状况的根本原因是苹果将默认编译器从GCC转换为LLVM（low level virtual machine）后，才不再需要为属性声明实例变量了。<br>在没有更改之前，属性的正常写法需要 <code>成员变量 + @property + @synthesize成员变量</code>三个步骤<br>如果我们只写成员变量+@property<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">GBViewController</span> :<span class=\"title\">UIViewController</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * myString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> * myString;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>这时，编译器会警告：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Autosynthesized property <span class=\"string\">'myString'</span> will use synthesized instance variable <span class=\"string\">'_myString'</span>, not existing instance variable <span class=\"string\">'myString'</span></span><br></pre></td></tr></table></figure></p>\n<p>但更换为<code>LLVM</code>之后，编译器在编译过程中发现没有生成实例变量时，就会生成一个下划线开头的实例变量。因此现在我们不必在声明一个实例变量（<strong>注意</strong>：是不必要，不是不可以）<br>对于<code>@synthesize</code>我们要明白，<code>@synthesize</code>不仅可以帮助生成setter/getter方法；同时还有一个作用就是可以指定与属性对应的实例变量<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synthesize</span> myString = _xxx；</span><br></pre></td></tr></table></figure></p>\n<p>那么<code>self.myString</code>其实是操作的实例变量_xxx，而不是<code>_myString</code>了。</p>\n"},{"title":"2017，我想和这个世界谈谈","date":"2017-12-31T02:01:47.000Z","_content":"\n## 2017，我想和这个世界谈谈\n\n题记：一年又一年，时光不断催人向前，2017，我想和这个世界谈谈，心平气和的娓娓诉说。\n\n> “We can not connect the dots looking forward; We can only connect them looking backwards.”\n\n再次引用Jobs的这句话，站在2016即将走完的今天，回顾2016时候，我仍然坚定的相信在未来的某天，能够看到这一年的每一个决定和选择对于未来的意义。\n\n- 2016，在这一年，终于完成挑战和梦想之旅，走完了318川藏段全程。\n\n今年是我人生走过的第二十二个岁月，很多人在这个犯二的年龄都会做着自己喜欢的事情，不管对与错，因为我们年轻，青春是我们最大的任性。6月10日从成都出发，25天，2000多公里，25篇骑行日志记录了全程骑行的人和事，身高还是183，只是瘦了20斤。318三个简单的数字，对特定的一群人来说，勾勒出的，是意志力和耐力的见证，是想起来就会感动久久的回忆，而对我来说也应当是重要的转折点，318的故事很长，难以界定起点和终点，或者说，我不想知道哪里才是起止，一段旅行，一人，一车，仅此而已。我所认为的世界观是走出来的，看到的，听到的，真的也好，假象也罢，经历本身就很美好。\n\n临行前的各种憧憬并期待，有些兴奋，想着应该会探索到很多想要的答案，可是到后来你会觉得，其实人生，并没有所谓的答案，可能一直就是在寻找中度过。6月6日，我和磊哥，带着各种装备，大包小包，飞离北京，那天的首都机场，暴雨整整倾泻了四个多小时，八点的航班晚点到十二点才起飞，到达成都青旅时已是凌晨四点。成都，凌晨四点仍然等候的阿铭，三巷一号调车的大哥，陪伴我走完全程的老七，你们好吗？相隔半年之期，关于这一切我已不再时常惦念，只是偶尔想起时会微笑，幸福的那种...\n![](/images/daily/3122621194.jpeg)\n- 2016，在这一年，终于考研了。\n\n嘿嘿，这两个字说出来其实对于我承载着太多特殊的意义。如果说川藏之行是身体上的折磨和挑战的话，那么考研便是心理和精神上。（8.1-12.25）147页日历见证了走过的考研岁月,4篇考研日志记录了片段的考研心路历程。道长说其实人的一生改变命运的机会不多，而高考和考研便是其中为数不多的两次，此刻，当我端坐在电脑前，敲下这些文字的时候，距离2017研究生考试结束已经过去了5天，身体和精神上也都已不再是冲刺的状态，像是一根憋足了劲儿的弹簧，从考完的那一刻，从头到脚，无力感像潮水般涌来，专业课交卷的那一霎，我仰天长叹，这一叹伴着呼吸在零度的长治凝结成白色的雾气，我望着它缓缓地升腾，渐渐消散，最终分不清是雾气还是白云。再抬头，一缕阳光照在我的脸上，也照进我的心底。\n\n当2017年全国硕士研究生统一考试的初试告一段落，当在凌晨六点生物钟自动醒来的时候，我想从某种意义上说，考研过程和结果本身都会在一定程度上影响一个人的生命的厚度，而且无关于成败。如果有人问我，考研给予我最多的是什么。我想就是考研岁月所经历的一切...\n\n引用王江涛老师的的一句话说：“考研是人生中的小小驿站。人生关键处只有为数不多的几次选择，考研正是这样的一次拼搏。每当旭日东升，正处于酣战中的你突然觉得前途渺茫的时候，请记住四个字：“永不放弃！”，多年以后当珍贵的大学光阴已经随风而逝时，希望还能记得今天，记得2016年这场残酷而美丽的战斗。”\n\n![](/images/daily/2233356333.jpeg)\n\n- 2017，但行好事，莫问前程。\n后记：考研恍若一梦，愿大家都能笑着醒来。\n\n2017/12/31  长治","source":"_posts/daily-2017-0231.md","raw":"---\ntitle: 2017，我想和这个世界谈谈\ndate: 2017-12-31 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 2017，我想和这个世界谈谈\n\n题记：一年又一年，时光不断催人向前，2017，我想和这个世界谈谈，心平气和的娓娓诉说。\n\n> “We can not connect the dots looking forward; We can only connect them looking backwards.”\n\n再次引用Jobs的这句话，站在2016即将走完的今天，回顾2016时候，我仍然坚定的相信在未来的某天，能够看到这一年的每一个决定和选择对于未来的意义。\n\n- 2016，在这一年，终于完成挑战和梦想之旅，走完了318川藏段全程。\n\n今年是我人生走过的第二十二个岁月，很多人在这个犯二的年龄都会做着自己喜欢的事情，不管对与错，因为我们年轻，青春是我们最大的任性。6月10日从成都出发，25天，2000多公里，25篇骑行日志记录了全程骑行的人和事，身高还是183，只是瘦了20斤。318三个简单的数字，对特定的一群人来说，勾勒出的，是意志力和耐力的见证，是想起来就会感动久久的回忆，而对我来说也应当是重要的转折点，318的故事很长，难以界定起点和终点，或者说，我不想知道哪里才是起止，一段旅行，一人，一车，仅此而已。我所认为的世界观是走出来的，看到的，听到的，真的也好，假象也罢，经历本身就很美好。\n\n临行前的各种憧憬并期待，有些兴奋，想着应该会探索到很多想要的答案，可是到后来你会觉得，其实人生，并没有所谓的答案，可能一直就是在寻找中度过。6月6日，我和磊哥，带着各种装备，大包小包，飞离北京，那天的首都机场，暴雨整整倾泻了四个多小时，八点的航班晚点到十二点才起飞，到达成都青旅时已是凌晨四点。成都，凌晨四点仍然等候的阿铭，三巷一号调车的大哥，陪伴我走完全程的老七，你们好吗？相隔半年之期，关于这一切我已不再时常惦念，只是偶尔想起时会微笑，幸福的那种...\n![](/images/daily/3122621194.jpeg)\n- 2016，在这一年，终于考研了。\n\n嘿嘿，这两个字说出来其实对于我承载着太多特殊的意义。如果说川藏之行是身体上的折磨和挑战的话，那么考研便是心理和精神上。（8.1-12.25）147页日历见证了走过的考研岁月,4篇考研日志记录了片段的考研心路历程。道长说其实人的一生改变命运的机会不多，而高考和考研便是其中为数不多的两次，此刻，当我端坐在电脑前，敲下这些文字的时候，距离2017研究生考试结束已经过去了5天，身体和精神上也都已不再是冲刺的状态，像是一根憋足了劲儿的弹簧，从考完的那一刻，从头到脚，无力感像潮水般涌来，专业课交卷的那一霎，我仰天长叹，这一叹伴着呼吸在零度的长治凝结成白色的雾气，我望着它缓缓地升腾，渐渐消散，最终分不清是雾气还是白云。再抬头，一缕阳光照在我的脸上，也照进我的心底。\n\n当2017年全国硕士研究生统一考试的初试告一段落，当在凌晨六点生物钟自动醒来的时候，我想从某种意义上说，考研过程和结果本身都会在一定程度上影响一个人的生命的厚度，而且无关于成败。如果有人问我，考研给予我最多的是什么。我想就是考研岁月所经历的一切...\n\n引用王江涛老师的的一句话说：“考研是人生中的小小驿站。人生关键处只有为数不多的几次选择，考研正是这样的一次拼搏。每当旭日东升，正处于酣战中的你突然觉得前途渺茫的时候，请记住四个字：“永不放弃！”，多年以后当珍贵的大学光阴已经随风而逝时，希望还能记得今天，记得2016年这场残酷而美丽的战斗。”\n\n![](/images/daily/2233356333.jpeg)\n\n- 2017，但行好事，莫问前程。\n后记：考研恍若一梦，愿大家都能笑着醒来。\n\n2017/12/31  长治","slug":"daily-2017-0231","published":1,"updated":"2019-01-13T09:49:45.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2e000sl1fq09oj4fj6","content":"<h2 id=\"2017，我想和这个世界谈谈\"><a href=\"#2017，我想和这个世界谈谈\" class=\"headerlink\" title=\"2017，我想和这个世界谈谈\"></a>2017，我想和这个世界谈谈</h2><p>题记：一年又一年，时光不断催人向前，2017，我想和这个世界谈谈，心平气和的娓娓诉说。</p>\n<blockquote>\n<p>“We can not connect the dots looking forward; We can only connect them looking backwards.”</p>\n</blockquote>\n<p>再次引用Jobs的这句话，站在2016即将走完的今天，回顾2016时候，我仍然坚定的相信在未来的某天，能够看到这一年的每一个决定和选择对于未来的意义。</p>\n<ul>\n<li>2016，在这一年，终于完成挑战和梦想之旅，走完了318川藏段全程。</li>\n</ul>\n<p>今年是我人生走过的第二十二个岁月，很多人在这个犯二的年龄都会做着自己喜欢的事情，不管对与错，因为我们年轻，青春是我们最大的任性。6月10日从成都出发，25天，2000多公里，25篇骑行日志记录了全程骑行的人和事，身高还是183，只是瘦了20斤。318三个简单的数字，对特定的一群人来说，勾勒出的，是意志力和耐力的见证，是想起来就会感动久久的回忆，而对我来说也应当是重要的转折点，318的故事很长，难以界定起点和终点，或者说，我不想知道哪里才是起止，一段旅行，一人，一车，仅此而已。我所认为的世界观是走出来的，看到的，听到的，真的也好，假象也罢，经历本身就很美好。</p>\n<p>临行前的各种憧憬并期待，有些兴奋，想着应该会探索到很多想要的答案，可是到后来你会觉得，其实人生，并没有所谓的答案，可能一直就是在寻找中度过。6月6日，我和磊哥，带着各种装备，大包小包，飞离北京，那天的首都机场，暴雨整整倾泻了四个多小时，八点的航班晚点到十二点才起飞，到达成都青旅时已是凌晨四点。成都，凌晨四点仍然等候的阿铭，三巷一号调车的大哥，陪伴我走完全程的老七，你们好吗？相隔半年之期，关于这一切我已不再时常惦念，只是偶尔想起时会微笑，幸福的那种…<br><img src=\"/images/daily/3122621194.jpeg\" alt=\"\"></p>\n<ul>\n<li>2016，在这一年，终于考研了。</li>\n</ul>\n<p>嘿嘿，这两个字说出来其实对于我承载着太多特殊的意义。如果说川藏之行是身体上的折磨和挑战的话，那么考研便是心理和精神上。（8.1-12.25）147页日历见证了走过的考研岁月,4篇考研日志记录了片段的考研心路历程。道长说其实人的一生改变命运的机会不多，而高考和考研便是其中为数不多的两次，此刻，当我端坐在电脑前，敲下这些文字的时候，距离2017研究生考试结束已经过去了5天，身体和精神上也都已不再是冲刺的状态，像是一根憋足了劲儿的弹簧，从考完的那一刻，从头到脚，无力感像潮水般涌来，专业课交卷的那一霎，我仰天长叹，这一叹伴着呼吸在零度的长治凝结成白色的雾气，我望着它缓缓地升腾，渐渐消散，最终分不清是雾气还是白云。再抬头，一缕阳光照在我的脸上，也照进我的心底。</p>\n<p>当2017年全国硕士研究生统一考试的初试告一段落，当在凌晨六点生物钟自动醒来的时候，我想从某种意义上说，考研过程和结果本身都会在一定程度上影响一个人的生命的厚度，而且无关于成败。如果有人问我，考研给予我最多的是什么。我想就是考研岁月所经历的一切…</p>\n<p>引用王江涛老师的的一句话说：“考研是人生中的小小驿站。人生关键处只有为数不多的几次选择，考研正是这样的一次拼搏。每当旭日东升，正处于酣战中的你突然觉得前途渺茫的时候，请记住四个字：“永不放弃！”，多年以后当珍贵的大学光阴已经随风而逝时，希望还能记得今天，记得2016年这场残酷而美丽的战斗。”</p>\n<p><img src=\"/images/daily/2233356333.jpeg\" alt=\"\"></p>\n<ul>\n<li>2017，但行好事，莫问前程。<br>后记：考研恍若一梦，愿大家都能笑着醒来。</li>\n</ul>\n<p>2017/12/31  长治</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2017，我想和这个世界谈谈\"><a href=\"#2017，我想和这个世界谈谈\" class=\"headerlink\" title=\"2017，我想和这个世界谈谈\"></a>2017，我想和这个世界谈谈</h2><p>题记：一年又一年，时光不断催人向前，2017，我想和这个世界谈谈，心平气和的娓娓诉说。</p>\n<blockquote>\n<p>“We can not connect the dots looking forward; We can only connect them looking backwards.”</p>\n</blockquote>\n<p>再次引用Jobs的这句话，站在2016即将走完的今天，回顾2016时候，我仍然坚定的相信在未来的某天，能够看到这一年的每一个决定和选择对于未来的意义。</p>\n<ul>\n<li>2016，在这一年，终于完成挑战和梦想之旅，走完了318川藏段全程。</li>\n</ul>\n<p>今年是我人生走过的第二十二个岁月，很多人在这个犯二的年龄都会做着自己喜欢的事情，不管对与错，因为我们年轻，青春是我们最大的任性。6月10日从成都出发，25天，2000多公里，25篇骑行日志记录了全程骑行的人和事，身高还是183，只是瘦了20斤。318三个简单的数字，对特定的一群人来说，勾勒出的，是意志力和耐力的见证，是想起来就会感动久久的回忆，而对我来说也应当是重要的转折点，318的故事很长，难以界定起点和终点，或者说，我不想知道哪里才是起止，一段旅行，一人，一车，仅此而已。我所认为的世界观是走出来的，看到的，听到的，真的也好，假象也罢，经历本身就很美好。</p>\n<p>临行前的各种憧憬并期待，有些兴奋，想着应该会探索到很多想要的答案，可是到后来你会觉得，其实人生，并没有所谓的答案，可能一直就是在寻找中度过。6月6日，我和磊哥，带着各种装备，大包小包，飞离北京，那天的首都机场，暴雨整整倾泻了四个多小时，八点的航班晚点到十二点才起飞，到达成都青旅时已是凌晨四点。成都，凌晨四点仍然等候的阿铭，三巷一号调车的大哥，陪伴我走完全程的老七，你们好吗？相隔半年之期，关于这一切我已不再时常惦念，只是偶尔想起时会微笑，幸福的那种…<br><img src=\"/images/daily/3122621194.jpeg\" alt=\"\"></p>\n<ul>\n<li>2016，在这一年，终于考研了。</li>\n</ul>\n<p>嘿嘿，这两个字说出来其实对于我承载着太多特殊的意义。如果说川藏之行是身体上的折磨和挑战的话，那么考研便是心理和精神上。（8.1-12.25）147页日历见证了走过的考研岁月,4篇考研日志记录了片段的考研心路历程。道长说其实人的一生改变命运的机会不多，而高考和考研便是其中为数不多的两次，此刻，当我端坐在电脑前，敲下这些文字的时候，距离2017研究生考试结束已经过去了5天，身体和精神上也都已不再是冲刺的状态，像是一根憋足了劲儿的弹簧，从考完的那一刻，从头到脚，无力感像潮水般涌来，专业课交卷的那一霎，我仰天长叹，这一叹伴着呼吸在零度的长治凝结成白色的雾气，我望着它缓缓地升腾，渐渐消散，最终分不清是雾气还是白云。再抬头，一缕阳光照在我的脸上，也照进我的心底。</p>\n<p>当2017年全国硕士研究生统一考试的初试告一段落，当在凌晨六点生物钟自动醒来的时候，我想从某种意义上说，考研过程和结果本身都会在一定程度上影响一个人的生命的厚度，而且无关于成败。如果有人问我，考研给予我最多的是什么。我想就是考研岁月所经历的一切…</p>\n<p>引用王江涛老师的的一句话说：“考研是人生中的小小驿站。人生关键处只有为数不多的几次选择，考研正是这样的一次拼搏。每当旭日东升，正处于酣战中的你突然觉得前途渺茫的时候，请记住四个字：“永不放弃！”，多年以后当珍贵的大学光阴已经随风而逝时，希望还能记得今天，记得2016年这场残酷而美丽的战斗。”</p>\n<p><img src=\"/images/daily/2233356333.jpeg\" alt=\"\"></p>\n<ul>\n<li>2017，但行好事，莫问前程。<br>后记：考研恍若一梦，愿大家都能笑着醒来。</li>\n</ul>\n<p>2017/12/31  长治</p>\n"},{"title":"strong、weak、copy、retain和assign的区别","date":"2018-05-18T06:12:00.000Z","_content":"\n## assign：\n`assign`一般用来修饰基本的数据类型，包括基础数据类型（NSInteger,CGFloat）和C语言数据类型（int,float,double,char）等等。因为assign声明的属性，是不会增加引用计数的，也就是说声明的属性释放后也就没有了，及时其他对象引用了它也不会保留，只会造成crash。但是及时被释放，指针却还在，成为了`野指针`，如果新的对象被分配到了这个内存地址上，又会造成crash。所以一般只用来声明基本的数据类型，因为它们会被分配到`栈区`上，而栈取由系统`自动管理`，不会造成野指针。\n\n## retain：\n与assign相对，我们要解决`对象`被其他对象引用后释放造成的问题，就需要用`retain`来声明。使用retain声明的对象会`更改引用计数`，每次被引用，引用计数都会`+1`，释放后就会`-1`。即使这个对象本身被释放了，只要还有对象在引用它，该对象就会`仍然持有`，不会出现任何问题。并且只有当引用`计数为0时`，就会被`dealloc`析构函数回收进内存。\n\n## copy：\n最常见到的copy的声明使用是 NSString 等。copy与retain的`区别`在于：retain是拷贝内存指针地址，而copy是拷贝对象本身；也就是说retain是`浅复制`，copy是`深复制`；如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在`NSString`这一类有`可变类型对象`的身上使用`copy`关键字，是因为他们有可能和对应的可变类型如 `NSMutableString` 之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了 `NSCopying` 协议的`对象类型`有效。\n\n## weak：\nweak是由ARC新引入的对象变量属性，weak类似于assign，叫`弱引用`，也是不增加引用计数，不同在于week指向对象类型时，当对象被释放会指向nil，而assign则会造成野指针。一般只有在防止循环引用时候使用；比如父类引用了子类，子类又引用父类；IBOutlet、Delegate等一般就是使用week，这是因为他们可能会在类外部被调用，防止循环应用。\n\n## strong：\nstrong也是由ARC新引入的对象变量属性，在ARC下,用strong代替了retain，叫`强引用`，会增加引用计数。，所有的局部变量代码中我们声明的变量默认都是强引用，不需要再额外使用`__strong`来修饰。\n\n## 什么时候用`stong`/`weak`\n- 根视图和父视图需要使用`strong`; 子视图使用`weak`\n- 没有强指针指向的对象使用`strong`; 有强指针指向的可以可以`weak`\n\n## `__strong,__weak,__unsafe_unretained,__autoreleasing` 的含义\n在ARC情况下，对象类型的变量将有所有权修饰符\n`__strong`: 是缺省的关键词。\n`__weak`: 声明了一个可以自动nil化的引用。\n`__unsafe_unretained`: 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。\n`__autoreleasing`: 用来修饰一个函数的参数，这个参数在函数返回的时候会被自动释放。\n\n`ARC`声明属性时，对于`基本数据类型`默认关键字是 （atomic,readwrite,assign）\n`ARC`声明属性时，对于普通的`OC对象`默认关键字是 （atomic,readwrite,strong）\n- 示例\n``` Objc\n@property (nonatomic) int supportOrientation;           默认是assign，因为是基础数据类型，必须是assign\n@property (readonly) UIImage* rightImage;                                     默认是atomic\n@property (nonatomic) bolo_BasePlayerControlView* ctrlView;            默认是strong\n@property (nonatomic, weak) id<WatchVideoDetailDelegate> delegate;         代理使用weak\n```\n\n## 扩展：\nLLVM官网给出的一些示意，ARC里也可以使用retain等关键字\n```\nassign implies __unsafe_unretained ownership.\ncopy implies __strong ownership, as well as the usual behavior of copy semantics on the setter.\nretain implies __strong ownership.\nstrong implies __strong ownership.\nunsafe_unretained implies __unsafe_unretained ownership.\nweak implies __weak ownership.\n```\nassign 等同于unsafe_retained\ncopy的作用和MRC一样，同时又有strong的效果\nretain等同于strong\nweak和unsafe_unretained的区别在于：weak降被释放指针赋值为nil，而unsafe_unretained则会成为野指针\n","source":"_posts/ios-keywors-of-strong-weak-copy-retain-assign.md","raw":"---\ntitle: strong、weak、copy、retain和assign的区别\ndate: 2018-05-18 14:12:00\ntags: [iOS,keywords]\ncategories: [iOS,Objc]\n---\n\n## assign：\n`assign`一般用来修饰基本的数据类型，包括基础数据类型（NSInteger,CGFloat）和C语言数据类型（int,float,double,char）等等。因为assign声明的属性，是不会增加引用计数的，也就是说声明的属性释放后也就没有了，及时其他对象引用了它也不会保留，只会造成crash。但是及时被释放，指针却还在，成为了`野指针`，如果新的对象被分配到了这个内存地址上，又会造成crash。所以一般只用来声明基本的数据类型，因为它们会被分配到`栈区`上，而栈取由系统`自动管理`，不会造成野指针。\n\n## retain：\n与assign相对，我们要解决`对象`被其他对象引用后释放造成的问题，就需要用`retain`来声明。使用retain声明的对象会`更改引用计数`，每次被引用，引用计数都会`+1`，释放后就会`-1`。即使这个对象本身被释放了，只要还有对象在引用它，该对象就会`仍然持有`，不会出现任何问题。并且只有当引用`计数为0时`，就会被`dealloc`析构函数回收进内存。\n\n## copy：\n最常见到的copy的声明使用是 NSString 等。copy与retain的`区别`在于：retain是拷贝内存指针地址，而copy是拷贝对象本身；也就是说retain是`浅复制`，copy是`深复制`；如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在`NSString`这一类有`可变类型对象`的身上使用`copy`关键字，是因为他们有可能和对应的可变类型如 `NSMutableString` 之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了 `NSCopying` 协议的`对象类型`有效。\n\n## weak：\nweak是由ARC新引入的对象变量属性，weak类似于assign，叫`弱引用`，也是不增加引用计数，不同在于week指向对象类型时，当对象被释放会指向nil，而assign则会造成野指针。一般只有在防止循环引用时候使用；比如父类引用了子类，子类又引用父类；IBOutlet、Delegate等一般就是使用week，这是因为他们可能会在类外部被调用，防止循环应用。\n\n## strong：\nstrong也是由ARC新引入的对象变量属性，在ARC下,用strong代替了retain，叫`强引用`，会增加引用计数。，所有的局部变量代码中我们声明的变量默认都是强引用，不需要再额外使用`__strong`来修饰。\n\n## 什么时候用`stong`/`weak`\n- 根视图和父视图需要使用`strong`; 子视图使用`weak`\n- 没有强指针指向的对象使用`strong`; 有强指针指向的可以可以`weak`\n\n## `__strong,__weak,__unsafe_unretained,__autoreleasing` 的含义\n在ARC情况下，对象类型的变量将有所有权修饰符\n`__strong`: 是缺省的关键词。\n`__weak`: 声明了一个可以自动nil化的引用。\n`__unsafe_unretained`: 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。\n`__autoreleasing`: 用来修饰一个函数的参数，这个参数在函数返回的时候会被自动释放。\n\n`ARC`声明属性时，对于`基本数据类型`默认关键字是 （atomic,readwrite,assign）\n`ARC`声明属性时，对于普通的`OC对象`默认关键字是 （atomic,readwrite,strong）\n- 示例\n``` Objc\n@property (nonatomic) int supportOrientation;           默认是assign，因为是基础数据类型，必须是assign\n@property (readonly) UIImage* rightImage;                                     默认是atomic\n@property (nonatomic) bolo_BasePlayerControlView* ctrlView;            默认是strong\n@property (nonatomic, weak) id<WatchVideoDetailDelegate> delegate;         代理使用weak\n```\n\n## 扩展：\nLLVM官网给出的一些示意，ARC里也可以使用retain等关键字\n```\nassign implies __unsafe_unretained ownership.\ncopy implies __strong ownership, as well as the usual behavior of copy semantics on the setter.\nretain implies __strong ownership.\nstrong implies __strong ownership.\nunsafe_unretained implies __unsafe_unretained ownership.\nweak implies __weak ownership.\n```\nassign 等同于unsafe_retained\ncopy的作用和MRC一样，同时又有strong的效果\nretain等同于strong\nweak和unsafe_unretained的区别在于：weak降被释放指针赋值为nil，而unsafe_unretained则会成为野指针\n","slug":"ios-keywors-of-strong-weak-copy-retain-assign","published":1,"updated":"2019-01-13T04:36:40.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2g000xl1fq42k8a86j","content":"<h2 id=\"assign：\"><a href=\"#assign：\" class=\"headerlink\" title=\"assign：\"></a>assign：</h2><p><code>assign</code>一般用来修饰基本的数据类型，包括基础数据类型（NSInteger,CGFloat）和C语言数据类型（int,float,double,char）等等。因为assign声明的属性，是不会增加引用计数的，也就是说声明的属性释放后也就没有了，及时其他对象引用了它也不会保留，只会造成crash。但是及时被释放，指针却还在，成为了<code>野指针</code>，如果新的对象被分配到了这个内存地址上，又会造成crash。所以一般只用来声明基本的数据类型，因为它们会被分配到<code>栈区</code>上，而栈取由系统<code>自动管理</code>，不会造成野指针。</p>\n<h2 id=\"retain：\"><a href=\"#retain：\" class=\"headerlink\" title=\"retain：\"></a>retain：</h2><p>与assign相对，我们要解决<code>对象</code>被其他对象引用后释放造成的问题，就需要用<code>retain</code>来声明。使用retain声明的对象会<code>更改引用计数</code>，每次被引用，引用计数都会<code>+1</code>，释放后就会<code>-1</code>。即使这个对象本身被释放了，只要还有对象在引用它，该对象就会<code>仍然持有</code>，不会出现任何问题。并且只有当引用<code>计数为0时</code>，就会被<code>dealloc</code>析构函数回收进内存。</p>\n<h2 id=\"copy：\"><a href=\"#copy：\" class=\"headerlink\" title=\"copy：\"></a>copy：</h2><p>最常见到的copy的声明使用是 NSString 等。copy与retain的<code>区别</code>在于：retain是拷贝内存指针地址，而copy是拷贝对象本身；也就是说retain是<code>浅复制</code>，copy是<code>深复制</code>；如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在<code>NSString</code>这一类有<code>可变类型对象</code>的身上使用<code>copy</code>关键字，是因为他们有可能和对应的可变类型如 <code>NSMutableString</code> 之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了 <code>NSCopying</code> 协议的<code>对象类型</code>有效。</p>\n<h2 id=\"weak：\"><a href=\"#weak：\" class=\"headerlink\" title=\"weak：\"></a>weak：</h2><p>weak是由ARC新引入的对象变量属性，weak类似于assign，叫<code>弱引用</code>，也是不增加引用计数，不同在于week指向对象类型时，当对象被释放会指向nil，而assign则会造成野指针。一般只有在防止循环引用时候使用；比如父类引用了子类，子类又引用父类；IBOutlet、Delegate等一般就是使用week，这是因为他们可能会在类外部被调用，防止循环应用。</p>\n<h2 id=\"strong：\"><a href=\"#strong：\" class=\"headerlink\" title=\"strong：\"></a>strong：</h2><p>strong也是由ARC新引入的对象变量属性，在ARC下,用strong代替了retain，叫<code>强引用</code>，会增加引用计数。，所有的局部变量代码中我们声明的变量默认都是强引用，不需要再额外使用<code>__strong</code>来修饰。</p>\n<h2 id=\"什么时候用stong-weak\"><a href=\"#什么时候用stong-weak\" class=\"headerlink\" title=\"什么时候用stong/weak\"></a>什么时候用<code>stong</code>/<code>weak</code></h2><ul>\n<li>根视图和父视图需要使用<code>strong</code>; 子视图使用<code>weak</code></li>\n<li>没有强指针指向的对象使用<code>strong</code>; 有强指针指向的可以可以<code>weak</code></li>\n</ul>\n<h2 id=\"strong-weak-unsafe-unretained-autoreleasing-的含义\"><a href=\"#strong-weak-unsafe-unretained-autoreleasing-的含义\" class=\"headerlink\" title=\"__strong,__weak,__unsafe_unretained,__autoreleasing 的含义\"></a><code>__strong,__weak,__unsafe_unretained,__autoreleasing</code> 的含义</h2><p>在ARC情况下，对象类型的变量将有所有权修饰符<br><code>__strong</code>: 是缺省的关键词。<br><code>__weak</code>: 声明了一个可以自动nil化的引用。<br><code>__unsafe_unretained</code>: 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。<br><code>__autoreleasing</code>: 用来修饰一个函数的参数，这个参数在函数返回的时候会被自动释放。</p>\n<p><code>ARC</code>声明属性时，对于<code>基本数据类型</code>默认关键字是 （atomic,readwrite,assign）<br><code>ARC</code>声明属性时，对于普通的<code>OC对象</code>默认关键字是 （atomic,readwrite,strong）</p>\n<ul>\n<li>示例<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> supportOrientation;           默认是<span class=\"keyword\">assign</span>，因为是基础数据类型，必须是<span class=\"keyword\">assign</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIImage</span>* rightImage;                                     默认是atomic</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) bolo_BasePlayerControlView* ctrlView;            默认是<span class=\"keyword\">strong</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span>&lt;WatchVideoDetailDelegate&gt; delegate;         代理使用<span class=\"keyword\">weak</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h2><p>LLVM官网给出的一些示意，ARC里也可以使用retain等关键字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assign implies __unsafe_unretained ownership.</span><br><span class=\"line\">copy implies __strong ownership, as well as the usual behavior of copy semantics on the setter.</span><br><span class=\"line\">retain implies __strong ownership.</span><br><span class=\"line\">strong implies __strong ownership.</span><br><span class=\"line\">unsafe_unretained implies __unsafe_unretained ownership.</span><br><span class=\"line\">weak implies __weak ownership.</span><br></pre></td></tr></table></figure></p>\n<p>assign 等同于unsafe_retained<br>copy的作用和MRC一样，同时又有strong的效果<br>retain等同于strong<br>weak和unsafe_unretained的区别在于：weak降被释放指针赋值为nil，而unsafe_unretained则会成为野指针</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"assign：\"><a href=\"#assign：\" class=\"headerlink\" title=\"assign：\"></a>assign：</h2><p><code>assign</code>一般用来修饰基本的数据类型，包括基础数据类型（NSInteger,CGFloat）和C语言数据类型（int,float,double,char）等等。因为assign声明的属性，是不会增加引用计数的，也就是说声明的属性释放后也就没有了，及时其他对象引用了它也不会保留，只会造成crash。但是及时被释放，指针却还在，成为了<code>野指针</code>，如果新的对象被分配到了这个内存地址上，又会造成crash。所以一般只用来声明基本的数据类型，因为它们会被分配到<code>栈区</code>上，而栈取由系统<code>自动管理</code>，不会造成野指针。</p>\n<h2 id=\"retain：\"><a href=\"#retain：\" class=\"headerlink\" title=\"retain：\"></a>retain：</h2><p>与assign相对，我们要解决<code>对象</code>被其他对象引用后释放造成的问题，就需要用<code>retain</code>来声明。使用retain声明的对象会<code>更改引用计数</code>，每次被引用，引用计数都会<code>+1</code>，释放后就会<code>-1</code>。即使这个对象本身被释放了，只要还有对象在引用它，该对象就会<code>仍然持有</code>，不会出现任何问题。并且只有当引用<code>计数为0时</code>，就会被<code>dealloc</code>析构函数回收进内存。</p>\n<h2 id=\"copy：\"><a href=\"#copy：\" class=\"headerlink\" title=\"copy：\"></a>copy：</h2><p>最常见到的copy的声明使用是 NSString 等。copy与retain的<code>区别</code>在于：retain是拷贝内存指针地址，而copy是拷贝对象本身；也就是说retain是<code>浅复制</code>，copy是<code>深复制</code>；如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在<code>NSString</code>这一类有<code>可变类型对象</code>的身上使用<code>copy</code>关键字，是因为他们有可能和对应的可变类型如 <code>NSMutableString</code> 之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了 <code>NSCopying</code> 协议的<code>对象类型</code>有效。</p>\n<h2 id=\"weak：\"><a href=\"#weak：\" class=\"headerlink\" title=\"weak：\"></a>weak：</h2><p>weak是由ARC新引入的对象变量属性，weak类似于assign，叫<code>弱引用</code>，也是不增加引用计数，不同在于week指向对象类型时，当对象被释放会指向nil，而assign则会造成野指针。一般只有在防止循环引用时候使用；比如父类引用了子类，子类又引用父类；IBOutlet、Delegate等一般就是使用week，这是因为他们可能会在类外部被调用，防止循环应用。</p>\n<h2 id=\"strong：\"><a href=\"#strong：\" class=\"headerlink\" title=\"strong：\"></a>strong：</h2><p>strong也是由ARC新引入的对象变量属性，在ARC下,用strong代替了retain，叫<code>强引用</code>，会增加引用计数。，所有的局部变量代码中我们声明的变量默认都是强引用，不需要再额外使用<code>__strong</code>来修饰。</p>\n<h2 id=\"什么时候用stong-weak\"><a href=\"#什么时候用stong-weak\" class=\"headerlink\" title=\"什么时候用stong/weak\"></a>什么时候用<code>stong</code>/<code>weak</code></h2><ul>\n<li>根视图和父视图需要使用<code>strong</code>; 子视图使用<code>weak</code></li>\n<li>没有强指针指向的对象使用<code>strong</code>; 有强指针指向的可以可以<code>weak</code></li>\n</ul>\n<h2 id=\"strong-weak-unsafe-unretained-autoreleasing-的含义\"><a href=\"#strong-weak-unsafe-unretained-autoreleasing-的含义\" class=\"headerlink\" title=\"__strong,__weak,__unsafe_unretained,__autoreleasing 的含义\"></a><code>__strong,__weak,__unsafe_unretained,__autoreleasing</code> 的含义</h2><p>在ARC情况下，对象类型的变量将有所有权修饰符<br><code>__strong</code>: 是缺省的关键词。<br><code>__weak</code>: 声明了一个可以自动nil化的引用。<br><code>__unsafe_unretained</code>: 声明一个弱引用，但是不会自动nil化，也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针了。<br><code>__autoreleasing</code>: 用来修饰一个函数的参数，这个参数在函数返回的时候会被自动释放。</p>\n<p><code>ARC</code>声明属性时，对于<code>基本数据类型</code>默认关键字是 （atomic,readwrite,assign）<br><code>ARC</code>声明属性时，对于普通的<code>OC对象</code>默认关键字是 （atomic,readwrite,strong）</p>\n<ul>\n<li>示例<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">int</span> supportOrientation;           默认是<span class=\"keyword\">assign</span>，因为是基础数据类型，必须是<span class=\"keyword\">assign</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">readonly</span>) <span class=\"built_in\">UIImage</span>* rightImage;                                     默认是atomic</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>) bolo_BasePlayerControlView* ctrlView;            默认是<span class=\"keyword\">strong</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span>&lt;WatchVideoDetailDelegate&gt; delegate;         代理使用<span class=\"keyword\">weak</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h2><p>LLVM官网给出的一些示意，ARC里也可以使用retain等关键字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assign implies __unsafe_unretained ownership.</span><br><span class=\"line\">copy implies __strong ownership, as well as the usual behavior of copy semantics on the setter.</span><br><span class=\"line\">retain implies __strong ownership.</span><br><span class=\"line\">strong implies __strong ownership.</span><br><span class=\"line\">unsafe_unretained implies __unsafe_unretained ownership.</span><br><span class=\"line\">weak implies __weak ownership.</span><br></pre></td></tr></table></figure></p>\n<p>assign 等同于unsafe_retained<br>copy的作用和MRC一样，同时又有strong的效果<br>retain等同于strong<br>weak和unsafe_unretained的区别在于：weak降被释放指针赋值为nil，而unsafe_unretained则会成为野指针</p>\n"},{"title":"iOS - KVC 和 KVO 的使用和原理","date":"2018-05-23T04:55:57.000Z","_content":"# KVC\nKVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。\n## 简介\nKVC（Key-value coding），键值编码；是指在iOS开发中，可以允许开发者通过属性名`Key`直接访问对象的属性并给属性`编码`（赋值value），而不是调用对应的getter/setter方法。很多高级的iOS开发技巧都是基于KVC实现，例如修改系统控件内部属性；json->model的映射框架等。\n## KVC最重要的四个方法\n```Objc\n- (nullable id)valueForKey:(NSString * )key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString * )key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString * )keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString * )keyPath;  //通过KeyPath来设值\n```\n## valueForKey 和 valueForKeyPath区别\n### 先来看一段代码\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSDictionary * dict = @{@\"key1\":@\"value1\",\n                           @\"second\":@{\n                                   @\"k1\":@\"v1\",\n                                   @\"k2\":@\"v2\",\n                                   @\"third\":@{\n                                           @\"t1\":@\"h1\",\n                                           @\"t2\":@\"h2\"\n                                           }\n                                   }\n                           };\n\n    NSDictionary * second = [dict valueForKey:@\"second\"];\n    NSDictionary * third1 = [second valueForKey:@\"third\"];\n    NSLog(@\"%@\",third1);\n    NSDictionary * third2 = [dict valueForKeyPath:@\"second.third\"];\n    NSLog(@\"%@\",third2);\n}\n```\n### 输出结果：\n```console\n2018-05-23 13:52:33.430617+0800 KVC-Demo[1584:403407] {\n    t1 = h1;\n    t2 = h2;\n}\n2018-05-23 13:52:33.430800+0800 KVC-Demo[1584:403407] {\n    t1 = h1;\n    t2 = h2;\n}\n```\n### 小结\n通过代码我们可以看出，我们想要从dict这个字典中获取到`third`这个key所对应的值得话,使用`valueForKey`需要通过一层一层的对象才能取到想要的字典，而使用valueForKeyPath则只需要输入third在字典中的`路径（path）`一次就可以取到third字典。\n### 参考博客\nhttps://www.jianshu.com/p/c0e099f72a3b\nhttps://www.jianshu.com/p/a6a0abac1c4a\n\n## KVC的使用\n### 代替getter/setter\n```Objc\n@interface Model : NSObject\n@property (copy, nonatomic) NSString * text;\n@property (copy, nonatomic) SubModel * subModel;\n@end\n\n@interface SubModel : Model\n@property (copy, nonatomic) NSString * subText;\n@end\n```\n- 不使用kvc\n```Objc\n //赋值\n Model *model = [[Model alloc]init];\n model.text = @\"text\";\n SubModel *subModel = [[SubModel alloc]init];\n subModel.subText = @\"subText\";\n model.subModel = subModel;\n //取值\n NSString *text =  model.text;\n NSString *subText = model.subModel.subText;\n```\n- 使用kvc\n```Objc\n    //赋值\n    Model *model = [[Model alloc]init];\n    [model setValue:@\"text\" forKey:@\"text\"];\n    [model setValue:@\"subText\" forKeyPath:@\"subModel.subText\"];\n    //取值\n    NSString *text =  [model valueForKey:@\"text\"];\n    NSString *subText = [model valueForKeyPath:@\"subModel.subText\"];\n```\n### 字典转模型（仿YYModel）\n- 创建NSObject的扩展NSObject+Model\n```Objc\n@interface NSObject (Model)\n+ (instancetype) tb_modelWithDictionary:(NSDictionary * )dictionary;\n@end\n```\n- 实现SObject+Model\n利用Runtime取到对应类的属性列表，在使用kvc对所有属性进行赋值\n```Objc\n@implementation NSObject (Model)\n+ (NSArray * )getPropertyList:(Class)cls{\n    NSArray * array = objc_getAssociatedObject(self, `_cmd`);\n    if (array != nil){\n        return array;\n    }\n    NSMutableArray * arrM = [NSMutableArray array];\n    //输出个数\n    unsigned int outCount;\n    //获取属性列表（ objc_property_t * ）\n    objc_property_t * properties = class_copyPropertyList(cls, &outCount);\n    for (NSInteger i=0; i<outCount; ++i) {\n        objc_property_t property = properties[i];\n        //属性名字\n        NSString * name = [NSString stringWithUTF8String:property_getName(property)];\n        [arrM addObject:name];\n    }\n    objc_setAssociatedObject(self, @selector(getPropertyList:), [arrM copy], OBJC_ASSOCIATION_RETAIN);\n    free(properties);\n    return [arrM copy];\n}\n\n+ (instancetype)tb_modelWithDictionary:(NSDictionary * )dictionary{\n    NSObject * object = [[self alloc]init];\n\n    NSArray * array = [self getPropertyList:[self class]];\n    [dictionary enumerateKeysAndObjectsUsingBlock:^(NSString * key, id value, BOOL * stop) {\n        if ([array containsObject:key]){\n            [object setValue:value forKey:key];\n        }\n    }];\n\n    return  object;\n}\n@end\n```\n- 使用tb_modelWithDictionary模仿YYModel的字典转模型方式\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSDictionary * dict = @{\n                           @\"text\":@\"text\"\n                           };\n    Model * model = [Model tb_modelWithDictionary:dict];\n    NSLog(@\"%@\",model);\n}\n```\n\n### 修改系统控件内部属性（runtime+kvc）\n- 需求：修改UIPageControl小圆点的背景图片\n- 查看UIPageControl.h如下\n```Objc\nNS_CLASS_AVAILABLE_IOS(2_0) @interface UIPageControl : UIControl\n\n@property(nonatomic) NSInteger numberOfPages;          // default is 0\n@property(nonatomic) NSInteger currentPage;            // default is 0. value pinned to 0..numberOfPages-1\n\n@property(nonatomic) BOOL hidesForSinglePage;          // hide the the indicator if there is only one page. default is NO\n\n@property(nonatomic) BOOL defersCurrentPageDisplay;    // if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO\n- (void)updateCurrentPageDisplay;                      // update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately\n\n- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;   // returns minimum size required to display dots for given page count. can be used to size control if page count could change\n\n@property(nullable, nonatomic,strong) UIColor * pageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic,strong) UIColor * currentPageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@end\n```\n没有发现UIPageControl暴露的操作中有设置小圆点背景图片的方法和属性，那么就可以利用runtime遍历UIPageControl类的成员变量（`ivar`）和属性（`property`）\n\n- 利用runtime遍历UIPageControl成员变量\n\n导入头文件：\n```Objc\n#import <objc/runtime.h>\n```\n遍历成员变量：\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIPageControl * pc = [[UIPageControl alloc]init];\n    NSArray * array = [self getIvarList:[pc class]];\n    NSLog(@\"%@\",array);\n\n}\n- (NSArray * )getIvarList:(Class)cls{\n    NSMutableArray * arrM = [NSMutableArray array];\n    unsigned int outCount;\n    Ivar * ivars = class_copyIvarList(cls, &outCount);\n    for (NSInteger i=0; i<outCount; ++i) {\n        Ivar ivar = ivars[i];\n        NSString * name = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        NSString * type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSString * str = [name stringByAppendingFormat:@\" -- %@\",type];\n        [arrM addObject:str];\n    }\n    free(ivars);\n    return [arrM copy];\n}\n```\n输出结果：\n```console\n2018-05-23 16:45:18.380346+0800 KVC-Demo[4400:856521] (\n    \"_lastUserInterfaceIdiom -- q\",\n    \"_indicators -- @\\\"NSMutableArray\\\"\",\n    \"_currentPage -- q\",\n    \"_displayedPage -- q\",\n    \"_pageControlFlags -- {?=\\\"hideForSinglePage\\\"b1\\\"defersCurrentPageDisplay\\\"b1}\",\n    \"_currentPageImage -- @\\\"UIImage\\\"\",\n    \"_pageImage -- @\\\"UIImage\\\"\",\n    \"_currentPageImages -- @\\\"NSMutableArray\\\"\",\n    \"_pageImages -- @\\\"NSMutableArray\\\"\",\n    \"_backgroundVisualEffectView -- @\\\"UIVisualEffectView\\\"\",\n    \"_currentPageIndicatorTintColor -- @\\\"UIColor\\\"\",\n    \"_pageIndicatorTintColor -- @\\\"UIColor\\\"\",\n    \"_legibilitySettings -- @\\\"_UILegibilitySettings\\\"\",\n    \"_numberOfPages -- q\"\n)\n```\n- 利用kvc设置`_currentPageImage`和`_pageImage`\n\n```Objc\n    UIPageControl *pc = [[UIPageControl alloc]init];\n    [pc setValue:[UIImage imageNamed:@\"pageImage\"] forKeyPath:@\"_pageImage\"];\n    [pc setValue:[UIImage imageNamed:@\"currentPageImage\"] forKeyPath:@\"_currentPageImage\"];\n```\n\n### XIB/Storyboard\n在xib/Storyboard中，也可以使用KVC，例如下面是在xib中使用KVC把图片边框设置成圆角。\n![](/images/kvc_layer_cornerradius.png)\n\n# KVO\nKVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。\n## 简介\nKVO 是 Objective-C 对观察者设计模式的一种实现；[另外一种是：通知机制（notification）]。\n## 使用（Swift）\n需求：UIScrollView内包含一部分原生控件和UIWebView的组合;这种情况下UIWebView的高度无法得知，因为UIWebView写完中包含UIScrollerView，所以需要利用KVO技术监听UIWebView中UIScrollerView的contentSize的变化以达到需求的目的。\n\n### addOberver\n- 一般在viewDidLoad中添加监听\n```Swift\nif let scrollView = mWebView.subviews.first as? UIScrollView {\n            scrollView.alwaysBounceVertical = false\n            scrollView.alwaysBounceHorizontal = false\n            scrollView.bounces = false\n            scrollView.addObserver(self, forKeyPath: \"contentSize\", options: .new, context: nil)\n        }\n```\n\n### observerValueForkeyPath\n- 当contentSize发生变化时,会回调到`observerValueForkeyPath`这个方法\n```Swift\noverride func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {\n        if keyPath == \"contentSize\" && change != nil {\n            let value = (change![NSKeyValueChangeKey.newKey] as! NSValue).cgSizeValue.height\n            desViewHeightCons.constant = value\n        }\n    }\n```\n\n### removeObserver\n- 当界面销毁时，移除监听\n```Swift\ndeinit {\n        if let scrollView = mWebView?.subviews.first as? UIScrollView {\n            scrollView.removeObserver(self, forKeyPath: \"contentSize\")\n        }\n    }\n```\n\n## KVO的原理\n键值编码(KVC)和键值观察（KVO）是根据`isa-swizzling`技术来实现的，主要依据runtime的强大动态能力。\n当某个类第一次被观察时，系统会在运行时期动态的创建一个该类的派生类，在这个派生类中重写任何被观察属性的`setter`方法。派生类在被重写的setter方法实现真正的通知机制，这么设计是基于设置属性会调用setter方法，而通过重写就获得了KVO需要的通知机制，当然前提是要遵循KVO的属性设置方式来变更属性值，如果直接修改属性对应的成员变量是无法实现KVO的。\n同时派生类还重写了class方法`欺骗`外部调用者它就是起初的那个类，然后系统将`isa`指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因为在该对象上对setter的调用就会调用的重写的setter，从而激活键值通知机制。此外派生类还重写了`delloc`方法来释放资源。\n\n在Runtime篇章中介绍过，isa指针其实指向的是类的元类，如果添加监听之前的类名为`Person`,那么添加监听之后被runtime更改以后的类名会变成：`NSKVONotifying_Person`\n\n新的派生类`NSKVONotifying_Person`会重写以下方法：\n增加了监听的属性对应的`setter`,`class`,`delloc`,`_isKVOA`\n\n### class\n重写class方法是为了方便我们调用它的时候，返回跟重写继承类之前同样的内容。\n```Objc\nPerson *person = [[Person alloc]init];\nNSLog(@\"before isa:%@  class:%@\",object_getClass(person), [person class]);\n[person addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:nil];\nNSLog(@\"end isa:%@  class:%@\",object_getClass(person), [person class]);\n_person = person;\n```\n输出结果：\n```console\n2018-05-23 19:55:23.430908+0800 KVO-Demo[6395:1312349] before isa:Person  class:Person\n2018-05-23 19:55:23.431456+0800 KVO-Demo[6395:1312349] end isa:NSKVONotifying_Person  class:Person\n```\n这也是`isa`指针和`class`方法的一个区别，使用的时候要`特别注意`。\n\n### setter\n新的派生类会重写对应的setter方法，其实是为了在setter中增加另外两个方法的调用\n```Objc\n- (void)willChangeValueForKey:(NSString * )key  \n- (void)didChangeValueForKey:(NSString * )key  \n```\n其中 `didChangeValueForKey`负责触发：`observeValueForKeyPath:keyPath :object :change :context`方法，这就是`kvo`的原理。\n如果没有执行`setter`之类的调用，那么使用`setValue:forKey`方法也会直接调用`observeValueForKeyPath:keyPath :object :change :context`方法\n再如果既没有调用`setter`也没有调用`setValue:forKey`，那么\n```Objc\n- (void)willChangeValueForKey:(NSString * )key  \n- (void)didChangeValueForKey:(NSString * )key  \n```\n我们只需要显示调用上述两个方法，就会触发`observeValueForKeyPath:keyPath :object :change :context`方法，同样可以使用KVO。\n\n### `_isKVOA`\n这个私有方法是用来表示该类是一个KVO机制声明的类\n\n### 小结（触发KVO的三种方法）\n1. 使用KVC （运行时会在`setValue:forKey`中来调用`will/didChangeValueForKey:`）\n2. 使用setter方法（运行时会在setter方法中调用`will/didChangeValueForKey:`）\n3. 显示调用`will/didChangeValueForKey:`方法\n\n## 如何更优雅的使用KVO\n只需要使用 Facebook 开源的 [KVOController](https://github.com/facebook/KVOController) 框架就可以优雅地解决这些问题了。\n```Objc\n[self.KVOController observe:person\n                    keyPath:@\"age\"\n                    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                      block:^(id  observer, id  object, NSDictionary<NSString  * , id> *  change) {\n                          NSLog(@\"%@\", change);\n                      }];\n```\n我们可以在任意对象上获得 `KVOController` 对象，然后调用它的实例方法 `-observer:keyPath:options:block:` 就可以检测某个对象对应的属性了，该方法传入的参数非常容易理解，在 block 中也可以获得所有与 KVO 有关的参数。\n\n使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题:\n\n不需要手动移除观察者；\n实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；\n使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；\n每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；\n\n# 参考文档和博客\nhttp://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1\nhttps://blog.csdn.net/wzzvictory/article/details/9674431\nhttps://blog.csdn.net/kesalin/article/details/8194240\nhttps://draveness.me/kvocontroller\n","source":"_posts/ios-kvc-and-kvo.md","raw":"---\ntitle: iOS - KVC 和 KVO 的使用和原理\ndate: 2018-05-23 12:55:57\ntags: [iOS,Objc,KVC,KVO]\ncategories: [iOS,Objc]\n---\n# KVC\nKVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。\n## 简介\nKVC（Key-value coding），键值编码；是指在iOS开发中，可以允许开发者通过属性名`Key`直接访问对象的属性并给属性`编码`（赋值value），而不是调用对应的getter/setter方法。很多高级的iOS开发技巧都是基于KVC实现，例如修改系统控件内部属性；json->model的映射框架等。\n## KVC最重要的四个方法\n```Objc\n- (nullable id)valueForKey:(NSString * )key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString * )key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString * )keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString * )keyPath;  //通过KeyPath来设值\n```\n## valueForKey 和 valueForKeyPath区别\n### 先来看一段代码\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSDictionary * dict = @{@\"key1\":@\"value1\",\n                           @\"second\":@{\n                                   @\"k1\":@\"v1\",\n                                   @\"k2\":@\"v2\",\n                                   @\"third\":@{\n                                           @\"t1\":@\"h1\",\n                                           @\"t2\":@\"h2\"\n                                           }\n                                   }\n                           };\n\n    NSDictionary * second = [dict valueForKey:@\"second\"];\n    NSDictionary * third1 = [second valueForKey:@\"third\"];\n    NSLog(@\"%@\",third1);\n    NSDictionary * third2 = [dict valueForKeyPath:@\"second.third\"];\n    NSLog(@\"%@\",third2);\n}\n```\n### 输出结果：\n```console\n2018-05-23 13:52:33.430617+0800 KVC-Demo[1584:403407] {\n    t1 = h1;\n    t2 = h2;\n}\n2018-05-23 13:52:33.430800+0800 KVC-Demo[1584:403407] {\n    t1 = h1;\n    t2 = h2;\n}\n```\n### 小结\n通过代码我们可以看出，我们想要从dict这个字典中获取到`third`这个key所对应的值得话,使用`valueForKey`需要通过一层一层的对象才能取到想要的字典，而使用valueForKeyPath则只需要输入third在字典中的`路径（path）`一次就可以取到third字典。\n### 参考博客\nhttps://www.jianshu.com/p/c0e099f72a3b\nhttps://www.jianshu.com/p/a6a0abac1c4a\n\n## KVC的使用\n### 代替getter/setter\n```Objc\n@interface Model : NSObject\n@property (copy, nonatomic) NSString * text;\n@property (copy, nonatomic) SubModel * subModel;\n@end\n\n@interface SubModel : Model\n@property (copy, nonatomic) NSString * subText;\n@end\n```\n- 不使用kvc\n```Objc\n //赋值\n Model *model = [[Model alloc]init];\n model.text = @\"text\";\n SubModel *subModel = [[SubModel alloc]init];\n subModel.subText = @\"subText\";\n model.subModel = subModel;\n //取值\n NSString *text =  model.text;\n NSString *subText = model.subModel.subText;\n```\n- 使用kvc\n```Objc\n    //赋值\n    Model *model = [[Model alloc]init];\n    [model setValue:@\"text\" forKey:@\"text\"];\n    [model setValue:@\"subText\" forKeyPath:@\"subModel.subText\"];\n    //取值\n    NSString *text =  [model valueForKey:@\"text\"];\n    NSString *subText = [model valueForKeyPath:@\"subModel.subText\"];\n```\n### 字典转模型（仿YYModel）\n- 创建NSObject的扩展NSObject+Model\n```Objc\n@interface NSObject (Model)\n+ (instancetype) tb_modelWithDictionary:(NSDictionary * )dictionary;\n@end\n```\n- 实现SObject+Model\n利用Runtime取到对应类的属性列表，在使用kvc对所有属性进行赋值\n```Objc\n@implementation NSObject (Model)\n+ (NSArray * )getPropertyList:(Class)cls{\n    NSArray * array = objc_getAssociatedObject(self, `_cmd`);\n    if (array != nil){\n        return array;\n    }\n    NSMutableArray * arrM = [NSMutableArray array];\n    //输出个数\n    unsigned int outCount;\n    //获取属性列表（ objc_property_t * ）\n    objc_property_t * properties = class_copyPropertyList(cls, &outCount);\n    for (NSInteger i=0; i<outCount; ++i) {\n        objc_property_t property = properties[i];\n        //属性名字\n        NSString * name = [NSString stringWithUTF8String:property_getName(property)];\n        [arrM addObject:name];\n    }\n    objc_setAssociatedObject(self, @selector(getPropertyList:), [arrM copy], OBJC_ASSOCIATION_RETAIN);\n    free(properties);\n    return [arrM copy];\n}\n\n+ (instancetype)tb_modelWithDictionary:(NSDictionary * )dictionary{\n    NSObject * object = [[self alloc]init];\n\n    NSArray * array = [self getPropertyList:[self class]];\n    [dictionary enumerateKeysAndObjectsUsingBlock:^(NSString * key, id value, BOOL * stop) {\n        if ([array containsObject:key]){\n            [object setValue:value forKey:key];\n        }\n    }];\n\n    return  object;\n}\n@end\n```\n- 使用tb_modelWithDictionary模仿YYModel的字典转模型方式\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSDictionary * dict = @{\n                           @\"text\":@\"text\"\n                           };\n    Model * model = [Model tb_modelWithDictionary:dict];\n    NSLog(@\"%@\",model);\n}\n```\n\n### 修改系统控件内部属性（runtime+kvc）\n- 需求：修改UIPageControl小圆点的背景图片\n- 查看UIPageControl.h如下\n```Objc\nNS_CLASS_AVAILABLE_IOS(2_0) @interface UIPageControl : UIControl\n\n@property(nonatomic) NSInteger numberOfPages;          // default is 0\n@property(nonatomic) NSInteger currentPage;            // default is 0. value pinned to 0..numberOfPages-1\n\n@property(nonatomic) BOOL hidesForSinglePage;          // hide the the indicator if there is only one page. default is NO\n\n@property(nonatomic) BOOL defersCurrentPageDisplay;    // if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO\n- (void)updateCurrentPageDisplay;                      // update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately\n\n- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;   // returns minimum size required to display dots for given page count. can be used to size control if page count could change\n\n@property(nullable, nonatomic,strong) UIColor * pageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic,strong) UIColor * currentPageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@end\n```\n没有发现UIPageControl暴露的操作中有设置小圆点背景图片的方法和属性，那么就可以利用runtime遍历UIPageControl类的成员变量（`ivar`）和属性（`property`）\n\n- 利用runtime遍历UIPageControl成员变量\n\n导入头文件：\n```Objc\n#import <objc/runtime.h>\n```\n遍历成员变量：\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    UIPageControl * pc = [[UIPageControl alloc]init];\n    NSArray * array = [self getIvarList:[pc class]];\n    NSLog(@\"%@\",array);\n\n}\n- (NSArray * )getIvarList:(Class)cls{\n    NSMutableArray * arrM = [NSMutableArray array];\n    unsigned int outCount;\n    Ivar * ivars = class_copyIvarList(cls, &outCount);\n    for (NSInteger i=0; i<outCount; ++i) {\n        Ivar ivar = ivars[i];\n        NSString * name = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        NSString * type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        NSString * str = [name stringByAppendingFormat:@\" -- %@\",type];\n        [arrM addObject:str];\n    }\n    free(ivars);\n    return [arrM copy];\n}\n```\n输出结果：\n```console\n2018-05-23 16:45:18.380346+0800 KVC-Demo[4400:856521] (\n    \"_lastUserInterfaceIdiom -- q\",\n    \"_indicators -- @\\\"NSMutableArray\\\"\",\n    \"_currentPage -- q\",\n    \"_displayedPage -- q\",\n    \"_pageControlFlags -- {?=\\\"hideForSinglePage\\\"b1\\\"defersCurrentPageDisplay\\\"b1}\",\n    \"_currentPageImage -- @\\\"UIImage\\\"\",\n    \"_pageImage -- @\\\"UIImage\\\"\",\n    \"_currentPageImages -- @\\\"NSMutableArray\\\"\",\n    \"_pageImages -- @\\\"NSMutableArray\\\"\",\n    \"_backgroundVisualEffectView -- @\\\"UIVisualEffectView\\\"\",\n    \"_currentPageIndicatorTintColor -- @\\\"UIColor\\\"\",\n    \"_pageIndicatorTintColor -- @\\\"UIColor\\\"\",\n    \"_legibilitySettings -- @\\\"_UILegibilitySettings\\\"\",\n    \"_numberOfPages -- q\"\n)\n```\n- 利用kvc设置`_currentPageImage`和`_pageImage`\n\n```Objc\n    UIPageControl *pc = [[UIPageControl alloc]init];\n    [pc setValue:[UIImage imageNamed:@\"pageImage\"] forKeyPath:@\"_pageImage\"];\n    [pc setValue:[UIImage imageNamed:@\"currentPageImage\"] forKeyPath:@\"_currentPageImage\"];\n```\n\n### XIB/Storyboard\n在xib/Storyboard中，也可以使用KVC，例如下面是在xib中使用KVC把图片边框设置成圆角。\n![](/images/kvc_layer_cornerradius.png)\n\n# KVO\nKVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。\n## 简介\nKVO 是 Objective-C 对观察者设计模式的一种实现；[另外一种是：通知机制（notification）]。\n## 使用（Swift）\n需求：UIScrollView内包含一部分原生控件和UIWebView的组合;这种情况下UIWebView的高度无法得知，因为UIWebView写完中包含UIScrollerView，所以需要利用KVO技术监听UIWebView中UIScrollerView的contentSize的变化以达到需求的目的。\n\n### addOberver\n- 一般在viewDidLoad中添加监听\n```Swift\nif let scrollView = mWebView.subviews.first as? UIScrollView {\n            scrollView.alwaysBounceVertical = false\n            scrollView.alwaysBounceHorizontal = false\n            scrollView.bounces = false\n            scrollView.addObserver(self, forKeyPath: \"contentSize\", options: .new, context: nil)\n        }\n```\n\n### observerValueForkeyPath\n- 当contentSize发生变化时,会回调到`observerValueForkeyPath`这个方法\n```Swift\noverride func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {\n        if keyPath == \"contentSize\" && change != nil {\n            let value = (change![NSKeyValueChangeKey.newKey] as! NSValue).cgSizeValue.height\n            desViewHeightCons.constant = value\n        }\n    }\n```\n\n### removeObserver\n- 当界面销毁时，移除监听\n```Swift\ndeinit {\n        if let scrollView = mWebView?.subviews.first as? UIScrollView {\n            scrollView.removeObserver(self, forKeyPath: \"contentSize\")\n        }\n    }\n```\n\n## KVO的原理\n键值编码(KVC)和键值观察（KVO）是根据`isa-swizzling`技术来实现的，主要依据runtime的强大动态能力。\n当某个类第一次被观察时，系统会在运行时期动态的创建一个该类的派生类，在这个派生类中重写任何被观察属性的`setter`方法。派生类在被重写的setter方法实现真正的通知机制，这么设计是基于设置属性会调用setter方法，而通过重写就获得了KVO需要的通知机制，当然前提是要遵循KVO的属性设置方式来变更属性值，如果直接修改属性对应的成员变量是无法实现KVO的。\n同时派生类还重写了class方法`欺骗`外部调用者它就是起初的那个类，然后系统将`isa`指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因为在该对象上对setter的调用就会调用的重写的setter，从而激活键值通知机制。此外派生类还重写了`delloc`方法来释放资源。\n\n在Runtime篇章中介绍过，isa指针其实指向的是类的元类，如果添加监听之前的类名为`Person`,那么添加监听之后被runtime更改以后的类名会变成：`NSKVONotifying_Person`\n\n新的派生类`NSKVONotifying_Person`会重写以下方法：\n增加了监听的属性对应的`setter`,`class`,`delloc`,`_isKVOA`\n\n### class\n重写class方法是为了方便我们调用它的时候，返回跟重写继承类之前同样的内容。\n```Objc\nPerson *person = [[Person alloc]init];\nNSLog(@\"before isa:%@  class:%@\",object_getClass(person), [person class]);\n[person addObserver:self forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:nil];\nNSLog(@\"end isa:%@  class:%@\",object_getClass(person), [person class]);\n_person = person;\n```\n输出结果：\n```console\n2018-05-23 19:55:23.430908+0800 KVO-Demo[6395:1312349] before isa:Person  class:Person\n2018-05-23 19:55:23.431456+0800 KVO-Demo[6395:1312349] end isa:NSKVONotifying_Person  class:Person\n```\n这也是`isa`指针和`class`方法的一个区别，使用的时候要`特别注意`。\n\n### setter\n新的派生类会重写对应的setter方法，其实是为了在setter中增加另外两个方法的调用\n```Objc\n- (void)willChangeValueForKey:(NSString * )key  \n- (void)didChangeValueForKey:(NSString * )key  \n```\n其中 `didChangeValueForKey`负责触发：`observeValueForKeyPath:keyPath :object :change :context`方法，这就是`kvo`的原理。\n如果没有执行`setter`之类的调用，那么使用`setValue:forKey`方法也会直接调用`observeValueForKeyPath:keyPath :object :change :context`方法\n再如果既没有调用`setter`也没有调用`setValue:forKey`，那么\n```Objc\n- (void)willChangeValueForKey:(NSString * )key  \n- (void)didChangeValueForKey:(NSString * )key  \n```\n我们只需要显示调用上述两个方法，就会触发`observeValueForKeyPath:keyPath :object :change :context`方法，同样可以使用KVO。\n\n### `_isKVOA`\n这个私有方法是用来表示该类是一个KVO机制声明的类\n\n### 小结（触发KVO的三种方法）\n1. 使用KVC （运行时会在`setValue:forKey`中来调用`will/didChangeValueForKey:`）\n2. 使用setter方法（运行时会在setter方法中调用`will/didChangeValueForKey:`）\n3. 显示调用`will/didChangeValueForKey:`方法\n\n## 如何更优雅的使用KVO\n只需要使用 Facebook 开源的 [KVOController](https://github.com/facebook/KVOController) 框架就可以优雅地解决这些问题了。\n```Objc\n[self.KVOController observe:person\n                    keyPath:@\"age\"\n                    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                      block:^(id  observer, id  object, NSDictionary<NSString  * , id> *  change) {\n                          NSLog(@\"%@\", change);\n                      }];\n```\n我们可以在任意对象上获得 `KVOController` 对象，然后调用它的实例方法 `-observer:keyPath:options:block:` 就可以检测某个对象对应的属性了，该方法传入的参数非常容易理解，在 block 中也可以获得所有与 KVO 有关的参数。\n\n使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题:\n\n不需要手动移除观察者；\n实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；\n使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；\n每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；\n\n# 参考文档和博客\nhttp://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1\nhttps://blog.csdn.net/wzzvictory/article/details/9674431\nhttps://blog.csdn.net/kesalin/article/details/8194240\nhttps://draveness.me/kvocontroller\n","slug":"ios-kvc-and-kvo","published":1,"updated":"2019-01-13T05:09:27.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2h0010l1fq4t1zezpl","content":"<h1 id=\"KVC\"><a href=\"#KVC\" class=\"headerlink\" title=\"KVC\"></a>KVC</h1><p>KVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>KVC（Key-value coding），键值编码；是指在iOS开发中，可以允许开发者通过属性名<code>Key</code>直接访问对象的属性并给属性<code>编码</code>（赋值value），而不是调用对应的getter/setter方法。很多高级的iOS开发技巧都是基于KVC实现，例如修改系统控件内部属性；json-&gt;model的映射框架等。</p>\n<h2 id=\"KVC最重要的四个方法\"><a href=\"#KVC最重要的四个方法\" class=\"headerlink\" title=\"KVC最重要的四个方法\"></a>KVC最重要的四个方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> * )key;                          <span class=\"comment\">//直接通过Key来取值</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> * )key;          <span class=\"comment\">//通过Key来设值</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath;                  <span class=\"comment\">//通过KeyPath来取值</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath;  <span class=\"comment\">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"valueForKey-和-valueForKeyPath区别\"><a href=\"#valueForKey-和-valueForKeyPath区别\" class=\"headerlink\" title=\"valueForKey 和 valueForKeyPath区别\"></a>valueForKey 和 valueForKeyPath区别</h2><h3 id=\"先来看一段代码\"><a href=\"#先来看一段代码\" class=\"headerlink\" title=\"先来看一段代码\"></a>先来看一段代码</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * dict = @&#123;<span class=\"string\">@\"key1\"</span>:<span class=\"string\">@\"value1\"</span>,</span><br><span class=\"line\">                           <span class=\"string\">@\"second\"</span>:@&#123;</span><br><span class=\"line\">                                   <span class=\"string\">@\"k1\"</span>:<span class=\"string\">@\"v1\"</span>,</span><br><span class=\"line\">                                   <span class=\"string\">@\"k2\"</span>:<span class=\"string\">@\"v2\"</span>,</span><br><span class=\"line\">                                   <span class=\"string\">@\"third\"</span>:@&#123;</span><br><span class=\"line\">                                           <span class=\"string\">@\"t1\"</span>:<span class=\"string\">@\"h1\"</span>,</span><br><span class=\"line\">                                           <span class=\"string\">@\"t2\"</span>:<span class=\"string\">@\"h2\"</span></span><br><span class=\"line\">                                           &#125;</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * second = [dict valueForKey:<span class=\"string\">@\"second\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * third1 = [second valueForKey:<span class=\"string\">@\"third\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,third1);</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * third2 = [dict valueForKeyPath:<span class=\"string\">@\"second.third\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,third2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h3><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 13:52:33.430617+0800 KVC-Demo[1584:403407] &#123;</span><br><span class=\"line\">    t1 = h1;</span><br><span class=\"line\">    t2 = h2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2018-05-23 13:52:33.430800+0800 KVC-Demo[1584:403407] &#123;</span><br><span class=\"line\">    t1 = h1;</span><br><span class=\"line\">    t2 = h2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>通过代码我们可以看出，我们想要从dict这个字典中获取到<code>third</code>这个key所对应的值得话,使用<code>valueForKey</code>需要通过一层一层的对象才能取到想要的字典，而使用valueForKeyPath则只需要输入third在字典中的<code>路径（path）</code>一次就可以取到third字典。</p>\n<h3 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h3><p><a href=\"https://www.jianshu.com/p/c0e099f72a3b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c0e099f72a3b</a><br><a href=\"https://www.jianshu.com/p/a6a0abac1c4a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a6a0abac1c4a</a></p>\n<h2 id=\"KVC的使用\"><a href=\"#KVC的使用\" class=\"headerlink\" title=\"KVC的使用\"></a>KVC的使用</h2><h3 id=\"代替getter-setter\"><a href=\"#代替getter-setter\" class=\"headerlink\" title=\"代替getter/setter\"></a>代替getter/setter</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Model</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> * text;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) SubModel * subModel;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SubModel</span> : <span class=\"title\">Model</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> * subText;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>不使用kvc</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">Model *model = [[Model alloc]init];</span><br><span class=\"line\">model.text = <span class=\"string\">@\"text\"</span>;</span><br><span class=\"line\">SubModel *subModel = [[SubModel alloc]init];</span><br><span class=\"line\">subModel.subText = <span class=\"string\">@\"subText\"</span>;</span><br><span class=\"line\">model.subModel = subModel;</span><br><span class=\"line\"><span class=\"comment\">//取值</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *text =  model.text;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *subText = model.subModel.subText;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用kvc</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">Model *model = [[Model alloc]init];</span><br><span class=\"line\">[model setValue:<span class=\"string\">@\"text\"</span> forKey:<span class=\"string\">@\"text\"</span>];</span><br><span class=\"line\">[model setValue:<span class=\"string\">@\"subText\"</span> forKeyPath:<span class=\"string\">@\"subModel.subText\"</span>];</span><br><span class=\"line\"><span class=\"comment\">//取值</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *text =  [model valueForKey:<span class=\"string\">@\"text\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *subText = [model valueForKeyPath:<span class=\"string\">@\"subModel.subText\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"字典转模型（仿YYModel）\"><a href=\"#字典转模型（仿YYModel）\" class=\"headerlink\" title=\"字典转模型（仿YYModel）\"></a>字典转模型（仿YYModel）</h3><ul>\n<li><p>创建NSObject的扩展NSObject+Model</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>) tb_modelWithDictionary:(<span class=\"built_in\">NSDictionary</span> * )dictionary;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现SObject+Model<br>利用Runtime取到对应类的属性列表，在使用kvc对所有属性进行赋值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> * )getPropertyList:(Class)cls&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = objc_getAssociatedObject(<span class=\"keyword\">self</span>, `_cmd`);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array != <span class=\"literal\">nil</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * arrM = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">//输出个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount;</span><br><span class=\"line\">    <span class=\"comment\">//获取属性列表（ objc_property_t * ）</span></span><br><span class=\"line\">    objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;outCount; ++i) &#123;</span><br><span class=\"line\">        objc_property_t property = properties[i];</span><br><span class=\"line\">        <span class=\"comment\">//属性名字</span></span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class=\"line\">        [arrM addObject:name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(getPropertyList:), [arrM <span class=\"keyword\">copy</span>], OBJC_ASSOCIATION_RETAIN);</span><br><span class=\"line\">    free(properties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [arrM <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)tb_modelWithDictionary:(<span class=\"built_in\">NSDictionary</span> * )dictionary&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> * object = [[<span class=\"keyword\">self</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = [<span class=\"keyword\">self</span> getPropertyList:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">    [dictionary enumerateKeysAndObjectsUsingBlock:^(<span class=\"built_in\">NSString</span> * key, <span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> * stop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([array containsObject:key])&#123;</span><br><span class=\"line\">            [object setValue:value forKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  object;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用tb_modelWithDictionary模仿YYModel的字典转模型方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * dict = @&#123;</span><br><span class=\"line\">                           <span class=\"string\">@\"text\"</span>:<span class=\"string\">@\"text\"</span></span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\">    Model * model = [Model tb_modelWithDictionary:dict];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,model);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改系统控件内部属性（runtime-kvc）\"><a href=\"#修改系统控件内部属性（runtime-kvc）\" class=\"headerlink\" title=\"修改系统控件内部属性（runtime+kvc）\"></a>修改系统控件内部属性（runtime+kvc）</h3><ul>\n<li>需求：修改UIPageControl小圆点的背景图片</li>\n<li>查看UIPageControl.h如下<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">2</span>_0) <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIPageControl</span> : <span class=\"title\">UIControl</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> numberOfPages;          <span class=\"comment\">// default is 0</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> currentPage;            <span class=\"comment\">// default is 0. value pinned to 0..numberOfPages-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> hidesForSinglePage;          <span class=\"comment\">// hide the the indicator if there is only one page. default is NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> defersCurrentPageDisplay;    <span class=\"comment\">// if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateCurrentPageDisplay;                      <span class=\"comment\">// update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeForNumberOfPages:(<span class=\"built_in\">NSInteger</span>)pageCount;   <span class=\"comment\">// returns minimum size required to display dots for given page count. can be used to size control if page count could change</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> * pageIndicatorTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> * currentPageIndicatorTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>没有发现UIPageControl暴露的操作中有设置小圆点背景图片的方法和属性，那么就可以利用runtime遍历UIPageControl类的成员变量（<code>ivar</code>）和属性（<code>property</code>）</p>\n<ul>\n<li>利用runtime遍历UIPageControl成员变量</li>\n</ul>\n<p>导入头文件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>遍历成员变量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">UIPageControl</span> * pc = [[<span class=\"built_in\">UIPageControl</span> alloc]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = [<span class=\"keyword\">self</span> getIvarList:[pc <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,array);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> * )getIvarList:(Class)cls&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * arrM = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount;</span><br><span class=\"line\">    Ivar * ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;outCount; ++i) &#123;</span><br><span class=\"line\">        Ivar ivar = ivars[i];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * type = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * str = [name stringByAppendingFormat:<span class=\"string\">@\" -- %@\"</span>,type];</span><br><span class=\"line\">        [arrM addObject:str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(ivars);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [arrM <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 16:45:18.380346+0800 KVC-Demo[4400:856521] (</span><br><span class=\"line\">    \"_lastUserInterfaceIdiom -- q\",</span><br><span class=\"line\">    \"_indicators -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_currentPage -- q\",</span><br><span class=\"line\">    \"_displayedPage -- q\",</span><br><span class=\"line\">    \"_pageControlFlags -- &#123;?=\\\"hideForSinglePage\\\"b1\\\"defersCurrentPageDisplay\\\"b1&#125;\",</span><br><span class=\"line\">    \"_currentPageImage -- @\\\"UIImage\\\"\",</span><br><span class=\"line\">    \"_pageImage -- @\\\"UIImage\\\"\",</span><br><span class=\"line\">    \"_currentPageImages -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_pageImages -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_backgroundVisualEffectView -- @\\\"UIVisualEffectView\\\"\",</span><br><span class=\"line\">    \"_currentPageIndicatorTintColor -- @\\\"UIColor\\\"\",</span><br><span class=\"line\">    \"_pageIndicatorTintColor -- @\\\"UIColor\\\"\",</span><br><span class=\"line\">    \"_legibilitySettings -- @\\\"_UILegibilitySettings\\\"\",</span><br><span class=\"line\">    \"_numberOfPages -- q\"</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>利用kvc设置<code>_currentPageImage</code>和<code>_pageImage</code></li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIPageControl</span> *pc = [[<span class=\"built_in\">UIPageControl</span> alloc]init];</span><br><span class=\"line\">[pc setValue:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"pageImage\"</span>] forKeyPath:<span class=\"string\">@\"_pageImage\"</span>];</span><br><span class=\"line\">[pc setValue:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"currentPageImage\"</span>] forKeyPath:<span class=\"string\">@\"_currentPageImage\"</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"XIB-Storyboard\"><a href=\"#XIB-Storyboard\" class=\"headerlink\" title=\"XIB/Storyboard\"></a>XIB/Storyboard</h3><p>在xib/Storyboard中，也可以使用KVC，例如下面是在xib中使用KVC把图片边框设置成圆角。<br><img src=\"/images/kvc_layer_cornerradius.png\" alt=\"\"></p>\n<h1 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h1><p>KVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。</p>\n<h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>KVO 是 Objective-C 对观察者设计模式的一种实现；[另外一种是：通知机制（notification）]。</p>\n<h2 id=\"使用（Swift）\"><a href=\"#使用（Swift）\" class=\"headerlink\" title=\"使用（Swift）\"></a>使用（Swift）</h2><p>需求：UIScrollView内包含一部分原生控件和UIWebView的组合;这种情况下UIWebView的高度无法得知，因为UIWebView写完中包含UIScrollerView，所以需要利用KVO技术监听UIWebView中UIScrollerView的contentSize的变化以达到需求的目的。</p>\n<h3 id=\"addOberver\"><a href=\"#addOberver\" class=\"headerlink\" title=\"addOberver\"></a>addOberver</h3><ul>\n<li>一般在viewDidLoad中添加监听<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scrollView = mWebView.subviews.first <span class=\"keyword\">as</span>? <span class=\"type\">UIScrollView</span> &#123;</span><br><span class=\"line\">            scrollView.alwaysBounceVertical = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.alwaysBounceHorizontal = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.bounces = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">\"contentSize\"</span>, options: .new, context: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"observerValueForkeyPath\"><a href=\"#observerValueForkeyPath\" class=\"headerlink\" title=\"observerValueForkeyPath\"></a>observerValueForkeyPath</h3><ul>\n<li>当contentSize发生变化时,会回调到<code>observerValueForkeyPath</code>这个方法<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">observeValue</span><span class=\"params\">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> keyPath == <span class=\"string\">\"contentSize\"</span> &amp;&amp; change != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = (change![<span class=\"type\">NSKeyValueChangeKey</span>.newKey] <span class=\"keyword\">as</span>! <span class=\"type\">NSValue</span>).cgSizeValue.height</span><br><span class=\"line\">            desViewHeightCons.constant = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver\"></a>removeObserver</h3><ul>\n<li>当界面销毁时，移除监听<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scrollView = mWebView?.subviews.first <span class=\"keyword\">as</span>? <span class=\"type\">UIScrollView</span> &#123;</span><br><span class=\"line\">            scrollView.removeObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">\"contentSize\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>键值编码(KVC)和键值观察（KVO）是根据<code>isa-swizzling</code>技术来实现的，主要依据runtime的强大动态能力。<br>当某个类第一次被观察时，系统会在运行时期动态的创建一个该类的派生类，在这个派生类中重写任何被观察属性的<code>setter</code>方法。派生类在被重写的setter方法实现真正的通知机制，这么设计是基于设置属性会调用setter方法，而通过重写就获得了KVO需要的通知机制，当然前提是要遵循KVO的属性设置方式来变更属性值，如果直接修改属性对应的成员变量是无法实现KVO的。<br>同时派生类还重写了class方法<code>欺骗</code>外部调用者它就是起初的那个类，然后系统将<code>isa</code>指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因为在该对象上对setter的调用就会调用的重写的setter，从而激活键值通知机制。此外派生类还重写了<code>delloc</code>方法来释放资源。</p>\n<p>在Runtime篇章中介绍过，isa指针其实指向的是类的元类，如果添加监听之前的类名为<code>Person</code>,那么添加监听之后被runtime更改以后的类名会变成：<code>NSKVONotifying_Person</code></p>\n<p>新的派生类<code>NSKVONotifying_Person</code>会重写以下方法：<br>增加了监听的属性对应的<code>setter</code>,<code>class</code>,<code>delloc</code>,<code>_isKVOA</code></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>重写class方法是为了方便我们调用它的时候，返回跟重写继承类之前同样的内容。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [[Person alloc]init];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"before isa:%@  class:%@\"</span>,object_getClass(person), [person <span class=\"keyword\">class</span>]);</span><br><span class=\"line\">[person addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"age\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end isa:%@  class:%@\"</span>,object_getClass(person), [person <span class=\"keyword\">class</span>]);</span><br><span class=\"line\">_person = person;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 19:55:23.430908+0800 KVO-Demo[6395:1312349] before isa:Person  class:Person</span><br><span class=\"line\">2018-05-23 19:55:23.431456+0800 KVO-Demo[6395:1312349] end isa:NSKVONotifying_Person  class:Person</span><br></pre></td></tr></table></figure></p>\n<p>这也是<code>isa</code>指针和<code>class</code>方法的一个区别，使用的时候要<code>特别注意</code>。</p>\n<h3 id=\"setter\"><a href=\"#setter\" class=\"headerlink\" title=\"setter\"></a>setter</h3><p>新的派生类会重写对应的setter方法，其实是为了在setter中增加另外两个方法的调用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>didChangeValueForKey</code>负责触发：<code>observeValueForKeyPath:keyPath :object :change :context</code>方法，这就是<code>kvo</code>的原理。<br>如果没有执行<code>setter</code>之类的调用，那么使用<code>setValue:forKey</code>方法也会直接调用<code>observeValueForKeyPath:keyPath :object :change :context</code>方法<br>再如果既没有调用<code>setter</code>也没有调用<code>setValue:forKey</code>，那么<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key</span><br></pre></td></tr></table></figure></p>\n<p>我们只需要显示调用上述两个方法，就会触发<code>observeValueForKeyPath:keyPath :object :change :context</code>方法，同样可以使用KVO。</p>\n<h3 id=\"isKVOA\"><a href=\"#isKVOA\" class=\"headerlink\" title=\"_isKVOA\"></a><code>_isKVOA</code></h3><p>这个私有方法是用来表示该类是一个KVO机制声明的类</p>\n<h3 id=\"小结（触发KVO的三种方法）\"><a href=\"#小结（触发KVO的三种方法）\" class=\"headerlink\" title=\"小结（触发KVO的三种方法）\"></a>小结（触发KVO的三种方法）</h3><ol>\n<li>使用KVC （运行时会在<code>setValue:forKey</code>中来调用<code>will/didChangeValueForKey:</code>）</li>\n<li>使用setter方法（运行时会在setter方法中调用<code>will/didChangeValueForKey:</code>）</li>\n<li>显示调用<code>will/didChangeValueForKey:</code>方法</li>\n</ol>\n<h2 id=\"如何更优雅的使用KVO\"><a href=\"#如何更优雅的使用KVO\" class=\"headerlink\" title=\"如何更优雅的使用KVO\"></a>如何更优雅的使用KVO</h2><p>只需要使用 Facebook 开源的 <a href=\"https://github.com/facebook/KVOController\" target=\"_blank\" rel=\"noopener\">KVOController</a> 框架就可以优雅地解决这些问题了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.KVOController observe:person</span><br><span class=\"line\">                    keyPath:<span class=\"string\">@\"age\"</span></span><br><span class=\"line\">                    options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionOld</span></span><br><span class=\"line\">                      block:^(<span class=\"keyword\">id</span>  observer, <span class=\"keyword\">id</span>  object, <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span>  * , <span class=\"keyword\">id</span>&gt; *  change) &#123;</span><br><span class=\"line\">                          <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, change);</span><br><span class=\"line\">                      &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>我们可以在任意对象上获得 <code>KVOController</code> 对象，然后调用它的实例方法 <code>-observer:keyPath:options:block:</code> 就可以检测某个对象对应的属性了，该方法传入的参数非常容易理解，在 block 中也可以获得所有与 KVO 有关的参数。</p>\n<p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题:</p>\n<p>不需要手动移除观察者；<br>实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；<br>使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；<br>每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；</p>\n<h1 id=\"参考文档和博客\"><a href=\"#参考文档和博客\" class=\"headerlink\" title=\"参考文档和博客\"></a>参考文档和博客</h1><p><a href=\"http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1\" target=\"_blank\" rel=\"noopener\">http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1</a><br><a href=\"https://blog.csdn.net/wzzvictory/article/details/9674431\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wzzvictory/article/details/9674431</a><br><a href=\"https://blog.csdn.net/kesalin/article/details/8194240\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kesalin/article/details/8194240</a><br><a href=\"https://draveness.me/kvocontroller\" target=\"_blank\" rel=\"noopener\">https://draveness.me/kvocontroller</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"KVC\"><a href=\"#KVC\" class=\"headerlink\" title=\"KVC\"></a>KVC</h1><p>KVC(键值编码)，即 Key-Value Coding，一个非正式的 Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用 Setter、Getter 方法等显式的存取方式去访问。</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>KVC（Key-value coding），键值编码；是指在iOS开发中，可以允许开发者通过属性名<code>Key</code>直接访问对象的属性并给属性<code>编码</code>（赋值value），而不是调用对应的getter/setter方法。很多高级的iOS开发技巧都是基于KVC实现，例如修改系统控件内部属性；json-&gt;model的映射框架等。</p>\n<h2 id=\"KVC最重要的四个方法\"><a href=\"#KVC最重要的四个方法\" class=\"headerlink\" title=\"KVC最重要的四个方法\"></a>KVC最重要的四个方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> * )key;                          <span class=\"comment\">//直接通过Key来取值</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> * )key;          <span class=\"comment\">//通过Key来设值</span></span><br><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath;                  <span class=\"comment\">//通过KeyPath来取值</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath;  <span class=\"comment\">//通过KeyPath来设值</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"valueForKey-和-valueForKeyPath区别\"><a href=\"#valueForKey-和-valueForKeyPath区别\" class=\"headerlink\" title=\"valueForKey 和 valueForKeyPath区别\"></a>valueForKey 和 valueForKeyPath区别</h2><h3 id=\"先来看一段代码\"><a href=\"#先来看一段代码\" class=\"headerlink\" title=\"先来看一段代码\"></a>先来看一段代码</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * dict = @&#123;<span class=\"string\">@\"key1\"</span>:<span class=\"string\">@\"value1\"</span>,</span><br><span class=\"line\">                           <span class=\"string\">@\"second\"</span>:@&#123;</span><br><span class=\"line\">                                   <span class=\"string\">@\"k1\"</span>:<span class=\"string\">@\"v1\"</span>,</span><br><span class=\"line\">                                   <span class=\"string\">@\"k2\"</span>:<span class=\"string\">@\"v2\"</span>,</span><br><span class=\"line\">                                   <span class=\"string\">@\"third\"</span>:@&#123;</span><br><span class=\"line\">                                           <span class=\"string\">@\"t1\"</span>:<span class=\"string\">@\"h1\"</span>,</span><br><span class=\"line\">                                           <span class=\"string\">@\"t2\"</span>:<span class=\"string\">@\"h2\"</span></span><br><span class=\"line\">                                           &#125;</span><br><span class=\"line\">                                   &#125;</span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * second = [dict valueForKey:<span class=\"string\">@\"second\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * third1 = [second valueForKey:<span class=\"string\">@\"third\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,third1);</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * third2 = [dict valueForKeyPath:<span class=\"string\">@\"second.third\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,third2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h3><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 13:52:33.430617+0800 KVC-Demo[1584:403407] &#123;</span><br><span class=\"line\">    t1 = h1;</span><br><span class=\"line\">    t2 = h2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">2018-05-23 13:52:33.430800+0800 KVC-Demo[1584:403407] &#123;</span><br><span class=\"line\">    t1 = h1;</span><br><span class=\"line\">    t2 = h2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>通过代码我们可以看出，我们想要从dict这个字典中获取到<code>third</code>这个key所对应的值得话,使用<code>valueForKey</code>需要通过一层一层的对象才能取到想要的字典，而使用valueForKeyPath则只需要输入third在字典中的<code>路径（path）</code>一次就可以取到third字典。</p>\n<h3 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h3><p><a href=\"https://www.jianshu.com/p/c0e099f72a3b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c0e099f72a3b</a><br><a href=\"https://www.jianshu.com/p/a6a0abac1c4a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/a6a0abac1c4a</a></p>\n<h2 id=\"KVC的使用\"><a href=\"#KVC的使用\" class=\"headerlink\" title=\"KVC的使用\"></a>KVC的使用</h2><h3 id=\"代替getter-setter\"><a href=\"#代替getter-setter\" class=\"headerlink\" title=\"代替getter/setter\"></a>代替getter/setter</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Model</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> * text;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) SubModel * subModel;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">SubModel</span> : <span class=\"title\">Model</span></span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> * subText;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>不使用kvc</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">Model *model = [[Model alloc]init];</span><br><span class=\"line\">model.text = <span class=\"string\">@\"text\"</span>;</span><br><span class=\"line\">SubModel *subModel = [[SubModel alloc]init];</span><br><span class=\"line\">subModel.subText = <span class=\"string\">@\"subText\"</span>;</span><br><span class=\"line\">model.subModel = subModel;</span><br><span class=\"line\"><span class=\"comment\">//取值</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *text =  model.text;</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *subText = model.subModel.subText;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用kvc</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//赋值</span></span><br><span class=\"line\">Model *model = [[Model alloc]init];</span><br><span class=\"line\">[model setValue:<span class=\"string\">@\"text\"</span> forKey:<span class=\"string\">@\"text\"</span>];</span><br><span class=\"line\">[model setValue:<span class=\"string\">@\"subText\"</span> forKeyPath:<span class=\"string\">@\"subModel.subText\"</span>];</span><br><span class=\"line\"><span class=\"comment\">//取值</span></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *text =  [model valueForKey:<span class=\"string\">@\"text\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *subText = [model valueForKeyPath:<span class=\"string\">@\"subModel.subText\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"字典转模型（仿YYModel）\"><a href=\"#字典转模型（仿YYModel）\" class=\"headerlink\" title=\"字典转模型（仿YYModel）\"></a>字典转模型（仿YYModel）</h3><ul>\n<li><p>创建NSObject的扩展NSObject+Model</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>) tb_modelWithDictionary:(<span class=\"built_in\">NSDictionary</span> * )dictionary;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现SObject+Model<br>利用Runtime取到对应类的属性列表，在使用kvc对所有属性进行赋值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSArray</span> * )getPropertyList:(Class)cls&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = objc_getAssociatedObject(<span class=\"keyword\">self</span>, `_cmd`);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array != <span class=\"literal\">nil</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * arrM = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">//输出个数</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount;</span><br><span class=\"line\">    <span class=\"comment\">//获取属性列表（ objc_property_t * ）</span></span><br><span class=\"line\">    objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;outCount; ++i) &#123;</span><br><span class=\"line\">        objc_property_t property = properties[i];</span><br><span class=\"line\">        <span class=\"comment\">//属性名字</span></span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class=\"line\">        [arrM addObject:name];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(getPropertyList:), [arrM <span class=\"keyword\">copy</span>], OBJC_ASSOCIATION_RETAIN);</span><br><span class=\"line\">    free(properties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [arrM <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)tb_modelWithDictionary:(<span class=\"built_in\">NSDictionary</span> * )dictionary&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSObject</span> * object = [[<span class=\"keyword\">self</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = [<span class=\"keyword\">self</span> getPropertyList:[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">    [dictionary enumerateKeysAndObjectsUsingBlock:^(<span class=\"built_in\">NSString</span> * key, <span class=\"keyword\">id</span> value, <span class=\"built_in\">BOOL</span> * stop) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([array containsObject:key])&#123;</span><br><span class=\"line\">            [object setValue:value forKey:key];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span>  object;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用tb_modelWithDictionary模仿YYModel的字典转模型方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> * dict = @&#123;</span><br><span class=\"line\">                           <span class=\"string\">@\"text\"</span>:<span class=\"string\">@\"text\"</span></span><br><span class=\"line\">                           &#125;;</span><br><span class=\"line\">    Model * model = [Model tb_modelWithDictionary:dict];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,model);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改系统控件内部属性（runtime-kvc）\"><a href=\"#修改系统控件内部属性（runtime-kvc）\" class=\"headerlink\" title=\"修改系统控件内部属性（runtime+kvc）\"></a>修改系统控件内部属性（runtime+kvc）</h3><ul>\n<li>需求：修改UIPageControl小圆点的背景图片</li>\n<li>查看UIPageControl.h如下<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NS_CLASS_AVAILABLE_IOS</span>(<span class=\"number\">2</span>_0) <span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIPageControl</span> : <span class=\"title\">UIControl</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> numberOfPages;          <span class=\"comment\">// default is 0</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSInteger</span> currentPage;            <span class=\"comment\">// default is 0. value pinned to 0..numberOfPages-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> hidesForSinglePage;          <span class=\"comment\">// hide the the indicator if there is only one page. default is NO</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">BOOL</span> defersCurrentPageDisplay;    <span class=\"comment\">// if set, clicking to a new page won't update the currently displayed page until -updateCurrentPageDisplay is called. default is NO</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)updateCurrentPageDisplay;                      <span class=\"comment\">// update page display to match the currentPage. ignored if defersCurrentPageDisplay is NO. setting the page value directly will update immediately</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGSize</span>)sizeForNumberOfPages:(<span class=\"built_in\">NSInteger</span>)pageCount;   <span class=\"comment\">// returns minimum size required to display dots for given page count. can be used to size control if page count could change</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> * pageIndicatorTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nullable</span>, <span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">UIColor</span> * currentPageIndicatorTintColor <span class=\"built_in\">NS_AVAILABLE_IOS</span>(<span class=\"number\">6</span>_0) <span class=\"built_in\">UI_APPEARANCE_SELECTOR</span>;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>没有发现UIPageControl暴露的操作中有设置小圆点背景图片的方法和属性，那么就可以利用runtime遍历UIPageControl类的成员变量（<code>ivar</code>）和属性（<code>property</code>）</p>\n<ul>\n<li>利用runtime遍历UIPageControl成员变量</li>\n</ul>\n<p>导入头文件：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>遍历成员变量：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">UIPageControl</span> * pc = [[<span class=\"built_in\">UIPageControl</span> alloc]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> * array = [<span class=\"keyword\">self</span> getIvarList:[pc <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,array);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> * )getIvarList:(Class)cls&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> * arrM = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> outCount;</span><br><span class=\"line\">    Ivar * ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;outCount; ++i) &#123;</span><br><span class=\"line\">        Ivar ivar = ivars[i];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * type = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> * str = [name stringByAppendingFormat:<span class=\"string\">@\" -- %@\"</span>,type];</span><br><span class=\"line\">        [arrM addObject:str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(ivars);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [arrM <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 16:45:18.380346+0800 KVC-Demo[4400:856521] (</span><br><span class=\"line\">    \"_lastUserInterfaceIdiom -- q\",</span><br><span class=\"line\">    \"_indicators -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_currentPage -- q\",</span><br><span class=\"line\">    \"_displayedPage -- q\",</span><br><span class=\"line\">    \"_pageControlFlags -- &#123;?=\\\"hideForSinglePage\\\"b1\\\"defersCurrentPageDisplay\\\"b1&#125;\",</span><br><span class=\"line\">    \"_currentPageImage -- @\\\"UIImage\\\"\",</span><br><span class=\"line\">    \"_pageImage -- @\\\"UIImage\\\"\",</span><br><span class=\"line\">    \"_currentPageImages -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_pageImages -- @\\\"NSMutableArray\\\"\",</span><br><span class=\"line\">    \"_backgroundVisualEffectView -- @\\\"UIVisualEffectView\\\"\",</span><br><span class=\"line\">    \"_currentPageIndicatorTintColor -- @\\\"UIColor\\\"\",</span><br><span class=\"line\">    \"_pageIndicatorTintColor -- @\\\"UIColor\\\"\",</span><br><span class=\"line\">    \"_legibilitySettings -- @\\\"_UILegibilitySettings\\\"\",</span><br><span class=\"line\">    \"_numberOfPages -- q\"</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>利用kvc设置<code>_currentPageImage</code>和<code>_pageImage</code></li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIPageControl</span> *pc = [[<span class=\"built_in\">UIPageControl</span> alloc]init];</span><br><span class=\"line\">[pc setValue:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"pageImage\"</span>] forKeyPath:<span class=\"string\">@\"_pageImage\"</span>];</span><br><span class=\"line\">[pc setValue:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"currentPageImage\"</span>] forKeyPath:<span class=\"string\">@\"_currentPageImage\"</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"XIB-Storyboard\"><a href=\"#XIB-Storyboard\" class=\"headerlink\" title=\"XIB/Storyboard\"></a>XIB/Storyboard</h3><p>在xib/Storyboard中，也可以使用KVC，例如下面是在xib中使用KVC把图片边框设置成圆角。<br><img src=\"/images/kvc_layer_cornerradius.png\" alt=\"\"></p>\n<h1 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h1><p>KVO(键值监听)，即 Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后，对象就会接受到通知，前提是执行了 setter 方法、或者使用了 KVC 赋值。</p>\n<h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>KVO 是 Objective-C 对观察者设计模式的一种实现；[另外一种是：通知机制（notification）]。</p>\n<h2 id=\"使用（Swift）\"><a href=\"#使用（Swift）\" class=\"headerlink\" title=\"使用（Swift）\"></a>使用（Swift）</h2><p>需求：UIScrollView内包含一部分原生控件和UIWebView的组合;这种情况下UIWebView的高度无法得知，因为UIWebView写完中包含UIScrollerView，所以需要利用KVO技术监听UIWebView中UIScrollerView的contentSize的变化以达到需求的目的。</p>\n<h3 id=\"addOberver\"><a href=\"#addOberver\" class=\"headerlink\" title=\"addOberver\"></a>addOberver</h3><ul>\n<li>一般在viewDidLoad中添加监听<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scrollView = mWebView.subviews.first <span class=\"keyword\">as</span>? <span class=\"type\">UIScrollView</span> &#123;</span><br><span class=\"line\">            scrollView.alwaysBounceVertical = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.alwaysBounceHorizontal = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.bounces = <span class=\"literal\">false</span></span><br><span class=\"line\">            scrollView.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">\"contentSize\"</span>, options: .new, context: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"observerValueForkeyPath\"><a href=\"#observerValueForkeyPath\" class=\"headerlink\" title=\"observerValueForkeyPath\"></a>observerValueForkeyPath</h3><ul>\n<li>当contentSize发生变化时,会回调到<code>observerValueForkeyPath</code>这个方法<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">observeValue</span><span class=\"params\">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> keyPath == <span class=\"string\">\"contentSize\"</span> &amp;&amp; change != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = (change![<span class=\"type\">NSKeyValueChangeKey</span>.newKey] <span class=\"keyword\">as</span>! <span class=\"type\">NSValue</span>).cgSizeValue.height</span><br><span class=\"line\">            desViewHeightCons.constant = value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"removeObserver\"><a href=\"#removeObserver\" class=\"headerlink\" title=\"removeObserver\"></a>removeObserver</h3><ul>\n<li>当界面销毁时，移除监听<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> scrollView = mWebView?.subviews.first <span class=\"keyword\">as</span>? <span class=\"type\">UIScrollView</span> &#123;</span><br><span class=\"line\">            scrollView.removeObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">\"contentSize\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"KVO的原理\"><a href=\"#KVO的原理\" class=\"headerlink\" title=\"KVO的原理\"></a>KVO的原理</h2><p>键值编码(KVC)和键值观察（KVO）是根据<code>isa-swizzling</code>技术来实现的，主要依据runtime的强大动态能力。<br>当某个类第一次被观察时，系统会在运行时期动态的创建一个该类的派生类，在这个派生类中重写任何被观察属性的<code>setter</code>方法。派生类在被重写的setter方法实现真正的通知机制，这么设计是基于设置属性会调用setter方法，而通过重写就获得了KVO需要的通知机制，当然前提是要遵循KVO的属性设置方式来变更属性值，如果直接修改属性对应的成员变量是无法实现KVO的。<br>同时派生类还重写了class方法<code>欺骗</code>外部调用者它就是起初的那个类，然后系统将<code>isa</code>指针指向这个新诞生的派生类，因此这个对象就成为该派生类的对象了，因为在该对象上对setter的调用就会调用的重写的setter，从而激活键值通知机制。此外派生类还重写了<code>delloc</code>方法来释放资源。</p>\n<p>在Runtime篇章中介绍过，isa指针其实指向的是类的元类，如果添加监听之前的类名为<code>Person</code>,那么添加监听之后被runtime更改以后的类名会变成：<code>NSKVONotifying_Person</code></p>\n<p>新的派生类<code>NSKVONotifying_Person</code>会重写以下方法：<br>增加了监听的属性对应的<code>setter</code>,<code>class</code>,<code>delloc</code>,<code>_isKVOA</code></p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p>重写class方法是为了方便我们调用它的时候，返回跟重写继承类之前同样的内容。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [[Person alloc]init];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"before isa:%@  class:%@\"</span>,object_getClass(person), [person <span class=\"keyword\">class</span>]);</span><br><span class=\"line\">[person addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"age\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end isa:%@  class:%@\"</span>,object_getClass(person), [person <span class=\"keyword\">class</span>]);</span><br><span class=\"line\">_person = person;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-23 19:55:23.430908+0800 KVO-Demo[6395:1312349] before isa:Person  class:Person</span><br><span class=\"line\">2018-05-23 19:55:23.431456+0800 KVO-Demo[6395:1312349] end isa:NSKVONotifying_Person  class:Person</span><br></pre></td></tr></table></figure></p>\n<p>这也是<code>isa</code>指针和<code>class</code>方法的一个区别，使用的时候要<code>特别注意</code>。</p>\n<h3 id=\"setter\"><a href=\"#setter\" class=\"headerlink\" title=\"setter\"></a>setter</h3><p>新的派生类会重写对应的setter方法，其实是为了在setter中增加另外两个方法的调用<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>didChangeValueForKey</code>负责触发：<code>observeValueForKeyPath:keyPath :object :change :context</code>方法，这就是<code>kvo</code>的原理。<br>如果没有执行<code>setter</code>之类的调用，那么使用<code>setValue:forKey</code>方法也会直接调用<code>observeValueForKeyPath:keyPath :object :change :context</code>方法<br>再如果既没有调用<code>setter</code>也没有调用<code>setValue:forKey</code>，那么<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key  </span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> * )key</span><br></pre></td></tr></table></figure></p>\n<p>我们只需要显示调用上述两个方法，就会触发<code>observeValueForKeyPath:keyPath :object :change :context</code>方法，同样可以使用KVO。</p>\n<h3 id=\"isKVOA\"><a href=\"#isKVOA\" class=\"headerlink\" title=\"_isKVOA\"></a><code>_isKVOA</code></h3><p>这个私有方法是用来表示该类是一个KVO机制声明的类</p>\n<h3 id=\"小结（触发KVO的三种方法）\"><a href=\"#小结（触发KVO的三种方法）\" class=\"headerlink\" title=\"小结（触发KVO的三种方法）\"></a>小结（触发KVO的三种方法）</h3><ol>\n<li>使用KVC （运行时会在<code>setValue:forKey</code>中来调用<code>will/didChangeValueForKey:</code>）</li>\n<li>使用setter方法（运行时会在setter方法中调用<code>will/didChangeValueForKey:</code>）</li>\n<li>显示调用<code>will/didChangeValueForKey:</code>方法</li>\n</ol>\n<h2 id=\"如何更优雅的使用KVO\"><a href=\"#如何更优雅的使用KVO\" class=\"headerlink\" title=\"如何更优雅的使用KVO\"></a>如何更优雅的使用KVO</h2><p>只需要使用 Facebook 开源的 <a href=\"https://github.com/facebook/KVOController\" target=\"_blank\" rel=\"noopener\">KVOController</a> 框架就可以优雅地解决这些问题了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.KVOController observe:person</span><br><span class=\"line\">                    keyPath:<span class=\"string\">@\"age\"</span></span><br><span class=\"line\">                    options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> | <span class=\"built_in\">NSKeyValueObservingOptionOld</span></span><br><span class=\"line\">                      block:^(<span class=\"keyword\">id</span>  observer, <span class=\"keyword\">id</span>  object, <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span>  * , <span class=\"keyword\">id</span>&gt; *  change) &#123;</span><br><span class=\"line\">                          <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, change);</span><br><span class=\"line\">                      &#125;];</span><br></pre></td></tr></table></figure></p>\n<p>我们可以在任意对象上获得 <code>KVOController</code> 对象，然后调用它的实例方法 <code>-observer:keyPath:options:block:</code> 就可以检测某个对象对应的属性了，该方法传入的参数非常容易理解，在 block 中也可以获得所有与 KVO 有关的参数。</p>\n<p>使用 KVOController 进行键值观测可以说完美地解决了在使用原生 KVO 时遇到的各种问题:</p>\n<p>不需要手动移除观察者；<br>实现 KVO 与事件发生处的代码上下文相同，不需要跨方法传参数；<br>使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；<br>每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；</p>\n<h1 id=\"参考文档和博客\"><a href=\"#参考文档和博客\" class=\"headerlink\" title=\"参考文档和博客\"></a>参考文档和博客</h1><p><a href=\"http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1\" target=\"_blank\" rel=\"noopener\">http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/KeyValueCoding/Articles/KeyValueCoding.html#//apple_ref/doc/uid/10000107-SW1</a><br><a href=\"https://blog.csdn.net/wzzvictory/article/details/9674431\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wzzvictory/article/details/9674431</a><br><a href=\"https://blog.csdn.net/kesalin/article/details/8194240\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kesalin/article/details/8194240</a><br><a href=\"https://draveness.me/kvocontroller\" target=\"_blank\" rel=\"noopener\">https://draveness.me/kvocontroller</a></p>\n"},{"title":"iOS - NSURLSession","date":"2018-04-29T11:31:42.000Z","_content":"\nApple在 iOS9.0 之后已经放弃了 NSURLConnection，所以在现在的实际开发中，一般使用的是 iOS7.0 之后推出的 NSURLSession。NSURLSession 和 NSURLConnection 都提供了与各种协议，诸如 HTTP 和 HTTPS 进行交互的API。会话对象（NSURLSession 类对象）就是用于管理这种交互过程。它是一个高度可配置的容器，通过使用其提供的API，可进行细粒度的管理控制。它提供了在 NSURLConnection 中的所有特性，此外，它还可以实现 NSURLConnection 不能完成的任务，例如实现私密浏览。\n## 结构图\n![](/images/network_class_struct.png)\n## NSURLSession发送网络请求\n``` Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSURL * URL = [NSURL URLWithString:@\"http://www.baidu.com\"];\n    NSURLSession * session = [NSURLSession sharedSession];\n\t\tNSURLSessionDataTask * dataTask = [session dataTaskWithURL:URL completionHandler:^(NSData * data, NSURLResponse * response, NSError * error) {\n\t\t\t // data : 响应体; response : 响应头; error : 错误信息\n\t\t\t if (error == nil && data != nil){\n\t\t\t\t\t NSLog(@\"%@ -- %@ -- %@\",response,data,[NSThread currentThread]);\n\t\t\t } else {\n\t\t\t\t\t NSLog(@\"%@\",error);\n\t\t\t }\n\t }];\n   [dataTask resume];\n}\n```\n\n## HTML字符串反序列化\n``` Objc\n [[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\t\t\t\t// 反序列化HTML字符串\n\t\t\t\tNSString * html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n\t\t\t\t// 展示HTML字符串\n\t\t\t\t[self.webView loadHTMLString:html baseURL:URL];\n\t}];\n```\n\n## 小结\n- 为了方便程序员使用，NSURLSession提供了一个全局单例 session.\n- 所有的 任务(Task) 都是由 session 发起的.\n- 所有的任务默认是挂起的，需要 resume.\n- 完成回调是异步的\n- session可以自定义,自定义的时候可以同时设置代理.\n> AFNetworing 底层其实就是对 NSURLSession 的封装\n","source":"_posts/ios-network-nsurlsession.md","raw":"---\ntitle: iOS - NSURLSession\ndate: 2018-04-29 19:31:42\ntags: [iOS,Objc,Network,NSURLSession]\ncategories: [iOS,Objc]\n---\n\nApple在 iOS9.0 之后已经放弃了 NSURLConnection，所以在现在的实际开发中，一般使用的是 iOS7.0 之后推出的 NSURLSession。NSURLSession 和 NSURLConnection 都提供了与各种协议，诸如 HTTP 和 HTTPS 进行交互的API。会话对象（NSURLSession 类对象）就是用于管理这种交互过程。它是一个高度可配置的容器，通过使用其提供的API，可进行细粒度的管理控制。它提供了在 NSURLConnection 中的所有特性，此外，它还可以实现 NSURLConnection 不能完成的任务，例如实现私密浏览。\n## 结构图\n![](/images/network_class_struct.png)\n## NSURLSession发送网络请求\n``` Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSURL * URL = [NSURL URLWithString:@\"http://www.baidu.com\"];\n    NSURLSession * session = [NSURLSession sharedSession];\n\t\tNSURLSessionDataTask * dataTask = [session dataTaskWithURL:URL completionHandler:^(NSData * data, NSURLResponse * response, NSError * error) {\n\t\t\t // data : 响应体; response : 响应头; error : 错误信息\n\t\t\t if (error == nil && data != nil){\n\t\t\t\t\t NSLog(@\"%@ -- %@ -- %@\",response,data,[NSThread currentThread]);\n\t\t\t } else {\n\t\t\t\t\t NSLog(@\"%@\",error);\n\t\t\t }\n\t }];\n   [dataTask resume];\n}\n```\n\n## HTML字符串反序列化\n``` Objc\n [[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\t\t\t\t// 反序列化HTML字符串\n\t\t\t\tNSString * html = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n\t\t\t\t// 展示HTML字符串\n\t\t\t\t[self.webView loadHTMLString:html baseURL:URL];\n\t}];\n```\n\n## 小结\n- 为了方便程序员使用，NSURLSession提供了一个全局单例 session.\n- 所有的 任务(Task) 都是由 session 发起的.\n- 所有的任务默认是挂起的，需要 resume.\n- 完成回调是异步的\n- session可以自定义,自定义的时候可以同时设置代理.\n> AFNetworing 底层其实就是对 NSURLSession 的封装\n","slug":"ios-network-nsurlsession","published":1,"updated":"2019-01-13T05:09:34.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2i0013l1fqrnwjr2pp","content":"<p>Apple在 iOS9.0 之后已经放弃了 NSURLConnection，所以在现在的实际开发中，一般使用的是 iOS7.0 之后推出的 NSURLSession。NSURLSession 和 NSURLConnection 都提供了与各种协议，诸如 HTTP 和 HTTPS 进行交互的API。会话对象（NSURLSession 类对象）就是用于管理这种交互过程。它是一个高度可配置的容器，通过使用其提供的API，可进行细粒度的管理控制。它提供了在 NSURLConnection 中的所有特性，此外，它还可以实现 NSURLConnection 不能完成的任务，例如实现私密浏览。</p>\n<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"/images/network_class_struct.png\" alt=\"\"></p>\n<h2 id=\"NSURLSession发送网络请求\"><a href=\"#NSURLSession发送网络请求\" class=\"headerlink\" title=\"NSURLSession发送网络请求\"></a>NSURLSession发送网络请求</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> * session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSURLSessionDataTask</span> * dataTask = [session dataTaskWithURL:URL completionHandler:^(<span class=\"built_in\">NSData</span> * data, <span class=\"built_in\">NSURLResponse</span> * response, <span class=\"built_in\">NSError</span> * error) &#123;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">// data : 响应体; response : 响应头; error : 错误信息</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (error == <span class=\"literal\">nil</span> &amp;&amp; data != <span class=\"literal\">nil</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@ -- %@\"</span>,response,data,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t\t &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t &#125;];</span><br><span class=\"line\">   [dataTask resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML字符串反序列化\"><a href=\"#HTML字符串反序列化\" class=\"headerlink\" title=\"HTML字符串反序列化\"></a>HTML字符串反序列化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 反序列化HTML字符串</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSString</span> * html = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 展示HTML字符串</span></span><br><span class=\"line\">\t\t\t[<span class=\"keyword\">self</span>.webView loadHTMLString:html baseURL:URL];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>为了方便程序员使用，NSURLSession提供了一个全局单例 session.</li>\n<li>所有的 任务(Task) 都是由 session 发起的.</li>\n<li>所有的任务默认是挂起的，需要 resume.</li>\n<li>完成回调是异步的</li>\n<li>session可以自定义,自定义的时候可以同时设置代理.<blockquote>\n<p>AFNetworing 底层其实就是对 NSURLSession 的封装</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Apple在 iOS9.0 之后已经放弃了 NSURLConnection，所以在现在的实际开发中，一般使用的是 iOS7.0 之后推出的 NSURLSession。NSURLSession 和 NSURLConnection 都提供了与各种协议，诸如 HTTP 和 HTTPS 进行交互的API。会话对象（NSURLSession 类对象）就是用于管理这种交互过程。它是一个高度可配置的容器，通过使用其提供的API，可进行细粒度的管理控制。它提供了在 NSURLConnection 中的所有特性，此外，它还可以实现 NSURLConnection 不能完成的任务，例如实现私密浏览。</p>\n<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"/images/network_class_struct.png\" alt=\"\"></p>\n<h2 id=\"NSURLSession发送网络请求\"><a href=\"#NSURLSession发送网络请求\" class=\"headerlink\" title=\"NSURLSession发送网络请求\"></a>NSURLSession发送网络请求</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://www.baidu.com\"</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSURLSession</span> * session = [<span class=\"built_in\">NSURLSession</span> sharedSession];</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSURLSessionDataTask</span> * dataTask = [session dataTaskWithURL:URL completionHandler:^(<span class=\"built_in\">NSData</span> * data, <span class=\"built_in\">NSURLResponse</span> * response, <span class=\"built_in\">NSError</span> * error) &#123;</span><br><span class=\"line\">\t\t\t <span class=\"comment\">// data : 响应体; response : 响应头; error : 错误信息</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> (error == <span class=\"literal\">nil</span> &amp;&amp; data != <span class=\"literal\">nil</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@ -- %@\"</span>,response,data,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t\t &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</span><br><span class=\"line\">\t\t\t &#125;</span><br><span class=\"line\">\t &#125;];</span><br><span class=\"line\">   [dataTask resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML字符串反序列化\"><a href=\"#HTML字符串反序列化\" class=\"headerlink\" title=\"HTML字符串反序列化\"></a>HTML字符串反序列化</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 反序列化HTML字符串</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSString</span> * html = [[<span class=\"built_in\">NSString</span> alloc] initWithData:data encoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 展示HTML字符串</span></span><br><span class=\"line\">\t\t\t[<span class=\"keyword\">self</span>.webView loadHTMLString:html baseURL:URL];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>为了方便程序员使用，NSURLSession提供了一个全局单例 session.</li>\n<li>所有的 任务(Task) 都是由 session 发起的.</li>\n<li>所有的任务默认是挂起的，需要 resume.</li>\n<li>完成回调是异步的</li>\n<li>session可以自定义,自定义的时候可以同时设置代理.<blockquote>\n<p>AFNetworing 底层其实就是对 NSURLSession 的封装</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"iOS - 网络基础 & Http & Https","date":"2018-04-29T09:29:30.000Z","_content":"# HTTP\nHTTP：Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型\n## Request\n### GET\n``` html\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n（这里是请求数据）\n```\n- 第一部分：第一行是请求行（request line）\n- 第二部分：请求头（header），用来说明服务器要使用的附加信息\n- 第三部分：空行，请求头后面的空行是`必须`的\n- 第四部分：请求数据也叫主体，可以添加任意数据\n\n### POST\n``` html\nPOST / HTTP1.1\nHost: www.baidu.com\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 40\nConnection: Keep-Alive\n\nname=Professional%20Ajax&publisher=Wiley\n```\n- 第一部分：请求行，第一行是post请求，以及http1.1版本。\n- 第二部分：请求头部，第二行至第六行。\n- 第三部分：空行，第七行的空行。\n- 第四部分：请求数据，第八行。\n\n\n### GET和POST的区别\n- GET请求的数据会附在URL之后显示出来（数据放置在http协议头中）而POST把提交的数据放置在是HTTP包的包体中\n- 传输数据的大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但GET请求时特定浏览器和服务器对URL长度有限制（eg:IE限制2083个字节,2k+35）\n- 安全性：POST的安全性要比GET的安全性高（GET提交时，用户名密码会明文出现在URL上）\n\n\n## Response\n``` html\nHTTP/1.1 200 OK\nDate: Fri, 22 April 2018 06:07:21 GMT\nContent-Type: text/html; charset=UTF-8\n\n<html>\n\t  <head></head>\n\t  <body>\n\t\t\t<!--body goes here-->\n\t  </body>\n</html>\n```\n- 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n- 第二部分：消息报头，用来说明客户端要使用的一些附加信息\n- 第三部分：空行，消息报头后面的空行是必须的\n- 第四部分：响应正文，服务器返回给客户端的文本信息。\n\n## Http状态码\n- 1xx：指示信息--表示请求已接收，继续处理\n- 2xx：成功--表示请求已被成功接收、理解、接受\n- 3xx：重定向--要完成请求必须进行更进一步的操作\n- 4xx：客户端错误--请求有语法错误或请求无法实现\n- 5xx：服务器端错误--服务器未能实现合法的请求\n\n\n## 网络通信三要素\n### IP地址（主机名）\n- 网络中设备的标示\n- 本地回环地址：127.0.0.1 主机名：localhost\n\n### 端口号\n- 用于标示进程的逻辑地址，不同进程的标示\n- 有效端口：`0-65535`\n- 其中 `0-1024`由系统使用或者保留端口，开发中不要使用 1024 以下的端口\n- **注意** : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.处理HTTPS请求的端口号是443.\n\n### 传输协议\n- UDP(数据报文协议)\n\t- 只管发送，不确认对方是否接收到\n\t- 将数据源和目的封装成数据包中，不需要建立连接\n\t- 每个数据报的大小限制在64K之内\n\t- 因为无需连接，因此是不可靠协议\n\t- 不需要建立连接，速度快\n\t- 应用场景：多媒体教室／网络流媒体 / 视频实时共享\n\t- 当视频共享时,出现卡屏,就是因为UDP协议在传递数据时出现丢包.\n\n- TCP(传输控制协议)\n\t- 建立连接，形成传输数据的通道\n\t- 在连接中进行大数据传输（数据大小不受限制）\n\t- 通过三次握手完成连接，是可靠协议\n\t- 必须建立连接，效率会稍低\n\t- TCP协议的传输速度比UDP协议慢\n\n\n### 三次握手的描述\n- 图解：![](/images/network_three_time_hand.png)\n- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了\n\n\n### **注：**\n> 通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据\n\n\n## TCP/IP网络参考模型\n### 网络模型（理论）\n![](/images/network_theory_model.png)\n### 网络参考模型（现实）\n![](/images/network_real_model.png)\n### 通信过程\n![](/images/network_commute_progress.png)\n- 应用层 : APP\n- 传输层 : TCP,确定数据如何传输\n- 网络层 : 确定目标计算机的IP地址\n- 链路层 : 硬件,添加帧头帧尾\n> HTTP网络传输协议在传输层选择的是TCP/IP协议\n\n# HTTPS\n- HTTPS : Hyper Text Transfer Protocol over Secure Socket Layer,是以安全为目标的HTTP通道,简单讲是HTTP的安全版.即HTTP下加入SSL层,HTTPS的安全基础是SSL.\n- SSL : Secure Sockets Layer,表示安全套接层.\n- TLS : Transport Layer Security,是SSL的继任者,表示传输层安全.\n- SSL与TLS是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密.\n![](/images/network_http_and_https_diff.png)\n\n## HTTPS加密原理\n![](/images/network_encode_principle.png)\n\n## 加密科普（对称，非对称，散列 ）\nHTTPS一般使用的加密与HASH算法如下：\n非对称加密算法：RSA，DSA/DSS\n对称加密算法：AES，RC4，3DES\nHASH算法：MD5，SHA1，SHA256\n其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。\n\n## 小结（面试时如何回答)\n- HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。\n- HTTPS并不是一个单独的协议，是对工作在一个加密连接（SSL/TLS) 上的常规HTTP协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。\n- SSL/TLS协议加密会使传输速度会变慢，更耗资源，但是更安全\n\n相关文章：\n1.\thttps://www.cnblogs.com/Yfling/p/6670495.html\n2. http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\n","source":"_posts/ios-networkbase-http-and-https.md","raw":"---\ntitle: iOS - 网络基础 & Http & Https\ndate: 2018-04-29 17:29:30\ntags: [iOS,Network,Http,Https]\ncategories: iOS\n---\n# HTTP\nHTTP：Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型\n## Request\n### GET\n``` html\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\n\n（这里是请求数据）\n```\n- 第一部分：第一行是请求行（request line）\n- 第二部分：请求头（header），用来说明服务器要使用的附加信息\n- 第三部分：空行，请求头后面的空行是`必须`的\n- 第四部分：请求数据也叫主体，可以添加任意数据\n\n### POST\n``` html\nPOST / HTTP1.1\nHost: www.baidu.com\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 40\nConnection: Keep-Alive\n\nname=Professional%20Ajax&publisher=Wiley\n```\n- 第一部分：请求行，第一行是post请求，以及http1.1版本。\n- 第二部分：请求头部，第二行至第六行。\n- 第三部分：空行，第七行的空行。\n- 第四部分：请求数据，第八行。\n\n\n### GET和POST的区别\n- GET请求的数据会附在URL之后显示出来（数据放置在http协议头中）而POST把提交的数据放置在是HTTP包的包体中\n- 传输数据的大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但GET请求时特定浏览器和服务器对URL长度有限制（eg:IE限制2083个字节,2k+35）\n- 安全性：POST的安全性要比GET的安全性高（GET提交时，用户名密码会明文出现在URL上）\n\n\n## Response\n``` html\nHTTP/1.1 200 OK\nDate: Fri, 22 April 2018 06:07:21 GMT\nContent-Type: text/html; charset=UTF-8\n\n<html>\n\t  <head></head>\n\t  <body>\n\t\t\t<!--body goes here-->\n\t  </body>\n</html>\n```\n- 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n- 第二部分：消息报头，用来说明客户端要使用的一些附加信息\n- 第三部分：空行，消息报头后面的空行是必须的\n- 第四部分：响应正文，服务器返回给客户端的文本信息。\n\n## Http状态码\n- 1xx：指示信息--表示请求已接收，继续处理\n- 2xx：成功--表示请求已被成功接收、理解、接受\n- 3xx：重定向--要完成请求必须进行更进一步的操作\n- 4xx：客户端错误--请求有语法错误或请求无法实现\n- 5xx：服务器端错误--服务器未能实现合法的请求\n\n\n## 网络通信三要素\n### IP地址（主机名）\n- 网络中设备的标示\n- 本地回环地址：127.0.0.1 主机名：localhost\n\n### 端口号\n- 用于标示进程的逻辑地址，不同进程的标示\n- 有效端口：`0-65535`\n- 其中 `0-1024`由系统使用或者保留端口，开发中不要使用 1024 以下的端口\n- **注意** : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.处理HTTPS请求的端口号是443.\n\n### 传输协议\n- UDP(数据报文协议)\n\t- 只管发送，不确认对方是否接收到\n\t- 将数据源和目的封装成数据包中，不需要建立连接\n\t- 每个数据报的大小限制在64K之内\n\t- 因为无需连接，因此是不可靠协议\n\t- 不需要建立连接，速度快\n\t- 应用场景：多媒体教室／网络流媒体 / 视频实时共享\n\t- 当视频共享时,出现卡屏,就是因为UDP协议在传递数据时出现丢包.\n\n- TCP(传输控制协议)\n\t- 建立连接，形成传输数据的通道\n\t- 在连接中进行大数据传输（数据大小不受限制）\n\t- 通过三次握手完成连接，是可靠协议\n\t- 必须建立连接，效率会稍低\n\t- TCP协议的传输速度比UDP协议慢\n\n\n### 三次握手的描述\n- 图解：![](/images/network_three_time_hand.png)\n- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了\n\n\n### **注：**\n> 通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据\n\n\n## TCP/IP网络参考模型\n### 网络模型（理论）\n![](/images/network_theory_model.png)\n### 网络参考模型（现实）\n![](/images/network_real_model.png)\n### 通信过程\n![](/images/network_commute_progress.png)\n- 应用层 : APP\n- 传输层 : TCP,确定数据如何传输\n- 网络层 : 确定目标计算机的IP地址\n- 链路层 : 硬件,添加帧头帧尾\n> HTTP网络传输协议在传输层选择的是TCP/IP协议\n\n# HTTPS\n- HTTPS : Hyper Text Transfer Protocol over Secure Socket Layer,是以安全为目标的HTTP通道,简单讲是HTTP的安全版.即HTTP下加入SSL层,HTTPS的安全基础是SSL.\n- SSL : Secure Sockets Layer,表示安全套接层.\n- TLS : Transport Layer Security,是SSL的继任者,表示传输层安全.\n- SSL与TLS是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密.\n![](/images/network_http_and_https_diff.png)\n\n## HTTPS加密原理\n![](/images/network_encode_principle.png)\n\n## 加密科普（对称，非对称，散列 ）\nHTTPS一般使用的加密与HASH算法如下：\n非对称加密算法：RSA，DSA/DSS\n对称加密算法：AES，RC4，3DES\nHASH算法：MD5，SHA1，SHA256\n其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。\n\n## 小结（面试时如何回答)\n- HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。\n- HTTPS并不是一个单独的协议，是对工作在一个加密连接（SSL/TLS) 上的常规HTTP协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。\n- SSL/TLS协议加密会使传输速度会变慢，更耗资源，但是更安全\n\n相关文章：\n1.\thttps://www.cnblogs.com/Yfling/p/6670495.html\n2. http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\n","slug":"ios-networkbase-http-and-https","published":1,"updated":"2019-01-13T05:09:43.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2k0017l1fqrn8rbwkc","content":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP：Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型</p>\n<h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\"></span><br><span class=\"line\">（这里是请求数据）</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：第一行是请求行（request line）</li>\n<li>第二部分：请求头（header），用来说明服务器要使用的附加信息</li>\n<li>第三部分：空行，请求头后面的空行是<code>必须</code>的</li>\n<li>第四部分：请求数据也叫主体，可以添加任意数据</li>\n</ul>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST / HTTP1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">Content-Length: 40</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：请求行，第一行是post请求，以及http1.1版本。</li>\n<li>第二部分：请求头部，第二行至第六行。</li>\n<li>第三部分：空行，第七行的空行。</li>\n<li>第四部分：请求数据，第八行。</li>\n</ul>\n<h3 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h3><ul>\n<li>GET请求的数据会附在URL之后显示出来（数据放置在http协议头中）而POST把提交的数据放置在是HTTP包的包体中</li>\n<li>传输数据的大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但GET请求时特定浏览器和服务器对URL长度有限制（eg:IE限制2083个字节,2k+35）</li>\n<li>安全性：POST的安全性要比GET的安全性高（GET提交时，用户名密码会明文出现在URL上）</li>\n</ul>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Fri, 22 April 2018 06:07:21 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--body goes here--&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</li>\n<li>第二部分：消息报头，用来说明客户端要使用的一些附加信息</li>\n<li>第三部分：空行，消息报头后面的空行是必须的</li>\n<li>第四部分：响应正文，服务器返回给客户端的文本信息。</li>\n</ul>\n<h2 id=\"Http状态码\"><a href=\"#Http状态码\" class=\"headerlink\" title=\"Http状态码\"></a>Http状态码</h2><ul>\n<li>1xx：指示信息–表示请求已接收，继续处理</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求</li>\n</ul>\n<h2 id=\"网络通信三要素\"><a href=\"#网络通信三要素\" class=\"headerlink\" title=\"网络通信三要素\"></a>网络通信三要素</h2><h3 id=\"IP地址（主机名）\"><a href=\"#IP地址（主机名）\" class=\"headerlink\" title=\"IP地址（主机名）\"></a>IP地址（主机名）</h3><ul>\n<li>网络中设备的标示</li>\n<li>本地回环地址：127.0.0.1 主机名：localhost</li>\n</ul>\n<h3 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h3><ul>\n<li>用于标示进程的逻辑地址，不同进程的标示</li>\n<li>有效端口：<code>0-65535</code></li>\n<li>其中 <code>0-1024</code>由系统使用或者保留端口，开发中不要使用 1024 以下的端口</li>\n<li><strong>注意</strong> : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.处理HTTPS请求的端口号是443.</li>\n</ul>\n<h3 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h3><ul>\n<li><p>UDP(数据报文协议)</p>\n<ul>\n<li>只管发送，不确认对方是否接收到</li>\n<li>将数据源和目的封装成数据包中，不需要建立连接</li>\n<li>每个数据报的大小限制在64K之内</li>\n<li>因为无需连接，因此是不可靠协议</li>\n<li>不需要建立连接，速度快</li>\n<li>应用场景：多媒体教室／网络流媒体 / 视频实时共享</li>\n<li>当视频共享时,出现卡屏,就是因为UDP协议在传递数据时出现丢包.</li>\n</ul>\n</li>\n<li><p>TCP(传输控制协议)</p>\n<ul>\n<li>建立连接，形成传输数据的通道</li>\n<li>在连接中进行大数据传输（数据大小不受限制）</li>\n<li>通过三次握手完成连接，是可靠协议</li>\n<li>必须建立连接，效率会稍低</li>\n<li>TCP协议的传输速度比UDP协议慢</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三次握手的描述\"><a href=\"#三次握手的描述\" class=\"headerlink\" title=\"三次握手的描述\"></a>三次握手的描述</h3><ul>\n<li>图解：<img src=\"/images/network_three_time_hand.png\" alt=\"\"></li>\n<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>\n<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>\n<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了</li>\n</ul>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a><strong>注：</strong></h3><blockquote>\n<p>通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据</p>\n</blockquote>\n<h2 id=\"TCP-IP网络参考模型\"><a href=\"#TCP-IP网络参考模型\" class=\"headerlink\" title=\"TCP/IP网络参考模型\"></a>TCP/IP网络参考模型</h2><h3 id=\"网络模型（理论）\"><a href=\"#网络模型（理论）\" class=\"headerlink\" title=\"网络模型（理论）\"></a>网络模型（理论）</h3><p><img src=\"/images/network_theory_model.png\" alt=\"\"></p>\n<h3 id=\"网络参考模型（现实）\"><a href=\"#网络参考模型（现实）\" class=\"headerlink\" title=\"网络参考模型（现实）\"></a>网络参考模型（现实）</h3><p><img src=\"/images/network_real_model.png\" alt=\"\"></p>\n<h3 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h3><p><img src=\"/images/network_commute_progress.png\" alt=\"\"></p>\n<ul>\n<li>应用层 : APP</li>\n<li>传输层 : TCP,确定数据如何传输</li>\n<li>网络层 : 确定目标计算机的IP地址</li>\n<li>链路层 : 硬件,添加帧头帧尾<blockquote>\n<p>HTTP网络传输协议在传输层选择的是TCP/IP协议</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><ul>\n<li>HTTPS : Hyper Text Transfer Protocol over Secure Socket Layer,是以安全为目标的HTTP通道,简单讲是HTTP的安全版.即HTTP下加入SSL层,HTTPS的安全基础是SSL.</li>\n<li>SSL : Secure Sockets Layer,表示安全套接层.</li>\n<li>TLS : Transport Layer Security,是SSL的继任者,表示传输层安全.</li>\n<li>SSL与TLS是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密.<br><img src=\"/images/network_http_and_https_diff.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"HTTPS加密原理\"><a href=\"#HTTPS加密原理\" class=\"headerlink\" title=\"HTTPS加密原理\"></a>HTTPS加密原理</h2><p><img src=\"/images/network_encode_principle.png\" alt=\"\"></p>\n<h2 id=\"加密科普（对称，非对称，散列-）\"><a href=\"#加密科普（对称，非对称，散列-）\" class=\"headerlink\" title=\"加密科普（对称，非对称，散列 ）\"></a>加密科普（对称，非对称，散列 ）</h2><p>HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256<br>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>\n<h2 id=\"小结（面试时如何回答\"><a href=\"#小结（面试时如何回答\" class=\"headerlink\" title=\"小结（面试时如何回答)\"></a>小结（面试时如何回答)</h2><ul>\n<li>HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。</li>\n<li>HTTPS并不是一个单独的协议，是对工作在一个加密连接（SSL/TLS) 上的常规HTTP协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。</li>\n<li>SSL/TLS协议加密会使传输速度会变慢，更耗资源，但是更安全</li>\n</ul>\n<p>相关文章：</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/Yfling/p/6670495.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Yfling/p/6670495.html</a></li>\n<li><a href=\"http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"noopener\">http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP：Hyper Text Transfer Protocol（超文本传输协议）的缩写，HTTP是一个基于TCP/IP通信协议来传递数据，默认端口号为80,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型</p>\n<h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h2><h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\"></span><br><span class=\"line\">（这里是请求数据）</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：第一行是请求行（request line）</li>\n<li>第二部分：请求头（header），用来说明服务器要使用的附加信息</li>\n<li>第三部分：空行，请求头后面的空行是<code>必须</code>的</li>\n<li>第四部分：请求数据也叫主体，可以添加任意数据</li>\n</ul>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST / HTTP1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">Content-Length: 40</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\"></span><br><span class=\"line\">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：请求行，第一行是post请求，以及http1.1版本。</li>\n<li>第二部分：请求头部，第二行至第六行。</li>\n<li>第三部分：空行，第七行的空行。</li>\n<li>第四部分：请求数据，第八行。</li>\n</ul>\n<h3 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h3><ul>\n<li>GET请求的数据会附在URL之后显示出来（数据放置在http协议头中）而POST把提交的数据放置在是HTTP包的包体中</li>\n<li>传输数据的大小：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但GET请求时特定浏览器和服务器对URL长度有限制（eg:IE限制2083个字节,2k+35）</li>\n<li>安全性：POST的安全性要比GET的安全性高（GET提交时，用户名密码会明文出现在URL上）</li>\n</ul>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Date: Fri, 22 April 2018 06:07:21 GMT</span><br><span class=\"line\">Content-Type: text/html; charset=UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">&lt;!--body goes here--&gt;</span></span><br><span class=\"line\">\t  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</li>\n<li>第二部分：消息报头，用来说明客户端要使用的一些附加信息</li>\n<li>第三部分：空行，消息报头后面的空行是必须的</li>\n<li>第四部分：响应正文，服务器返回给客户端的文本信息。</li>\n</ul>\n<h2 id=\"Http状态码\"><a href=\"#Http状态码\" class=\"headerlink\" title=\"Http状态码\"></a>Http状态码</h2><ul>\n<li>1xx：指示信息–表示请求已接收，继续处理</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求</li>\n</ul>\n<h2 id=\"网络通信三要素\"><a href=\"#网络通信三要素\" class=\"headerlink\" title=\"网络通信三要素\"></a>网络通信三要素</h2><h3 id=\"IP地址（主机名）\"><a href=\"#IP地址（主机名）\" class=\"headerlink\" title=\"IP地址（主机名）\"></a>IP地址（主机名）</h3><ul>\n<li>网络中设备的标示</li>\n<li>本地回环地址：127.0.0.1 主机名：localhost</li>\n</ul>\n<h3 id=\"端口号\"><a href=\"#端口号\" class=\"headerlink\" title=\"端口号\"></a>端口号</h3><ul>\n<li>用于标示进程的逻辑地址，不同进程的标示</li>\n<li>有效端口：<code>0-65535</code></li>\n<li>其中 <code>0-1024</code>由系统使用或者保留端口，开发中不要使用 1024 以下的端口</li>\n<li><strong>注意</strong> : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.处理HTTPS请求的端口号是443.</li>\n</ul>\n<h3 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h3><ul>\n<li><p>UDP(数据报文协议)</p>\n<ul>\n<li>只管发送，不确认对方是否接收到</li>\n<li>将数据源和目的封装成数据包中，不需要建立连接</li>\n<li>每个数据报的大小限制在64K之内</li>\n<li>因为无需连接，因此是不可靠协议</li>\n<li>不需要建立连接，速度快</li>\n<li>应用场景：多媒体教室／网络流媒体 / 视频实时共享</li>\n<li>当视频共享时,出现卡屏,就是因为UDP协议在传递数据时出现丢包.</li>\n</ul>\n</li>\n<li><p>TCP(传输控制协议)</p>\n<ul>\n<li>建立连接，形成传输数据的通道</li>\n<li>在连接中进行大数据传输（数据大小不受限制）</li>\n<li>通过三次握手完成连接，是可靠协议</li>\n<li>必须建立连接，效率会稍低</li>\n<li>TCP协议的传输速度比UDP协议慢</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三次握手的描述\"><a href=\"#三次握手的描述\" class=\"headerlink\" title=\"三次握手的描述\"></a>三次握手的描述</h3><ul>\n<li>图解：<img src=\"/images/network_three_time_hand.png\" alt=\"\"></li>\n<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>\n<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>\n<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了</li>\n</ul>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a><strong>注：</strong></h3><blockquote>\n<p>通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据</p>\n</blockquote>\n<h2 id=\"TCP-IP网络参考模型\"><a href=\"#TCP-IP网络参考模型\" class=\"headerlink\" title=\"TCP/IP网络参考模型\"></a>TCP/IP网络参考模型</h2><h3 id=\"网络模型（理论）\"><a href=\"#网络模型（理论）\" class=\"headerlink\" title=\"网络模型（理论）\"></a>网络模型（理论）</h3><p><img src=\"/images/network_theory_model.png\" alt=\"\"></p>\n<h3 id=\"网络参考模型（现实）\"><a href=\"#网络参考模型（现实）\" class=\"headerlink\" title=\"网络参考模型（现实）\"></a>网络参考模型（现实）</h3><p><img src=\"/images/network_real_model.png\" alt=\"\"></p>\n<h3 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h3><p><img src=\"/images/network_commute_progress.png\" alt=\"\"></p>\n<ul>\n<li>应用层 : APP</li>\n<li>传输层 : TCP,确定数据如何传输</li>\n<li>网络层 : 确定目标计算机的IP地址</li>\n<li>链路层 : 硬件,添加帧头帧尾<blockquote>\n<p>HTTP网络传输协议在传输层选择的是TCP/IP协议</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><ul>\n<li>HTTPS : Hyper Text Transfer Protocol over Secure Socket Layer,是以安全为目标的HTTP通道,简单讲是HTTP的安全版.即HTTP下加入SSL层,HTTPS的安全基础是SSL.</li>\n<li>SSL : Secure Sockets Layer,表示安全套接层.</li>\n<li>TLS : Transport Layer Security,是SSL的继任者,表示传输层安全.</li>\n<li>SSL与TLS是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密.<br><img src=\"/images/network_http_and_https_diff.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"HTTPS加密原理\"><a href=\"#HTTPS加密原理\" class=\"headerlink\" title=\"HTTPS加密原理\"></a>HTTPS加密原理</h2><p><img src=\"/images/network_encode_principle.png\" alt=\"\"></p>\n<h2 id=\"加密科普（对称，非对称，散列-）\"><a href=\"#加密科普（对称，非对称，散列-）\" class=\"headerlink\" title=\"加密科普（对称，非对称，散列 ）\"></a>加密科普（对称，非对称，散列 ）</h2><p>HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256<br>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>\n<h2 id=\"小结（面试时如何回答\"><a href=\"#小结（面试时如何回答\" class=\"headerlink\" title=\"小结（面试时如何回答)\"></a>小结（面试时如何回答)</h2><ul>\n<li>HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。</li>\n<li>HTTPS并不是一个单独的协议，是对工作在一个加密连接（SSL/TLS) 上的常规HTTP协议。通过在TCP和HTTP之间加入TLS（Transport Layer Security）来加密。</li>\n<li>SSL/TLS协议加密会使传输速度会变慢，更耗资源，但是更安全</li>\n</ul>\n<p>相关文章：</p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/Yfling/p/6670495.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Yfling/p/6670495.html</a></li>\n<li><a href=\"http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\" target=\"_blank\" rel=\"noopener\">http://fullstack.blog/2017/03/12/%E4%B9%9D%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E6%82%89HTTPS/#BS-%E5%88%A9%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86</a></li>\n</ol>\n"},{"title":"iOS - 多线程之 NSThread","date":"2018-04-29T06:56:59.000Z","_content":"# 多线程基础（NSThread）\n\n## NSThread创建线程的三种方式\n``` Objc\n1. NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@\"alloc\"];\n2. [NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@\"detach\"];\n3. [self performSelectorInBackground:@selector(demo:) withObject:@\"perform\"];\n```\n## target和selector的关系\n- 执行哪个对象上的哪个方法.\n\n\n## 线程的状态-生命周期\n- `start` ：就绪状态，等待被CPU调用，当被调用的时候为运行状态\n- `sleep/加锁`：阻塞状态\n- `exit`：完全杀死（非正常死亡），**不要在主线程中调用**\n\n\n## 线程属性\n### `name` (线程名称)\n- 设置线程名称可以当线程执行的方法内部出现异常时，记录异常和当前线程\n\n\n### `stackSize`(栈区大小)\n- 默认情况下，无论是主线程还是子线程，栈区大小都是 512K\n- 栈区大小可以设置 \n  ``` Objc\n  [NSThread currentThread].stackSize = 1024 * 1024;\n  ```\n- 必须是 `4KB` 的倍数\n\n\n### `isMainThread` (是否主线程)\n\n### `threadPriority` (线程优先级)\n- 优先级，是一个浮点数，取值范围从`0~1.0`\n- `1.0`表示优先级最高\n- `0.0`表示优先级最低\n- 默认优先级是 `0.5`\n- **优先级高只是保证 CPU 调度的可能性会高**\n\n\n### `qualityOfService` (服务质量,iOS 8.0 推出)\n- `NSQualityOfServiceUserInteractive` - 用户交互，例如绘图或者处理用户事件\n- `NSQualityOfServiceUserInitiated` - 用户需要\n- `NSQualityOfServiceUtility` - 实用工具，用户不需要立即得到结果\n- `NSQualityOfServiceBackground` - 后台\n- `NSQualityOfServiceDefault` - 默认，介于用户需要和实用工具之间\n\n\n## 线程安全-资源共享（互斥锁小结）\n- `@synchronized`互斥锁，使用了线程同步技术\n- 同步锁/互斥锁：可以保证被锁定的代码，同一时间，只能有一个县城可以操作\n- `self`：锁对象，任何继承自NSObject的对象都可以是锁对象，因为内部都有一把锁，而且是默认开着的\n- 锁对象：一定要是全局的锁对象，要保证所有的线程都能访问，`self`是最方便使用的锁对象\n- 互斥锁锁定的范围应该尽量小，但是一定要锁住资源的`读写`部分\n- 加锁后程序的执行效率比不加锁的时候要低，因为线程要的等待解锁\n- 牺牲了性能保证了安全\n\n\n## 原子属性和非原子属性-以及自旋锁\n### `nonatomic` : 非原子属性\n- 线程不安全，不考虑多线程情况时使用此属性\n- 编译器少生成一些互斥加锁代码，可以提高效率。\n\n\n### `atomic` : 原子属性\n- 线程安全的,针对多线程设计的属性修饰符,是默认值.\n- 特点 : 单写多读\n- 单写多读 : 保证同一时间,只有一个线程能够执行setter方法,但是可以有多个线程执行getter方法.\n- atomic 属性的setter里面里面有一把锁,叫做自旋锁.\n- 原子属性的setter方法是线程安全的;但是,getter方法不是线程安全的.\n\n### `nonatomic`和`atomic`对比：\n- `nonatomic `: 非线程安全,适合内存小的移动设备.\n- `atomic` : 线程安全,需要消耗大量的资源.性能比非原子属性要差一点\n\n## 自旋锁和互斥锁的区别\n举个比较形象的例子就是：在火车上上厕所，自旋锁是比较着急那个人一直会敲门，问好了没有好了没有；而互斥锁就会等待厕所内的人出来之后自己在进去。显然自旋锁更为高效\n\n## 线程间通信（为什么能通信？）\n- `performSelectorInBackground`\n- `performSelectorOnMainThread`\n- 因为多线程共享地址空间和数据空间， 一个线程的数据可以直接提供给其他线程使用,叫做线程间通信\n","source":"_posts/ios-nsthread.md","raw":"---\ntitle: iOS - 多线程之 NSThread\ndate: 2018-04-29 14:56:59\ntags: [iOS,Objc,Thread,NSThread]\ncategories: [iOS,Objc]\n---\n# 多线程基础（NSThread）\n\n## NSThread创建线程的三种方式\n``` Objc\n1. NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@\"alloc\"];\n2. [NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@\"detach\"];\n3. [self performSelectorInBackground:@selector(demo:) withObject:@\"perform\"];\n```\n## target和selector的关系\n- 执行哪个对象上的哪个方法.\n\n\n## 线程的状态-生命周期\n- `start` ：就绪状态，等待被CPU调用，当被调用的时候为运行状态\n- `sleep/加锁`：阻塞状态\n- `exit`：完全杀死（非正常死亡），**不要在主线程中调用**\n\n\n## 线程属性\n### `name` (线程名称)\n- 设置线程名称可以当线程执行的方法内部出现异常时，记录异常和当前线程\n\n\n### `stackSize`(栈区大小)\n- 默认情况下，无论是主线程还是子线程，栈区大小都是 512K\n- 栈区大小可以设置 \n  ``` Objc\n  [NSThread currentThread].stackSize = 1024 * 1024;\n  ```\n- 必须是 `4KB` 的倍数\n\n\n### `isMainThread` (是否主线程)\n\n### `threadPriority` (线程优先级)\n- 优先级，是一个浮点数，取值范围从`0~1.0`\n- `1.0`表示优先级最高\n- `0.0`表示优先级最低\n- 默认优先级是 `0.5`\n- **优先级高只是保证 CPU 调度的可能性会高**\n\n\n### `qualityOfService` (服务质量,iOS 8.0 推出)\n- `NSQualityOfServiceUserInteractive` - 用户交互，例如绘图或者处理用户事件\n- `NSQualityOfServiceUserInitiated` - 用户需要\n- `NSQualityOfServiceUtility` - 实用工具，用户不需要立即得到结果\n- `NSQualityOfServiceBackground` - 后台\n- `NSQualityOfServiceDefault` - 默认，介于用户需要和实用工具之间\n\n\n## 线程安全-资源共享（互斥锁小结）\n- `@synchronized`互斥锁，使用了线程同步技术\n- 同步锁/互斥锁：可以保证被锁定的代码，同一时间，只能有一个县城可以操作\n- `self`：锁对象，任何继承自NSObject的对象都可以是锁对象，因为内部都有一把锁，而且是默认开着的\n- 锁对象：一定要是全局的锁对象，要保证所有的线程都能访问，`self`是最方便使用的锁对象\n- 互斥锁锁定的范围应该尽量小，但是一定要锁住资源的`读写`部分\n- 加锁后程序的执行效率比不加锁的时候要低，因为线程要的等待解锁\n- 牺牲了性能保证了安全\n\n\n## 原子属性和非原子属性-以及自旋锁\n### `nonatomic` : 非原子属性\n- 线程不安全，不考虑多线程情况时使用此属性\n- 编译器少生成一些互斥加锁代码，可以提高效率。\n\n\n### `atomic` : 原子属性\n- 线程安全的,针对多线程设计的属性修饰符,是默认值.\n- 特点 : 单写多读\n- 单写多读 : 保证同一时间,只有一个线程能够执行setter方法,但是可以有多个线程执行getter方法.\n- atomic 属性的setter里面里面有一把锁,叫做自旋锁.\n- 原子属性的setter方法是线程安全的;但是,getter方法不是线程安全的.\n\n### `nonatomic`和`atomic`对比：\n- `nonatomic `: 非线程安全,适合内存小的移动设备.\n- `atomic` : 线程安全,需要消耗大量的资源.性能比非原子属性要差一点\n\n## 自旋锁和互斥锁的区别\n举个比较形象的例子就是：在火车上上厕所，自旋锁是比较着急那个人一直会敲门，问好了没有好了没有；而互斥锁就会等待厕所内的人出来之后自己在进去。显然自旋锁更为高效\n\n## 线程间通信（为什么能通信？）\n- `performSelectorInBackground`\n- `performSelectorOnMainThread`\n- 因为多线程共享地址空间和数据空间， 一个线程的数据可以直接提供给其他线程使用,叫做线程间通信\n","slug":"ios-nsthread","published":1,"updated":"2019-01-13T05:09:49.676Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2l0019l1fqivjiw3cu","content":"<h1 id=\"多线程基础（NSThread）\"><a href=\"#多线程基础（NSThread）\" class=\"headerlink\" title=\"多线程基础（NSThread）\"></a>多线程基础（NSThread）</h1><h2 id=\"NSThread创建线程的三种方式\"><a href=\"#NSThread创建线程的三种方式\" class=\"headerlink\" title=\"NSThread创建线程的三种方式\"></a>NSThread创建线程的三种方式</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(demo:) object:<span class=\"string\">@\"alloc\"</span>];</span><br><span class=\"line\"><span class=\"number\">2.</span> [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(demo:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"detach\"</span>];</span><br><span class=\"line\"><span class=\"number\">3.</span> [<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(demo:) withObject:<span class=\"string\">@\"perform\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"target和selector的关系\"><a href=\"#target和selector的关系\" class=\"headerlink\" title=\"target和selector的关系\"></a>target和selector的关系</h2><ul>\n<li>执行哪个对象上的哪个方法.</li>\n</ul>\n<h2 id=\"线程的状态-生命周期\"><a href=\"#线程的状态-生命周期\" class=\"headerlink\" title=\"线程的状态-生命周期\"></a>线程的状态-生命周期</h2><ul>\n<li><code>start</code> ：就绪状态，等待被CPU调用，当被调用的时候为运行状态</li>\n<li><code>sleep/加锁</code>：阻塞状态</li>\n<li><code>exit</code>：完全杀死（非正常死亡），<strong>不要在主线程中调用</strong></li>\n</ul>\n<h2 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h2><h3 id=\"name-线程名称\"><a href=\"#name-线程名称\" class=\"headerlink\" title=\"name (线程名称)\"></a><code>name</code> (线程名称)</h3><ul>\n<li>设置线程名称可以当线程执行的方法内部出现异常时，记录异常和当前线程</li>\n</ul>\n<h3 id=\"stackSize-栈区大小\"><a href=\"#stackSize-栈区大小\" class=\"headerlink\" title=\"stackSize(栈区大小)\"></a><code>stackSize</code>(栈区大小)</h3><ul>\n<li>默认情况下，无论是主线程还是子线程，栈区大小都是 512K</li>\n<li><p>栈区大小可以设置 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSThread</span> currentThread].stackSize = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>必须是 <code>4KB</code> 的倍数</p>\n</li>\n</ul>\n<h3 id=\"isMainThread-是否主线程\"><a href=\"#isMainThread-是否主线程\" class=\"headerlink\" title=\"isMainThread (是否主线程)\"></a><code>isMainThread</code> (是否主线程)</h3><h3 id=\"threadPriority-线程优先级\"><a href=\"#threadPriority-线程优先级\" class=\"headerlink\" title=\"threadPriority (线程优先级)\"></a><code>threadPriority</code> (线程优先级)</h3><ul>\n<li>优先级，是一个浮点数，取值范围从<code>0~1.0</code></li>\n<li><code>1.0</code>表示优先级最高</li>\n<li><code>0.0</code>表示优先级最低</li>\n<li>默认优先级是 <code>0.5</code></li>\n<li><strong>优先级高只是保证 CPU 调度的可能性会高</strong></li>\n</ul>\n<h3 id=\"qualityOfService-服务质量-iOS-8-0-推出\"><a href=\"#qualityOfService-服务质量-iOS-8-0-推出\" class=\"headerlink\" title=\"qualityOfService (服务质量,iOS 8.0 推出)\"></a><code>qualityOfService</code> (服务质量,iOS 8.0 推出)</h3><ul>\n<li><code>NSQualityOfServiceUserInteractive</code> - 用户交互，例如绘图或者处理用户事件</li>\n<li><code>NSQualityOfServiceUserInitiated</code> - 用户需要</li>\n<li><code>NSQualityOfServiceUtility</code> - 实用工具，用户不需要立即得到结果</li>\n<li><code>NSQualityOfServiceBackground</code> - 后台</li>\n<li><code>NSQualityOfServiceDefault</code> - 默认，介于用户需要和实用工具之间</li>\n</ul>\n<h2 id=\"线程安全-资源共享（互斥锁小结）\"><a href=\"#线程安全-资源共享（互斥锁小结）\" class=\"headerlink\" title=\"线程安全-资源共享（互斥锁小结）\"></a>线程安全-资源共享（互斥锁小结）</h2><ul>\n<li><code>@synchronized</code>互斥锁，使用了线程同步技术</li>\n<li>同步锁/互斥锁：可以保证被锁定的代码，同一时间，只能有一个县城可以操作</li>\n<li><code>self</code>：锁对象，任何继承自NSObject的对象都可以是锁对象，因为内部都有一把锁，而且是默认开着的</li>\n<li>锁对象：一定要是全局的锁对象，要保证所有的线程都能访问，<code>self</code>是最方便使用的锁对象</li>\n<li>互斥锁锁定的范围应该尽量小，但是一定要锁住资源的<code>读写</code>部分</li>\n<li>加锁后程序的执行效率比不加锁的时候要低，因为线程要的等待解锁</li>\n<li>牺牲了性能保证了安全</li>\n</ul>\n<h2 id=\"原子属性和非原子属性-以及自旋锁\"><a href=\"#原子属性和非原子属性-以及自旋锁\" class=\"headerlink\" title=\"原子属性和非原子属性-以及自旋锁\"></a>原子属性和非原子属性-以及自旋锁</h2><h3 id=\"nonatomic-非原子属性\"><a href=\"#nonatomic-非原子属性\" class=\"headerlink\" title=\"nonatomic : 非原子属性\"></a><code>nonatomic</code> : 非原子属性</h3><ul>\n<li>线程不安全，不考虑多线程情况时使用此属性</li>\n<li>编译器少生成一些互斥加锁代码，可以提高效率。</li>\n</ul>\n<h3 id=\"atomic-原子属性\"><a href=\"#atomic-原子属性\" class=\"headerlink\" title=\"atomic : 原子属性\"></a><code>atomic</code> : 原子属性</h3><ul>\n<li>线程安全的,针对多线程设计的属性修饰符,是默认值.</li>\n<li>特点 : 单写多读</li>\n<li>单写多读 : 保证同一时间,只有一个线程能够执行setter方法,但是可以有多个线程执行getter方法.</li>\n<li>atomic 属性的setter里面里面有一把锁,叫做自旋锁.</li>\n<li>原子属性的setter方法是线程安全的;但是,getter方法不是线程安全的.</li>\n</ul>\n<h3 id=\"nonatomic和atomic对比：\"><a href=\"#nonatomic和atomic对比：\" class=\"headerlink\" title=\"nonatomic和atomic对比：\"></a><code>nonatomic</code>和<code>atomic</code>对比：</h3><ul>\n<li><code>nonatomic</code>: 非线程安全,适合内存小的移动设备.</li>\n<li><code>atomic</code> : 线程安全,需要消耗大量的资源.性能比非原子属性要差一点</li>\n</ul>\n<h2 id=\"自旋锁和互斥锁的区别\"><a href=\"#自旋锁和互斥锁的区别\" class=\"headerlink\" title=\"自旋锁和互斥锁的区别\"></a>自旋锁和互斥锁的区别</h2><p>举个比较形象的例子就是：在火车上上厕所，自旋锁是比较着急那个人一直会敲门，问好了没有好了没有；而互斥锁就会等待厕所内的人出来之后自己在进去。显然自旋锁更为高效</p>\n<h2 id=\"线程间通信（为什么能通信？）\"><a href=\"#线程间通信（为什么能通信？）\" class=\"headerlink\" title=\"线程间通信（为什么能通信？）\"></a>线程间通信（为什么能通信？）</h2><ul>\n<li><code>performSelectorInBackground</code></li>\n<li><code>performSelectorOnMainThread</code></li>\n<li>因为多线程共享地址空间和数据空间， 一个线程的数据可以直接提供给其他线程使用,叫做线程间通信</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"多线程基础（NSThread）\"><a href=\"#多线程基础（NSThread）\" class=\"headerlink\" title=\"多线程基础（NSThread）\"></a>多线程基础（NSThread）</h1><h2 id=\"NSThread创建线程的三种方式\"><a href=\"#NSThread创建线程的三种方式\" class=\"headerlink\" title=\"NSThread创建线程的三种方式\"></a>NSThread创建线程的三种方式</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(demo:) object:<span class=\"string\">@\"alloc\"</span>];</span><br><span class=\"line\"><span class=\"number\">2.</span> [<span class=\"built_in\">NSThread</span> detachNewThreadSelector:<span class=\"keyword\">@selector</span>(demo:) toTarget:<span class=\"keyword\">self</span> withObject:<span class=\"string\">@\"detach\"</span>];</span><br><span class=\"line\"><span class=\"number\">3.</span> [<span class=\"keyword\">self</span> performSelectorInBackground:<span class=\"keyword\">@selector</span>(demo:) withObject:<span class=\"string\">@\"perform\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"target和selector的关系\"><a href=\"#target和selector的关系\" class=\"headerlink\" title=\"target和selector的关系\"></a>target和selector的关系</h2><ul>\n<li>执行哪个对象上的哪个方法.</li>\n</ul>\n<h2 id=\"线程的状态-生命周期\"><a href=\"#线程的状态-生命周期\" class=\"headerlink\" title=\"线程的状态-生命周期\"></a>线程的状态-生命周期</h2><ul>\n<li><code>start</code> ：就绪状态，等待被CPU调用，当被调用的时候为运行状态</li>\n<li><code>sleep/加锁</code>：阻塞状态</li>\n<li><code>exit</code>：完全杀死（非正常死亡），<strong>不要在主线程中调用</strong></li>\n</ul>\n<h2 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h2><h3 id=\"name-线程名称\"><a href=\"#name-线程名称\" class=\"headerlink\" title=\"name (线程名称)\"></a><code>name</code> (线程名称)</h3><ul>\n<li>设置线程名称可以当线程执行的方法内部出现异常时，记录异常和当前线程</li>\n</ul>\n<h3 id=\"stackSize-栈区大小\"><a href=\"#stackSize-栈区大小\" class=\"headerlink\" title=\"stackSize(栈区大小)\"></a><code>stackSize</code>(栈区大小)</h3><ul>\n<li>默认情况下，无论是主线程还是子线程，栈区大小都是 512K</li>\n<li><p>栈区大小可以设置 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSThread</span> currentThread].stackSize = <span class=\"number\">1024</span> * <span class=\"number\">1024</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>必须是 <code>4KB</code> 的倍数</p>\n</li>\n</ul>\n<h3 id=\"isMainThread-是否主线程\"><a href=\"#isMainThread-是否主线程\" class=\"headerlink\" title=\"isMainThread (是否主线程)\"></a><code>isMainThread</code> (是否主线程)</h3><h3 id=\"threadPriority-线程优先级\"><a href=\"#threadPriority-线程优先级\" class=\"headerlink\" title=\"threadPriority (线程优先级)\"></a><code>threadPriority</code> (线程优先级)</h3><ul>\n<li>优先级，是一个浮点数，取值范围从<code>0~1.0</code></li>\n<li><code>1.0</code>表示优先级最高</li>\n<li><code>0.0</code>表示优先级最低</li>\n<li>默认优先级是 <code>0.5</code></li>\n<li><strong>优先级高只是保证 CPU 调度的可能性会高</strong></li>\n</ul>\n<h3 id=\"qualityOfService-服务质量-iOS-8-0-推出\"><a href=\"#qualityOfService-服务质量-iOS-8-0-推出\" class=\"headerlink\" title=\"qualityOfService (服务质量,iOS 8.0 推出)\"></a><code>qualityOfService</code> (服务质量,iOS 8.0 推出)</h3><ul>\n<li><code>NSQualityOfServiceUserInteractive</code> - 用户交互，例如绘图或者处理用户事件</li>\n<li><code>NSQualityOfServiceUserInitiated</code> - 用户需要</li>\n<li><code>NSQualityOfServiceUtility</code> - 实用工具，用户不需要立即得到结果</li>\n<li><code>NSQualityOfServiceBackground</code> - 后台</li>\n<li><code>NSQualityOfServiceDefault</code> - 默认，介于用户需要和实用工具之间</li>\n</ul>\n<h2 id=\"线程安全-资源共享（互斥锁小结）\"><a href=\"#线程安全-资源共享（互斥锁小结）\" class=\"headerlink\" title=\"线程安全-资源共享（互斥锁小结）\"></a>线程安全-资源共享（互斥锁小结）</h2><ul>\n<li><code>@synchronized</code>互斥锁，使用了线程同步技术</li>\n<li>同步锁/互斥锁：可以保证被锁定的代码，同一时间，只能有一个县城可以操作</li>\n<li><code>self</code>：锁对象，任何继承自NSObject的对象都可以是锁对象，因为内部都有一把锁，而且是默认开着的</li>\n<li>锁对象：一定要是全局的锁对象，要保证所有的线程都能访问，<code>self</code>是最方便使用的锁对象</li>\n<li>互斥锁锁定的范围应该尽量小，但是一定要锁住资源的<code>读写</code>部分</li>\n<li>加锁后程序的执行效率比不加锁的时候要低，因为线程要的等待解锁</li>\n<li>牺牲了性能保证了安全</li>\n</ul>\n<h2 id=\"原子属性和非原子属性-以及自旋锁\"><a href=\"#原子属性和非原子属性-以及自旋锁\" class=\"headerlink\" title=\"原子属性和非原子属性-以及自旋锁\"></a>原子属性和非原子属性-以及自旋锁</h2><h3 id=\"nonatomic-非原子属性\"><a href=\"#nonatomic-非原子属性\" class=\"headerlink\" title=\"nonatomic : 非原子属性\"></a><code>nonatomic</code> : 非原子属性</h3><ul>\n<li>线程不安全，不考虑多线程情况时使用此属性</li>\n<li>编译器少生成一些互斥加锁代码，可以提高效率。</li>\n</ul>\n<h3 id=\"atomic-原子属性\"><a href=\"#atomic-原子属性\" class=\"headerlink\" title=\"atomic : 原子属性\"></a><code>atomic</code> : 原子属性</h3><ul>\n<li>线程安全的,针对多线程设计的属性修饰符,是默认值.</li>\n<li>特点 : 单写多读</li>\n<li>单写多读 : 保证同一时间,只有一个线程能够执行setter方法,但是可以有多个线程执行getter方法.</li>\n<li>atomic 属性的setter里面里面有一把锁,叫做自旋锁.</li>\n<li>原子属性的setter方法是线程安全的;但是,getter方法不是线程安全的.</li>\n</ul>\n<h3 id=\"nonatomic和atomic对比：\"><a href=\"#nonatomic和atomic对比：\" class=\"headerlink\" title=\"nonatomic和atomic对比：\"></a><code>nonatomic</code>和<code>atomic</code>对比：</h3><ul>\n<li><code>nonatomic</code>: 非线程安全,适合内存小的移动设备.</li>\n<li><code>atomic</code> : 线程安全,需要消耗大量的资源.性能比非原子属性要差一点</li>\n</ul>\n<h2 id=\"自旋锁和互斥锁的区别\"><a href=\"#自旋锁和互斥锁的区别\" class=\"headerlink\" title=\"自旋锁和互斥锁的区别\"></a>自旋锁和互斥锁的区别</h2><p>举个比较形象的例子就是：在火车上上厕所，自旋锁是比较着急那个人一直会敲门，问好了没有好了没有；而互斥锁就会等待厕所内的人出来之后自己在进去。显然自旋锁更为高效</p>\n<h2 id=\"线程间通信（为什么能通信？）\"><a href=\"#线程间通信（为什么能通信？）\" class=\"headerlink\" title=\"线程间通信（为什么能通信？）\"></a>线程间通信（为什么能通信？）</h2><ul>\n<li><code>performSelectorInBackground</code></li>\n<li><code>performSelectorOnMainThread</code></li>\n<li>因为多线程共享地址空间和数据空间， 一个线程的数据可以直接提供给其他线程使用,叫做线程间通信</li>\n</ul>\n"},{"title":"iOS - NSURLRequest & NSURLResponse","date":"2018-05-02T14:30:51.000Z","_content":"![](/images/network_http_commute.png)\n## NSURLRequest\n### 创建请求对象 (缓存策略和超时时长都是默认的)\n``` Objc\nNSURLRequest * request = [NSURLRequest requestWithURL:url];\n```\n  ### 创建请求对象的同时指定缓存策略和超时时长\n``` Objc\nNSURLRequest * request = [NSURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15];\n```\n### 缓存策略\n| 枚举 | 数值 | 说明 |\n| -- | -- | -- |\n| `NSURLRequestUseProtocolCachePolicy` | 0 | 默认的缓存策略 |\n| `NSURLRequestReloadIgnoringLocalCacheData` | 1 | <ul><li>忽略本地缓存数据，始终加载服务器的数据</li><li>对数据的及时性要求高的应用</li></ul> |\n| `NSURLRequestReturnCacheDataElseLoad` | 2 | 如果有缓存，就返回缓存，否则加载最新数据 |\n| `NSURLRequestReturnCacheDataDontLoad` | 3 | 只加载缓存数据,不去服务器上获取(离线地图) |\n\n### 超时时长\n- 默认网络时长是 `60 s`\n> `SDWebImage` 的默认超时时长是 `15` 秒\n> `AFN` 的默认超时时长是 `60` 秒\n\n\n### NSMutableURLRequest（可变请求）\n``` Objc\n// 可变的请求对象才能设置额外的信息\nNSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15];\n// 设置请求头 : 告诉服务器,我的设备是iphone\n[requestM setValue:@\"iphone AppleWebKit\" forHTTPHeaderField:@\"User-Agent\"];\n```\n## NSURLResponse\n### 响应头\n| 响应属性 | 说明 |\n| -- | -- |\n| `URL` | 服务器反馈的 URL，有的时候，服务器会重定向新的 URL |\n| `MIMEType` | <ul><li>服务器告诉客户端，返回的二进制数据的类型（纯文本，视频，语音，超文本等）</li><li>`ContentType`</li><li>根据 MIMEType 客户端就知道使用什么软件处理返回的二进制数据</li></ul> |\n| `statusCode` | 状态码<br /><ul><li>1XX消息</li><li>2XX 成功</li><li>3XX 更多选择</li><li>4XX 客户端错误</li><li>5XX 服务器错误</li></ul> |\n| `expectedContentLength` | 数据长度，下载文件总长度 |\n| `suggestedFilename` | 获取服务器的文件的名称 |\n| `allHeaderFields ` | 返回数据的头部信息，key－value格式 |\n| `textEncodingName ` | 编码的名称 |\n\n### 响应体 data\n- `data` 服务器返回的二进制数据，程序员最关心的内容\n- 拿到响应体之后,无法直接使用,需要进行反序列化,转换成OC对象.\n\n\n## GET请求 URL中有中文时如何处理？\n``` Objc\nNSString * URLString = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];\n```\n> 注意：GET请求时,问号`?`后面的查询字符串里面不能有中文或者空格.如果有就需要使用%转义,不然URL会为nil. POST请求时,请求体里面可以有中文.\n> URLQueryAllowedCharacterSet : 百分号转义查询字符串\n\n## URL转字符串的方法\n``` objc\n[filePath.path / filePath.absoluteString]\n```\n","source":"_posts/ios-nsurlrequest-and-nsurlresponse.md","raw":"---\ntitle: iOS - NSURLRequest & NSURLResponse\ndate: 2018-05-02 22:30:51\ntags: [iOS,Objc,Network,NSURLRequest,NSURLResponse]\ncategories: [iOS,Objc]\n---\n![](/images/network_http_commute.png)\n## NSURLRequest\n### 创建请求对象 (缓存策略和超时时长都是默认的)\n``` Objc\nNSURLRequest * request = [NSURLRequest requestWithURL:url];\n```\n  ### 创建请求对象的同时指定缓存策略和超时时长\n``` Objc\nNSURLRequest * request = [NSURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15];\n```\n### 缓存策略\n| 枚举 | 数值 | 说明 |\n| -- | -- | -- |\n| `NSURLRequestUseProtocolCachePolicy` | 0 | 默认的缓存策略 |\n| `NSURLRequestReloadIgnoringLocalCacheData` | 1 | <ul><li>忽略本地缓存数据，始终加载服务器的数据</li><li>对数据的及时性要求高的应用</li></ul> |\n| `NSURLRequestReturnCacheDataElseLoad` | 2 | 如果有缓存，就返回缓存，否则加载最新数据 |\n| `NSURLRequestReturnCacheDataDontLoad` | 3 | 只加载缓存数据,不去服务器上获取(离线地图) |\n\n### 超时时长\n- 默认网络时长是 `60 s`\n> `SDWebImage` 的默认超时时长是 `15` 秒\n> `AFN` 的默认超时时长是 `60` 秒\n\n\n### NSMutableURLRequest（可变请求）\n``` Objc\n// 可变的请求对象才能设置额外的信息\nNSMutableURLRequest *requestM = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:15];\n// 设置请求头 : 告诉服务器,我的设备是iphone\n[requestM setValue:@\"iphone AppleWebKit\" forHTTPHeaderField:@\"User-Agent\"];\n```\n## NSURLResponse\n### 响应头\n| 响应属性 | 说明 |\n| -- | -- |\n| `URL` | 服务器反馈的 URL，有的时候，服务器会重定向新的 URL |\n| `MIMEType` | <ul><li>服务器告诉客户端，返回的二进制数据的类型（纯文本，视频，语音，超文本等）</li><li>`ContentType`</li><li>根据 MIMEType 客户端就知道使用什么软件处理返回的二进制数据</li></ul> |\n| `statusCode` | 状态码<br /><ul><li>1XX消息</li><li>2XX 成功</li><li>3XX 更多选择</li><li>4XX 客户端错误</li><li>5XX 服务器错误</li></ul> |\n| `expectedContentLength` | 数据长度，下载文件总长度 |\n| `suggestedFilename` | 获取服务器的文件的名称 |\n| `allHeaderFields ` | 返回数据的头部信息，key－value格式 |\n| `textEncodingName ` | 编码的名称 |\n\n### 响应体 data\n- `data` 服务器返回的二进制数据，程序员最关心的内容\n- 拿到响应体之后,无法直接使用,需要进行反序列化,转换成OC对象.\n\n\n## GET请求 URL中有中文时如何处理？\n``` Objc\nNSString * URLString = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];\n```\n> 注意：GET请求时,问号`?`后面的查询字符串里面不能有中文或者空格.如果有就需要使用%转义,不然URL会为nil. POST请求时,请求体里面可以有中文.\n> URLQueryAllowedCharacterSet : 百分号转义查询字符串\n\n## URL转字符串的方法\n``` objc\n[filePath.path / filePath.absoluteString]\n```\n","slug":"ios-nsurlrequest-and-nsurlresponse","published":1,"updated":"2019-01-13T05:09:55.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2n001cl1fqdp6o729v","content":"<p><img src=\"/images/network_http_commute.png\" alt=\"\"></p>\n<h2 id=\"NSURLRequest\"><a href=\"#NSURLRequest\" class=\"headerlink\" title=\"NSURLRequest\"></a>NSURLRequest</h2><h3 id=\"创建请求对象-缓存策略和超时时长都是默认的\"><a href=\"#创建请求对象-缓存策略和超时时长都是默认的\" class=\"headerlink\" title=\"创建请求对象 (缓存策略和超时时长都是默认的)\"></a>创建请求对象 (缓存策略和超时时长都是默认的)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:url];</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建请求对象的同时指定缓存策略和超时时长\"><a href=\"#创建请求对象的同时指定缓存策略和超时时长\" class=\"headerlink\" title=\"创建请求对象的同时指定缓存策略和超时时长\"></a>创建请求对象的同时指定缓存策略和超时时长</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:url cachePolicy:<span class=\"number\">0</span> timeoutInterval:<span class=\"number\">15</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><table>\n<thead>\n<tr>\n<th>枚举</th>\n<th>数值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>NSURLRequestUseProtocolCachePolicy</code></td>\n<td>0</td>\n<td>默认的缓存策略</td>\n</tr>\n<tr>\n<td><code>NSURLRequestReloadIgnoringLocalCacheData</code></td>\n<td>1</td>\n<td><ul><li>忽略本地缓存数据，始终加载服务器的数据</li><li>对数据的及时性要求高的应用</li></ul></td>\n</tr>\n<tr>\n<td><code>NSURLRequestReturnCacheDataElseLoad</code></td>\n<td>2</td>\n<td>如果有缓存，就返回缓存，否则加载最新数据</td>\n</tr>\n<tr>\n<td><code>NSURLRequestReturnCacheDataDontLoad</code></td>\n<td>3</td>\n<td>只加载缓存数据,不去服务器上获取(离线地图)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"超时时长\"><a href=\"#超时时长\" class=\"headerlink\" title=\"超时时长\"></a>超时时长</h3><ul>\n<li>默认网络时长是 <code>60 s</code><blockquote>\n<p><code>SDWebImage</code> 的默认超时时长是 <code>15</code> 秒<br><code>AFN</code> 的默认超时时长是 <code>60</code> 秒</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"NSMutableURLRequest（可变请求）\"><a href=\"#NSMutableURLRequest（可变请求）\" class=\"headerlink\" title=\"NSMutableURLRequest（可变请求）\"></a>NSMutableURLRequest（可变请求）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可变的请求对象才能设置额外的信息</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *requestM = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url cachePolicy:<span class=\"number\">0</span> timeoutInterval:<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"comment\">// 设置请求头 : 告诉服务器,我的设备是iphone</span></span><br><span class=\"line\">[requestM setValue:<span class=\"string\">@\"iphone AppleWebKit\"</span> forHTTPHeaderField:<span class=\"string\">@\"User-Agent\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NSURLResponse\"><a href=\"#NSURLResponse\" class=\"headerlink\" title=\"NSURLResponse\"></a>NSURLResponse</h2><h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><table>\n<thead>\n<tr>\n<th>响应属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>URL</code></td>\n<td>服务器反馈的 URL，有的时候，服务器会重定向新的 URL</td>\n</tr>\n<tr>\n<td><code>MIMEType</code></td>\n<td><ul><li>服务器告诉客户端，返回的二进制数据的类型（纯文本，视频，语音，超文本等）</li><li><code>ContentType</code></li><li>根据 MIMEType 客户端就知道使用什么软件处理返回的二进制数据</li></ul></td>\n</tr>\n<tr>\n<td><code>statusCode</code></td>\n<td>状态码<br><ul><li>1XX消息</li><li>2XX 成功</li><li>3XX 更多选择</li><li>4XX 客户端错误</li><li>5XX 服务器错误</li></ul></td>\n</tr>\n<tr>\n<td><code>expectedContentLength</code></td>\n<td>数据长度，下载文件总长度</td>\n</tr>\n<tr>\n<td><code>suggestedFilename</code></td>\n<td>获取服务器的文件的名称</td>\n</tr>\n<tr>\n<td><code>allHeaderFields</code></td>\n<td>返回数据的头部信息，key－value格式</td>\n</tr>\n<tr>\n<td><code>textEncodingName</code></td>\n<td>编码的名称</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应体-data\"><a href=\"#响应体-data\" class=\"headerlink\" title=\"响应体 data\"></a>响应体 data</h3><ul>\n<li><code>data</code> 服务器返回的二进制数据，程序员最关心的内容</li>\n<li>拿到响应体之后,无法直接使用,需要进行反序列化,转换成OC对象.</li>\n</ul>\n<h2 id=\"GET请求-URL中有中文时如何处理？\"><a href=\"#GET请求-URL中有中文时如何处理？\" class=\"headerlink\" title=\"GET请求 URL中有中文时如何处理？\"></a>GET请求 URL中有中文时如何处理？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * URLString = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[<span class=\"built_in\">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：GET请求时,问号<code>?</code>后面的查询字符串里面不能有中文或者空格.如果有就需要使用%转义,不然URL会为nil. POST请求时,请求体里面可以有中文.<br>URLQueryAllowedCharacterSet : 百分号转义查询字符串</p>\n</blockquote>\n<h2 id=\"URL转字符串的方法\"><a href=\"#URL转字符串的方法\" class=\"headerlink\" title=\"URL转字符串的方法\"></a>URL转字符串的方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[filePath.path / filePath.absoluteString]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/network_http_commute.png\" alt=\"\"></p>\n<h2 id=\"NSURLRequest\"><a href=\"#NSURLRequest\" class=\"headerlink\" title=\"NSURLRequest\"></a>NSURLRequest</h2><h3 id=\"创建请求对象-缓存策略和超时时长都是默认的\"><a href=\"#创建请求对象-缓存策略和超时时长都是默认的\" class=\"headerlink\" title=\"创建请求对象 (缓存策略和超时时长都是默认的)\"></a>创建请求对象 (缓存策略和超时时长都是默认的)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:url];</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建请求对象的同时指定缓存策略和超时时长\"><a href=\"#创建请求对象的同时指定缓存策略和超时时长\" class=\"headerlink\" title=\"创建请求对象的同时指定缓存策略和超时时长\"></a>创建请求对象的同时指定缓存策略和超时时长</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:url cachePolicy:<span class=\"number\">0</span> timeoutInterval:<span class=\"number\">15</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"缓存策略\"><a href=\"#缓存策略\" class=\"headerlink\" title=\"缓存策略\"></a>缓存策略</h3><table>\n<thead>\n<tr>\n<th>枚举</th>\n<th>数值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>NSURLRequestUseProtocolCachePolicy</code></td>\n<td>0</td>\n<td>默认的缓存策略</td>\n</tr>\n<tr>\n<td><code>NSURLRequestReloadIgnoringLocalCacheData</code></td>\n<td>1</td>\n<td><ul><li>忽略本地缓存数据，始终加载服务器的数据</li><li>对数据的及时性要求高的应用</li></ul></td>\n</tr>\n<tr>\n<td><code>NSURLRequestReturnCacheDataElseLoad</code></td>\n<td>2</td>\n<td>如果有缓存，就返回缓存，否则加载最新数据</td>\n</tr>\n<tr>\n<td><code>NSURLRequestReturnCacheDataDontLoad</code></td>\n<td>3</td>\n<td>只加载缓存数据,不去服务器上获取(离线地图)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"超时时长\"><a href=\"#超时时长\" class=\"headerlink\" title=\"超时时长\"></a>超时时长</h3><ul>\n<li>默认网络时长是 <code>60 s</code><blockquote>\n<p><code>SDWebImage</code> 的默认超时时长是 <code>15</code> 秒<br><code>AFN</code> 的默认超时时长是 <code>60</code> 秒</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"NSMutableURLRequest（可变请求）\"><a href=\"#NSMutableURLRequest（可变请求）\" class=\"headerlink\" title=\"NSMutableURLRequest（可变请求）\"></a>NSMutableURLRequest（可变请求）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可变的请求对象才能设置额外的信息</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *requestM = [<span class=\"built_in\">NSMutableURLRequest</span> requestWithURL:url cachePolicy:<span class=\"number\">0</span> timeoutInterval:<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"comment\">// 设置请求头 : 告诉服务器,我的设备是iphone</span></span><br><span class=\"line\">[requestM setValue:<span class=\"string\">@\"iphone AppleWebKit\"</span> forHTTPHeaderField:<span class=\"string\">@\"User-Agent\"</span>];</span><br></pre></td></tr></table></figure>\n<h2 id=\"NSURLResponse\"><a href=\"#NSURLResponse\" class=\"headerlink\" title=\"NSURLResponse\"></a>NSURLResponse</h2><h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><table>\n<thead>\n<tr>\n<th>响应属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>URL</code></td>\n<td>服务器反馈的 URL，有的时候，服务器会重定向新的 URL</td>\n</tr>\n<tr>\n<td><code>MIMEType</code></td>\n<td><ul><li>服务器告诉客户端，返回的二进制数据的类型（纯文本，视频，语音，超文本等）</li><li><code>ContentType</code></li><li>根据 MIMEType 客户端就知道使用什么软件处理返回的二进制数据</li></ul></td>\n</tr>\n<tr>\n<td><code>statusCode</code></td>\n<td>状态码<br><ul><li>1XX消息</li><li>2XX 成功</li><li>3XX 更多选择</li><li>4XX 客户端错误</li><li>5XX 服务器错误</li></ul></td>\n</tr>\n<tr>\n<td><code>expectedContentLength</code></td>\n<td>数据长度，下载文件总长度</td>\n</tr>\n<tr>\n<td><code>suggestedFilename</code></td>\n<td>获取服务器的文件的名称</td>\n</tr>\n<tr>\n<td><code>allHeaderFields</code></td>\n<td>返回数据的头部信息，key－value格式</td>\n</tr>\n<tr>\n<td><code>textEncodingName</code></td>\n<td>编码的名称</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应体-data\"><a href=\"#响应体-data\" class=\"headerlink\" title=\"响应体 data\"></a>响应体 data</h3><ul>\n<li><code>data</code> 服务器返回的二进制数据，程序员最关心的内容</li>\n<li>拿到响应体之后,无法直接使用,需要进行反序列化,转换成OC对象.</li>\n</ul>\n<h2 id=\"GET请求-URL中有中文时如何处理？\"><a href=\"#GET请求-URL中有中文时如何处理？\" class=\"headerlink\" title=\"GET请求 URL中有中文时如何处理？\"></a>GET请求 URL中有中文时如何处理？</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> * URLString = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[<span class=\"built_in\">NSCharacterSet</span> URLQueryAllowedCharacterSet]];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：GET请求时,问号<code>?</code>后面的查询字符串里面不能有中文或者空格.如果有就需要使用%转义,不然URL会为nil. POST请求时,请求体里面可以有中文.<br>URLQueryAllowedCharacterSet : 百分号转义查询字符串</p>\n</blockquote>\n<h2 id=\"URL转字符串的方法\"><a href=\"#URL转字符串的方法\" class=\"headerlink\" title=\"URL转字符串的方法\"></a>URL转字符串的方法</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[filePath.path / filePath.absoluteString]</span><br></pre></td></tr></table></figure>\n"},{"title":"iOS - RunLoop & AutoreleasePool","date":"2018-05-24T01:30:51.000Z","_content":"# RunLoop\n>A NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. A NSRunLoop object also processes NSTimer events.\n\n## RunLoop 的概念\n运行循环也叫消息循环，作用是循环的捕捉消息，然后执行消息对应的操作；并且保证应用程序不会退出。\nOSX/iOS 系统中，提供了两个这样的对象：`NSRunLoop` 和 `CFRunLoopRef`。\n`CFRunLoopRef` 是在 `CoreFoundation` 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。\n`NSRunLoop` 是基于 `CFRunLoopRef` 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。\n\n## Input source 与 Timer source\n`Input source` 与 `Timer source`这两个都是 RunLoop 事件的来源\n\n### Input Source 可以分为三类\n- Port-Based Sources：系统底层的 Port 事件源，例如`CFSocketRef`，但在应用层中几乎用不到。\n- Custom Input Sources：用户手动创建的事件源，例如手势，触摸，键入。\n- Cocoa Perform Selector Sources：Cocoa 提供的`performSelector`系列方法也是一种事件源。\n\n### Timer Source\n即是指定时器事件（`NSTimer`）。\n\n## RunLoop 与线程\n线程和 RunLoop  之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时候并没有 RunLoop，如果你不主动获取，那么它一直不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。所以只能在一个线程的内部获取 RunLoop(主线程除外)。\n\n下图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。\n![RunLoop](/images/objc_runloop.jpg)\n\n### Warning\n>The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.\n\n## RunLoop Observer\nRunLoop 通过监听 Source 来决定有没有任务要做；除此之外，我们还可以用 RunLoop Observer 来监控 RunLoop 本身的状态。\n\nRunLoop Observer 可以监听以下 RunLoop 事件：\n- The entrance to the run loop.\n- When the run loop is about to process a timer.\n- When the run loop is about to process an input source.\n- When the run loop is about to go to sleep.\n- When the run loop has woken up, but before it has processed the event that woke it up.\n- The exit from the run loop.\n\n\n## RunLoop Mode\n在监听与被监听中，RunLoop 要处理的事情非常复杂；为了让 RunLoop专注于处理特定事件而引入了 RunLoop Mode 概念\n![RunLoop Mode](/images/objc_runloop_mode.png)\n如果所示，RunLoop Mode 实际上是 Source、Timer、Observer 的集合，不同的 Mode 把不同组的 Source、Timer、Observer 隔绝开来；而 RunLoop 在某个时刻下只能跑在某一个 Mode 下，处理这一个 Mode 当中的Source、Timer 和 Observer。\n\n苹果文档中提到的 Mode 有五个，分别是：\n- `NSDefaultRunLoopMode`\n- `NSConnectionReplyMode`\n- `NSModalPanelRunLoopMode`\n- `NSTrackingRunLoopMode`\n- `NSRunLoopCommonModes`\n\niOS 中公开暴露出来的只有 `NSDefaultRunLoopMode` 、`UITrackingRunLoopMode` 和 `NSRunLoopCommonModes。` 而`NSRunLoopCommonModes` 实际上是一个 Mode 的集合，默认包括 `NSDefaultRunLoopMode` 和 `NSTrackingRunLoopMode`。\n\n## RunLoop 的使用\nRunLoop 和线程是绑定在一起的；每个线程（包括主线程）都有一个对应的 RunLoop 对象。\n\n### 获取 RunLoop\n我们不能自己创建 RunLoop 对象，只能获取到系统提供的 RunLoop 对象。\n```objc\n[NSRunLoop currentRunLoop];\n[NSRunLoop mainRunLoop];\n```\n### 在主线程和子线程中区别\nRunLoop 在主线程和子线程中的 **区别** 在于：主线程的 RunLoop 会在应用启动的时候默认开启；其他线程（子线程）的 RunLoop 默认并不会启动，需要手动开启。\n```objc\n//手动启动RunLoop，无法控制结束\n[[NSRunLoop currentRunLoop] run];\n//手动启动RunLoop，指定结束时间\n[[NSRunLoop currentRunLoop] runUntilDate:[[NSDate date] dateByAddingTimeInterval:5]];\n```\n\n## RunLoop 与 NSTimer\n### timerWithTimeInterval:\n```Objc\n //需要手动加入 RunLoop 并设置 Mode\n NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];\n //立即调用一次\n [timer fire];\n //手动加入 RunLoop\n [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n```\n### scheduledTimerWithTimeInterval:\n```Objc\n //默认加入 RunLoop 并设置 Mode 为 NSDefaultRunLoopMode\n NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];\n //立即调用一次\n [timer fire];\n```\n### 坑\n日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer，一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 `NSDefaultRunLoopMode` 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 `UITrackingRunLoopMode`；而这个时候， Timer 就不会运行。\n\n**解决方案：**\n设置RunLoop Mode，例如 NSTimer，我们指定它运行于 `NSRunLoopCommonModes` ，这是一个Mode的集合。这样无论当前 RunLoop 运行哪个 Mode ，事件都能得到执行。\n\n例如在 AFNetworking 中，就有相关的代码，如下：\n```Objc\n- (void)startActivationDelayTimer {\n    self.activationDelayTimer = [NSTimer\n                                 timerWithTimeInterval:self.activationDelay target:self selector:@selector(activationDelayTimerFired) userInfo:nil repeats:NO];\n    [[NSRunLoop mainRunLoop] addTimer:self.activationDelayTimer forMode:NSRunLoopCommonModes];\n}\n```\n这里就是添加了一个计时器，由于指定了 `NSRunLoopCommonModes`，所以不管 RunLoop 处于什么状态，都会执行这个计时器任务。\n\n# Runloop 和 Autoreleasepool 的关系图解\n![关系图解](/images/objc_autoreleasepool.png)\n\n# Autorelease Pool\nAutorelase Pool 提供了一种可以允许你向一个对象延迟发送 `release` 消息的机制；当你想放弃对象的所有权，同时又不希望这个对象被立即释放掉（例如在一个方法中返回一个对象时），Autoreleasepool就可以发挥作用。所谓的延迟发送`release`消息是指，当我们把一个对象标记为autorelease时:\n```Objc\nNSString* str = [[[NSString alloc] initWithString:@\"hello\"] autorelease];\n```\n这个对象的`retainCount+1`，但不会发生 `release`；当这个变量所处的`autoreleasepool`被 `倾倒(drain)` 操作时，所有标记了autorelease的对象的 `retainCount-1`；即`release`消息的发送被延迟到`autoreleasepool`释放的时候了。\n在 ARC 环境下，苹果引入了 `@autoreleasepool` 语法，不在需要手动调用`autorelease` 和 `drain` 等方法。\n>提示 : 此处讨论的自动释放池不是手动创建的，是跟运行循环相关的，并非 `main.m` 中的 `@autoreleasepool`\n\n## Autorelease Pool 的用处\n在 ARC 下我们并不需要手动调用`autorelease`有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确的管理好内存；因为 Cocoa Touch 的 RunLoop 中，每个 RunLoop Circle中系统都加入了 Autorelease Pool 的创建和释放。\n\n当我们需要创建和销毁大量对象时，使用手动创建的`autoreleasepool`可以有效的避免内存峰值的出现；因为如果不手动创建的话，外层系统创建的 Pool 会在整个 Runloop Circle 结束之后才执行 drain 操作，手动创建的话会在 block 结束之后就就执行 drain 操作。详情请见[苹果官方文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI)\n\n一个普遍被使用的例子如下：\n```Objc\nfor (int i = 0; i < 10000000; i++)\n{\n    @autoreleasepool\n    {\n        NSString* string = @\"abc\";\n        NSArray* array = [string componentsSeparatedByString:string];\n    }\n}\n```\n在上面的例子中如果不使用`autoreleasepool`，需要在循环结束之后释放1000000个字符串；如果使用的话会在每次循环结束的时候都进行release操作。\n\n## Autorelease Pool 进行 Drain 的时机\n如上所述，系统在 RunLoop 中创建的 autoreleasepool 会在 RunLoop 的一个 Event 结束时进行 Drain 操作；而我们手动创建的 autoreleasepool 会在 block 执行完后进行 Drain  操作。\n\n但需要注意的是：\n- 当 block 以异常(exception)结束时，pool 不会进行 drain 操作\n- Pool 的 drain 操作会把所有标记为 autorelease 的对象`retainCount-1`，但并不意味着这个对象一定会被释放掉；我们可以在 autoreleasepool 中手动 retain 该对象，以延长它的声明周期(在MRC中）\n\n## main.m 中的 autoreleasepool 的解释\n在 iOS 程序的 main.m 文件中有类似这样的语句：\n```Objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n在面试中问到有关autorealeasepool的知识时，也多半会问一下，这里的 pool 有什么作用？能不能去掉之类...\n根据[苹果官方文档](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)：`UIApplicationMain`函数是整个 app 的入口，用来创建 application对象（单例）和application delegate；尽管这个函数有返回值，但是却永远不会返回，当按下Home键时，app 只是切换到了后台状态。\n\n由文档知道，UIApplication会自己创建一个 main runloop，大致可以得到下面的结论：\n1. `main.m`中 UIApplicationMain 永远不会返回，只有在系统kill掉整个app时候，系统会把应用占用的全部内存释放出来。\n2. 因为 UIApplicationMain 永远不会返回，所以这里的 autoreleasepool 就永远不会进入到drain阶段。\n3. 假设真的有变量进入了main.m 中的这个 Pool（而没有被更内层的 Pool 捕获），那么这些内存实际上就是被泄露的，这个autoreleasepool 等于把这种泄露情况进行了隐藏。\n4. UIApplication自己会创建 main runlooop，在 Cocoa 的 RunLoop 中实际上也是包含 autoreleasepool 的，因此main.m中的autoreleasepool可以认为是 **没有必要** 的。\n\n另外，在基于 AppKit 框架的 Mac OS 开发中，`main.m`中就是不存在 autoreleasepool 的，这也进一步印证了上面的结论。不过因为不知道更底层的代码，加上苹果文档中不建议修改main.m 文件，所以我们也没有理由把它删掉。但是，删掉之后也不会影响 App 运行，用 `Instruments` 也没有发现内存泄露。\n\n## autoreleasepool的创建与销毁\n- 创建 : 运行循环检测到事件并启动后，就会创建自动释放池\n- 销毁 : 一次完整的运行循环结束之前，会被销毁\n\n以上，autoreleasepool的创建与销毁都和运行循环（RunLoop）息息相关。\n\n# 参考资料\nhttps://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html\nhttps://blog.ibireme.com/2015/05/18/RunLoop/\n","source":"_posts/ios-runloop-and-autoreleasepool.md","raw":"---\ntitle: iOS - RunLoop & AutoreleasePool\ndate: 2018-05-24 09:30:51\ntags: [iOS,Objc,RunLoop,AutoreleasePool]\ncategories: [iOS,Objc]\n---\n# RunLoop\n>A NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. A NSRunLoop object also processes NSTimer events.\n\n## RunLoop 的概念\n运行循环也叫消息循环，作用是循环的捕捉消息，然后执行消息对应的操作；并且保证应用程序不会退出。\nOSX/iOS 系统中，提供了两个这样的对象：`NSRunLoop` 和 `CFRunLoopRef`。\n`CFRunLoopRef` 是在 `CoreFoundation` 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。\n`NSRunLoop` 是基于 `CFRunLoopRef` 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。\n\n## Input source 与 Timer source\n`Input source` 与 `Timer source`这两个都是 RunLoop 事件的来源\n\n### Input Source 可以分为三类\n- Port-Based Sources：系统底层的 Port 事件源，例如`CFSocketRef`，但在应用层中几乎用不到。\n- Custom Input Sources：用户手动创建的事件源，例如手势，触摸，键入。\n- Cocoa Perform Selector Sources：Cocoa 提供的`performSelector`系列方法也是一种事件源。\n\n### Timer Source\n即是指定时器事件（`NSTimer`）。\n\n## RunLoop 与线程\n线程和 RunLoop  之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时候并没有 RunLoop，如果你不主动获取，那么它一直不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。所以只能在一个线程的内部获取 RunLoop(主线程除外)。\n\n下图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。\n![RunLoop](/images/objc_runloop.jpg)\n\n### Warning\n>The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.\n\n## RunLoop Observer\nRunLoop 通过监听 Source 来决定有没有任务要做；除此之外，我们还可以用 RunLoop Observer 来监控 RunLoop 本身的状态。\n\nRunLoop Observer 可以监听以下 RunLoop 事件：\n- The entrance to the run loop.\n- When the run loop is about to process a timer.\n- When the run loop is about to process an input source.\n- When the run loop is about to go to sleep.\n- When the run loop has woken up, but before it has processed the event that woke it up.\n- The exit from the run loop.\n\n\n## RunLoop Mode\n在监听与被监听中，RunLoop 要处理的事情非常复杂；为了让 RunLoop专注于处理特定事件而引入了 RunLoop Mode 概念\n![RunLoop Mode](/images/objc_runloop_mode.png)\n如果所示，RunLoop Mode 实际上是 Source、Timer、Observer 的集合，不同的 Mode 把不同组的 Source、Timer、Observer 隔绝开来；而 RunLoop 在某个时刻下只能跑在某一个 Mode 下，处理这一个 Mode 当中的Source、Timer 和 Observer。\n\n苹果文档中提到的 Mode 有五个，分别是：\n- `NSDefaultRunLoopMode`\n- `NSConnectionReplyMode`\n- `NSModalPanelRunLoopMode`\n- `NSTrackingRunLoopMode`\n- `NSRunLoopCommonModes`\n\niOS 中公开暴露出来的只有 `NSDefaultRunLoopMode` 、`UITrackingRunLoopMode` 和 `NSRunLoopCommonModes。` 而`NSRunLoopCommonModes` 实际上是一个 Mode 的集合，默认包括 `NSDefaultRunLoopMode` 和 `NSTrackingRunLoopMode`。\n\n## RunLoop 的使用\nRunLoop 和线程是绑定在一起的；每个线程（包括主线程）都有一个对应的 RunLoop 对象。\n\n### 获取 RunLoop\n我们不能自己创建 RunLoop 对象，只能获取到系统提供的 RunLoop 对象。\n```objc\n[NSRunLoop currentRunLoop];\n[NSRunLoop mainRunLoop];\n```\n### 在主线程和子线程中区别\nRunLoop 在主线程和子线程中的 **区别** 在于：主线程的 RunLoop 会在应用启动的时候默认开启；其他线程（子线程）的 RunLoop 默认并不会启动，需要手动开启。\n```objc\n//手动启动RunLoop，无法控制结束\n[[NSRunLoop currentRunLoop] run];\n//手动启动RunLoop，指定结束时间\n[[NSRunLoop currentRunLoop] runUntilDate:[[NSDate date] dateByAddingTimeInterval:5]];\n```\n\n## RunLoop 与 NSTimer\n### timerWithTimeInterval:\n```Objc\n //需要手动加入 RunLoop 并设置 Mode\n NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];\n //立即调用一次\n [timer fire];\n //手动加入 RunLoop\n [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n```\n### scheduledTimerWithTimeInterval:\n```Objc\n //默认加入 RunLoop 并设置 Mode 为 NSDefaultRunLoopMode\n NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timeFire) userInfo:nil repeats:YES];\n //立即调用一次\n [timer fire];\n```\n### 坑\n日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer，一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 `NSDefaultRunLoopMode` 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 `UITrackingRunLoopMode`；而这个时候， Timer 就不会运行。\n\n**解决方案：**\n设置RunLoop Mode，例如 NSTimer，我们指定它运行于 `NSRunLoopCommonModes` ，这是一个Mode的集合。这样无论当前 RunLoop 运行哪个 Mode ，事件都能得到执行。\n\n例如在 AFNetworking 中，就有相关的代码，如下：\n```Objc\n- (void)startActivationDelayTimer {\n    self.activationDelayTimer = [NSTimer\n                                 timerWithTimeInterval:self.activationDelay target:self selector:@selector(activationDelayTimerFired) userInfo:nil repeats:NO];\n    [[NSRunLoop mainRunLoop] addTimer:self.activationDelayTimer forMode:NSRunLoopCommonModes];\n}\n```\n这里就是添加了一个计时器，由于指定了 `NSRunLoopCommonModes`，所以不管 RunLoop 处于什么状态，都会执行这个计时器任务。\n\n# Runloop 和 Autoreleasepool 的关系图解\n![关系图解](/images/objc_autoreleasepool.png)\n\n# Autorelease Pool\nAutorelase Pool 提供了一种可以允许你向一个对象延迟发送 `release` 消息的机制；当你想放弃对象的所有权，同时又不希望这个对象被立即释放掉（例如在一个方法中返回一个对象时），Autoreleasepool就可以发挥作用。所谓的延迟发送`release`消息是指，当我们把一个对象标记为autorelease时:\n```Objc\nNSString* str = [[[NSString alloc] initWithString:@\"hello\"] autorelease];\n```\n这个对象的`retainCount+1`，但不会发生 `release`；当这个变量所处的`autoreleasepool`被 `倾倒(drain)` 操作时，所有标记了autorelease的对象的 `retainCount-1`；即`release`消息的发送被延迟到`autoreleasepool`释放的时候了。\n在 ARC 环境下，苹果引入了 `@autoreleasepool` 语法，不在需要手动调用`autorelease` 和 `drain` 等方法。\n>提示 : 此处讨论的自动释放池不是手动创建的，是跟运行循环相关的，并非 `main.m` 中的 `@autoreleasepool`\n\n## Autorelease Pool 的用处\n在 ARC 下我们并不需要手动调用`autorelease`有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确的管理好内存；因为 Cocoa Touch 的 RunLoop 中，每个 RunLoop Circle中系统都加入了 Autorelease Pool 的创建和释放。\n\n当我们需要创建和销毁大量对象时，使用手动创建的`autoreleasepool`可以有效的避免内存峰值的出现；因为如果不手动创建的话，外层系统创建的 Pool 会在整个 Runloop Circle 结束之后才执行 drain 操作，手动创建的话会在 block 结束之后就就执行 drain 操作。详情请见[苹果官方文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI)\n\n一个普遍被使用的例子如下：\n```Objc\nfor (int i = 0; i < 10000000; i++)\n{\n    @autoreleasepool\n    {\n        NSString* string = @\"abc\";\n        NSArray* array = [string componentsSeparatedByString:string];\n    }\n}\n```\n在上面的例子中如果不使用`autoreleasepool`，需要在循环结束之后释放1000000个字符串；如果使用的话会在每次循环结束的时候都进行release操作。\n\n## Autorelease Pool 进行 Drain 的时机\n如上所述，系统在 RunLoop 中创建的 autoreleasepool 会在 RunLoop 的一个 Event 结束时进行 Drain 操作；而我们手动创建的 autoreleasepool 会在 block 执行完后进行 Drain  操作。\n\n但需要注意的是：\n- 当 block 以异常(exception)结束时，pool 不会进行 drain 操作\n- Pool 的 drain 操作会把所有标记为 autorelease 的对象`retainCount-1`，但并不意味着这个对象一定会被释放掉；我们可以在 autoreleasepool 中手动 retain 该对象，以延长它的声明周期(在MRC中）\n\n## main.m 中的 autoreleasepool 的解释\n在 iOS 程序的 main.m 文件中有类似这样的语句：\n```Objc\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n在面试中问到有关autorealeasepool的知识时，也多半会问一下，这里的 pool 有什么作用？能不能去掉之类...\n根据[苹果官方文档](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)：`UIApplicationMain`函数是整个 app 的入口，用来创建 application对象（单例）和application delegate；尽管这个函数有返回值，但是却永远不会返回，当按下Home键时，app 只是切换到了后台状态。\n\n由文档知道，UIApplication会自己创建一个 main runloop，大致可以得到下面的结论：\n1. `main.m`中 UIApplicationMain 永远不会返回，只有在系统kill掉整个app时候，系统会把应用占用的全部内存释放出来。\n2. 因为 UIApplicationMain 永远不会返回，所以这里的 autoreleasepool 就永远不会进入到drain阶段。\n3. 假设真的有变量进入了main.m 中的这个 Pool（而没有被更内层的 Pool 捕获），那么这些内存实际上就是被泄露的，这个autoreleasepool 等于把这种泄露情况进行了隐藏。\n4. UIApplication自己会创建 main runlooop，在 Cocoa 的 RunLoop 中实际上也是包含 autoreleasepool 的，因此main.m中的autoreleasepool可以认为是 **没有必要** 的。\n\n另外，在基于 AppKit 框架的 Mac OS 开发中，`main.m`中就是不存在 autoreleasepool 的，这也进一步印证了上面的结论。不过因为不知道更底层的代码，加上苹果文档中不建议修改main.m 文件，所以我们也没有理由把它删掉。但是，删掉之后也不会影响 App 运行，用 `Instruments` 也没有发现内存泄露。\n\n## autoreleasepool的创建与销毁\n- 创建 : 运行循环检测到事件并启动后，就会创建自动释放池\n- 销毁 : 一次完整的运行循环结束之前，会被销毁\n\n以上，autoreleasepool的创建与销毁都和运行循环（RunLoop）息息相关。\n\n# 参考资料\nhttps://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html\nhttps://blog.ibireme.com/2015/05/18/RunLoop/\n","slug":"ios-runloop-and-autoreleasepool","published":1,"updated":"2019-01-13T05:10:00.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2o001el1fq4emiehud","content":"<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><blockquote>\n<p>A NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. A NSRunLoop object also processes NSTimer events.</p>\n</blockquote>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>运行循环也叫消息循环，作用是循环的捕捉消息，然后执行消息对应的操作；并且保证应用程序不会退出。<br>OSX/iOS 系统中，提供了两个这样的对象：<code>NSRunLoop</code> 和 <code>CFRunLoopRef</code>。<br><code>CFRunLoopRef</code> 是在 <code>CoreFoundation</code> 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br><code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>\n<h2 id=\"Input-source-与-Timer-source\"><a href=\"#Input-source-与-Timer-source\" class=\"headerlink\" title=\"Input source 与 Timer source\"></a>Input source 与 Timer source</h2><p><code>Input source</code> 与 <code>Timer source</code>这两个都是 RunLoop 事件的来源</p>\n<h3 id=\"Input-Source-可以分为三类\"><a href=\"#Input-Source-可以分为三类\" class=\"headerlink\" title=\"Input Source 可以分为三类\"></a>Input Source 可以分为三类</h3><ul>\n<li>Port-Based Sources：系统底层的 Port 事件源，例如<code>CFSocketRef</code>，但在应用层中几乎用不到。</li>\n<li>Custom Input Sources：用户手动创建的事件源，例如手势，触摸，键入。</li>\n<li>Cocoa Perform Selector Sources：Cocoa 提供的<code>performSelector</code>系列方法也是一种事件源。</li>\n</ul>\n<h3 id=\"Timer-Source\"><a href=\"#Timer-Source\" class=\"headerlink\" title=\"Timer Source\"></a>Timer Source</h3><p>即是指定时器事件（<code>NSTimer</code>）。</p>\n<h2 id=\"RunLoop-与线程\"><a href=\"#RunLoop-与线程\" class=\"headerlink\" title=\"RunLoop 与线程\"></a>RunLoop 与线程</h2><p>线程和 RunLoop  之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时候并没有 RunLoop，如果你不主动获取，那么它一直不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。所以只能在一个线程的内部获取 RunLoop(主线程除外)。</p>\n<p>下图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。<br><img src=\"/images/objc_runloop.jpg\" alt=\"RunLoop\"></p>\n<h3 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h3><blockquote>\n<p>The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.</p>\n</blockquote>\n<h2 id=\"RunLoop-Observer\"><a href=\"#RunLoop-Observer\" class=\"headerlink\" title=\"RunLoop Observer\"></a>RunLoop Observer</h2><p>RunLoop 通过监听 Source 来决定有没有任务要做；除此之外，我们还可以用 RunLoop Observer 来监控 RunLoop 本身的状态。</p>\n<p>RunLoop Observer 可以监听以下 RunLoop 事件：</p>\n<ul>\n<li>The entrance to the run loop.</li>\n<li>When the run loop is about to process a timer.</li>\n<li>When the run loop is about to process an input source.</li>\n<li>When the run loop is about to go to sleep.</li>\n<li>When the run loop has woken up, but before it has processed the event that woke it up.</li>\n<li>The exit from the run loop.</li>\n</ul>\n<h2 id=\"RunLoop-Mode\"><a href=\"#RunLoop-Mode\" class=\"headerlink\" title=\"RunLoop Mode\"></a>RunLoop Mode</h2><p>在监听与被监听中，RunLoop 要处理的事情非常复杂；为了让 RunLoop专注于处理特定事件而引入了 RunLoop Mode 概念<br><img src=\"/images/objc_runloop_mode.png\" alt=\"RunLoop Mode\"><br>如果所示，RunLoop Mode 实际上是 Source、Timer、Observer 的集合，不同的 Mode 把不同组的 Source、Timer、Observer 隔绝开来；而 RunLoop 在某个时刻下只能跑在某一个 Mode 下，处理这一个 Mode 当中的Source、Timer 和 Observer。</p>\n<p>苹果文档中提到的 Mode 有五个，分别是：</p>\n<ul>\n<li><code>NSDefaultRunLoopMode</code></li>\n<li><code>NSConnectionReplyMode</code></li>\n<li><code>NSModalPanelRunLoopMode</code></li>\n<li><code>NSTrackingRunLoopMode</code></li>\n<li><code>NSRunLoopCommonModes</code></li>\n</ul>\n<p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 、<code>UITrackingRunLoopMode</code> 和 <code>NSRunLoopCommonModes。</code> 而<code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSTrackingRunLoopMode</code>。</p>\n<h2 id=\"RunLoop-的使用\"><a href=\"#RunLoop-的使用\" class=\"headerlink\" title=\"RunLoop 的使用\"></a>RunLoop 的使用</h2><p>RunLoop 和线程是绑定在一起的；每个线程（包括主线程）都有一个对应的 RunLoop 对象。</p>\n<h3 id=\"获取-RunLoop\"><a href=\"#获取-RunLoop\" class=\"headerlink\" title=\"获取 RunLoop\"></a>获取 RunLoop</h3><p>我们不能自己创建 RunLoop 对象，只能获取到系统提供的 RunLoop 对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> mainRunLoop];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在主线程和子线程中区别\"><a href=\"#在主线程和子线程中区别\" class=\"headerlink\" title=\"在主线程和子线程中区别\"></a>在主线程和子线程中区别</h3><p>RunLoop 在主线程和子线程中的 <strong>区别</strong> 在于：主线程的 RunLoop 会在应用启动的时候默认开启；其他线程（子线程）的 RunLoop 默认并不会启动，需要手动开启。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手动启动RunLoop，无法控制结束</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\"><span class=\"comment\">//手动启动RunLoop，指定结束时间</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runUntilDate:[[<span class=\"built_in\">NSDate</span> date] dateByAddingTimeInterval:<span class=\"number\">5</span>]];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RunLoop-与-NSTimer\"><a href=\"#RunLoop-与-NSTimer\" class=\"headerlink\" title=\"RunLoop 与 NSTimer\"></a>RunLoop 与 NSTimer</h2><h3 id=\"timerWithTimeInterval\"><a href=\"#timerWithTimeInterval\" class=\"headerlink\" title=\"timerWithTimeInterval:\"></a>timerWithTimeInterval:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//需要手动加入 RunLoop 并设置 Mode</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">//立即调用一次</span></span><br><span class=\"line\">[timer fire];</span><br><span class=\"line\"><span class=\"comment\">//手动加入 RunLoop</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"scheduledTimerWithTimeInterval\"><a href=\"#scheduledTimerWithTimeInterval\" class=\"headerlink\" title=\"scheduledTimerWithTimeInterval:\"></a>scheduledTimerWithTimeInterval:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认加入 RunLoop 并设置 Mode 为 NSDefaultRunLoopMode</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">//立即调用一次</span></span><br><span class=\"line\">[timer fire];</span><br></pre></td></tr></table></figure>\n<h3 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h3><p>日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer，一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 <code>NSDefaultRunLoopMode</code> 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 <code>UITrackingRunLoopMode</code>；而这个时候， Timer 就不会运行。</p>\n<p><strong>解决方案：</strong><br>设置RunLoop Mode，例如 NSTimer，我们指定它运行于 <code>NSRunLoopCommonModes</code> ，这是一个Mode的集合。这样无论当前 RunLoop 运行哪个 Mode ，事件都能得到执行。</p>\n<p>例如在 AFNetworking 中，就有相关的代码，如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startActivationDelayTimer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.activationDelayTimer = [<span class=\"built_in\">NSTimer</span></span><br><span class=\"line\">                                 timerWithTimeInterval:<span class=\"keyword\">self</span>.activationDelay target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(activationDelayTimerFired) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:<span class=\"keyword\">self</span>.activationDelayTimer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里就是添加了一个计时器，由于指定了 <code>NSRunLoopCommonModes</code>，所以不管 RunLoop 处于什么状态，都会执行这个计时器任务。</p>\n<h1 id=\"Runloop-和-Autoreleasepool-的关系图解\"><a href=\"#Runloop-和-Autoreleasepool-的关系图解\" class=\"headerlink\" title=\"Runloop 和 Autoreleasepool 的关系图解\"></a>Runloop 和 Autoreleasepool 的关系图解</h1><p><img src=\"/images/objc_autoreleasepool.png\" alt=\"关系图解\"></p>\n<h1 id=\"Autorelease-Pool\"><a href=\"#Autorelease-Pool\" class=\"headerlink\" title=\"Autorelease Pool\"></a>Autorelease Pool</h1><p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送 <code>release</code> 消息的机制；当你想放弃对象的所有权，同时又不希望这个对象被立即释放掉（例如在一个方法中返回一个对象时），Autoreleasepool就可以发挥作用。所谓的延迟发送<code>release</code>消息是指，当我们把一个对象标记为autorelease时:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span>* str = [[[<span class=\"built_in\">NSString</span> alloc] initWithString:<span class=\"string\">@\"hello\"</span>] autorelease];</span><br></pre></td></tr></table></figure></p>\n<p>这个对象的<code>retainCount+1</code>，但不会发生 <code>release</code>；当这个变量所处的<code>autoreleasepool</code>被 <code>倾倒(drain)</code> 操作时，所有标记了autorelease的对象的 <code>retainCount-1</code>；即<code>release</code>消息的发送被延迟到<code>autoreleasepool</code>释放的时候了。<br>在 ARC 环境下，苹果引入了 <code>@autoreleasepool</code> 语法，不在需要手动调用<code>autorelease</code> 和 <code>drain</code> 等方法。</p>\n<blockquote>\n<p>提示 : 此处讨论的自动释放池不是手动创建的，是跟运行循环相关的，并非 <code>main.m</code> 中的 <code>@autoreleasepool</code></p>\n</blockquote>\n<h2 id=\"Autorelease-Pool-的用处\"><a href=\"#Autorelease-Pool-的用处\" class=\"headerlink\" title=\"Autorelease Pool 的用处\"></a>Autorelease Pool 的用处</h2><p>在 ARC 下我们并不需要手动调用<code>autorelease</code>有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确的管理好内存；因为 Cocoa Touch 的 RunLoop 中，每个 RunLoop Circle中系统都加入了 Autorelease Pool 的创建和释放。</p>\n<p>当我们需要创建和销毁大量对象时，使用手动创建的<code>autoreleasepool</code>可以有效的避免内存峰值的出现；因为如果不手动创建的话，外层系统创建的 Pool 会在整个 Runloop Circle 结束之后才执行 drain 操作，手动创建的话会在 block 结束之后就就执行 drain 操作。详情请见<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n<p>一个普遍被使用的例子如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000000</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span>* string = <span class=\"string\">@\"abc\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span>* array = [string componentsSeparatedByString:string];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的例子中如果不使用<code>autoreleasepool</code>，需要在循环结束之后释放1000000个字符串；如果使用的话会在每次循环结束的时候都进行release操作。</p>\n<h2 id=\"Autorelease-Pool-进行-Drain-的时机\"><a href=\"#Autorelease-Pool-进行-Drain-的时机\" class=\"headerlink\" title=\"Autorelease Pool 进行 Drain 的时机\"></a>Autorelease Pool 进行 Drain 的时机</h2><p>如上所述，系统在 RunLoop 中创建的 autoreleasepool 会在 RunLoop 的一个 Event 结束时进行 Drain 操作；而我们手动创建的 autoreleasepool 会在 block 执行完后进行 Drain  操作。</p>\n<p>但需要注意的是：</p>\n<ul>\n<li>当 block 以异常(exception)结束时，pool 不会进行 drain 操作</li>\n<li>Pool 的 drain 操作会把所有标记为 autorelease 的对象<code>retainCount-1</code>，但并不意味着这个对象一定会被释放掉；我们可以在 autoreleasepool 中手动 retain 该对象，以延长它的声明周期(在MRC中）</li>\n</ul>\n<h2 id=\"main-m-中的-autoreleasepool-的解释\"><a href=\"#main-m-中的-autoreleasepool-的解释\" class=\"headerlink\" title=\"main.m 中的 autoreleasepool 的解释\"></a>main.m 中的 autoreleasepool 的解释</h2><p>在 iOS 程序的 main.m 文件中有类似这样的语句：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([AppDelegate <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在面试中问到有关autorealeasepool的知识时，也多半会问一下，这里的 pool 有什么作用？能不能去掉之类…<br>根据<a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a>：<code>UIApplicationMain</code>函数是整个 app 的入口，用来创建 application对象（单例）和application delegate；尽管这个函数有返回值，但是却永远不会返回，当按下Home键时，app 只是切换到了后台状态。</p>\n<p>由文档知道，UIApplication会自己创建一个 main runloop，大致可以得到下面的结论：</p>\n<ol>\n<li><code>main.m</code>中 UIApplicationMain 永远不会返回，只有在系统kill掉整个app时候，系统会把应用占用的全部内存释放出来。</li>\n<li>因为 UIApplicationMain 永远不会返回，所以这里的 autoreleasepool 就永远不会进入到drain阶段。</li>\n<li>假设真的有变量进入了main.m 中的这个 Pool（而没有被更内层的 Pool 捕获），那么这些内存实际上就是被泄露的，这个autoreleasepool 等于把这种泄露情况进行了隐藏。</li>\n<li>UIApplication自己会创建 main runlooop，在 Cocoa 的 RunLoop 中实际上也是包含 autoreleasepool 的，因此main.m中的autoreleasepool可以认为是 <strong>没有必要</strong> 的。</li>\n</ol>\n<p>另外，在基于 AppKit 框架的 Mac OS 开发中，<code>main.m</code>中就是不存在 autoreleasepool 的，这也进一步印证了上面的结论。不过因为不知道更底层的代码，加上苹果文档中不建议修改main.m 文件，所以我们也没有理由把它删掉。但是，删掉之后也不会影响 App 运行，用 <code>Instruments</code> 也没有发现内存泄露。</p>\n<h2 id=\"autoreleasepool的创建与销毁\"><a href=\"#autoreleasepool的创建与销毁\" class=\"headerlink\" title=\"autoreleasepool的创建与销毁\"></a>autoreleasepool的创建与销毁</h2><ul>\n<li>创建 : 运行循环检测到事件并启动后，就会创建自动释放池</li>\n<li>销毁 : 一次完整的运行循环结束之前，会被销毁</li>\n</ul>\n<p>以上，autoreleasepool的创建与销毁都和运行循环（RunLoop）息息相关。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html\" target=\"_blank\" rel=\"noopener\">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html</a><br><a href=\"https://blog.ibireme.com/2015/05/18/RunLoop/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/05/18/RunLoop/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><blockquote>\n<p>A NSRunLoop object processes input for sources such as mouse and keyboard events from the window system, NSPort objects, and NSConnection objects. A NSRunLoop object also processes NSTimer events.</p>\n</blockquote>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>运行循环也叫消息循环，作用是循环的捕捉消息，然后执行消息对应的操作；并且保证应用程序不会退出。<br>OSX/iOS 系统中，提供了两个这样的对象：<code>NSRunLoop</code> 和 <code>CFRunLoopRef</code>。<br><code>CFRunLoopRef</code> 是在 <code>CoreFoundation</code> 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br><code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>\n<h2 id=\"Input-source-与-Timer-source\"><a href=\"#Input-source-与-Timer-source\" class=\"headerlink\" title=\"Input source 与 Timer source\"></a>Input source 与 Timer source</h2><p><code>Input source</code> 与 <code>Timer source</code>这两个都是 RunLoop 事件的来源</p>\n<h3 id=\"Input-Source-可以分为三类\"><a href=\"#Input-Source-可以分为三类\" class=\"headerlink\" title=\"Input Source 可以分为三类\"></a>Input Source 可以分为三类</h3><ul>\n<li>Port-Based Sources：系统底层的 Port 事件源，例如<code>CFSocketRef</code>，但在应用层中几乎用不到。</li>\n<li>Custom Input Sources：用户手动创建的事件源，例如手势，触摸，键入。</li>\n<li>Cocoa Perform Selector Sources：Cocoa 提供的<code>performSelector</code>系列方法也是一种事件源。</li>\n</ul>\n<h3 id=\"Timer-Source\"><a href=\"#Timer-Source\" class=\"headerlink\" title=\"Timer Source\"></a>Timer Source</h3><p>即是指定时器事件（<code>NSTimer</code>）。</p>\n<h2 id=\"RunLoop-与线程\"><a href=\"#RunLoop-与线程\" class=\"headerlink\" title=\"RunLoop 与线程\"></a>RunLoop 与线程</h2><p>线程和 RunLoop  之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时候并没有 RunLoop，如果你不主动获取，那么它一直不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。所以只能在一个线程的内部获取 RunLoop(主线程除外)。</p>\n<p>下图中展现了 RunLoop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。<br><img src=\"/images/objc_runloop.jpg\" alt=\"RunLoop\"></p>\n<h3 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h3><blockquote>\n<p>The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.</p>\n</blockquote>\n<h2 id=\"RunLoop-Observer\"><a href=\"#RunLoop-Observer\" class=\"headerlink\" title=\"RunLoop Observer\"></a>RunLoop Observer</h2><p>RunLoop 通过监听 Source 来决定有没有任务要做；除此之外，我们还可以用 RunLoop Observer 来监控 RunLoop 本身的状态。</p>\n<p>RunLoop Observer 可以监听以下 RunLoop 事件：</p>\n<ul>\n<li>The entrance to the run loop.</li>\n<li>When the run loop is about to process a timer.</li>\n<li>When the run loop is about to process an input source.</li>\n<li>When the run loop is about to go to sleep.</li>\n<li>When the run loop has woken up, but before it has processed the event that woke it up.</li>\n<li>The exit from the run loop.</li>\n</ul>\n<h2 id=\"RunLoop-Mode\"><a href=\"#RunLoop-Mode\" class=\"headerlink\" title=\"RunLoop Mode\"></a>RunLoop Mode</h2><p>在监听与被监听中，RunLoop 要处理的事情非常复杂；为了让 RunLoop专注于处理特定事件而引入了 RunLoop Mode 概念<br><img src=\"/images/objc_runloop_mode.png\" alt=\"RunLoop Mode\"><br>如果所示，RunLoop Mode 实际上是 Source、Timer、Observer 的集合，不同的 Mode 把不同组的 Source、Timer、Observer 隔绝开来；而 RunLoop 在某个时刻下只能跑在某一个 Mode 下，处理这一个 Mode 当中的Source、Timer 和 Observer。</p>\n<p>苹果文档中提到的 Mode 有五个，分别是：</p>\n<ul>\n<li><code>NSDefaultRunLoopMode</code></li>\n<li><code>NSConnectionReplyMode</code></li>\n<li><code>NSModalPanelRunLoopMode</code></li>\n<li><code>NSTrackingRunLoopMode</code></li>\n<li><code>NSRunLoopCommonModes</code></li>\n</ul>\n<p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 、<code>UITrackingRunLoopMode</code> 和 <code>NSRunLoopCommonModes。</code> 而<code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSTrackingRunLoopMode</code>。</p>\n<h2 id=\"RunLoop-的使用\"><a href=\"#RunLoop-的使用\" class=\"headerlink\" title=\"RunLoop 的使用\"></a>RunLoop 的使用</h2><p>RunLoop 和线程是绑定在一起的；每个线程（包括主线程）都有一个对应的 RunLoop 对象。</p>\n<h3 id=\"获取-RunLoop\"><a href=\"#获取-RunLoop\" class=\"headerlink\" title=\"获取 RunLoop\"></a>获取 RunLoop</h3><p>我们不能自己创建 RunLoop 对象，只能获取到系统提供的 RunLoop 对象。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> currentRunLoop];</span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> mainRunLoop];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在主线程和子线程中区别\"><a href=\"#在主线程和子线程中区别\" class=\"headerlink\" title=\"在主线程和子线程中区别\"></a>在主线程和子线程中区别</h3><p>RunLoop 在主线程和子线程中的 <strong>区别</strong> 在于：主线程的 RunLoop 会在应用启动的时候默认开启；其他线程（子线程）的 RunLoop 默认并不会启动，需要手动开启。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//手动启动RunLoop，无法控制结束</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\"><span class=\"comment\">//手动启动RunLoop，指定结束时间</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runUntilDate:[[<span class=\"built_in\">NSDate</span> date] dateByAddingTimeInterval:<span class=\"number\">5</span>]];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RunLoop-与-NSTimer\"><a href=\"#RunLoop-与-NSTimer\" class=\"headerlink\" title=\"RunLoop 与 NSTimer\"></a>RunLoop 与 NSTimer</h2><h3 id=\"timerWithTimeInterval\"><a href=\"#timerWithTimeInterval\" class=\"headerlink\" title=\"timerWithTimeInterval:\"></a>timerWithTimeInterval:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//需要手动加入 RunLoop 并设置 Mode</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">//立即调用一次</span></span><br><span class=\"line\">[timer fire];</span><br><span class=\"line\"><span class=\"comment\">//手动加入 RunLoop</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"scheduledTimerWithTimeInterval\"><a href=\"#scheduledTimerWithTimeInterval\" class=\"headerlink\" title=\"scheduledTimerWithTimeInterval:\"></a>scheduledTimerWithTimeInterval:</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认加入 RunLoop 并设置 Mode 为 NSDefaultRunLoopMode</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timeFire) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"><span class=\"comment\">//立即调用一次</span></span><br><span class=\"line\">[timer fire];</span><br></pre></td></tr></table></figure>\n<h3 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h3><p>日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer，一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 <code>NSDefaultRunLoopMode</code> 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 <code>UITrackingRunLoopMode</code>；而这个时候， Timer 就不会运行。</p>\n<p><strong>解决方案：</strong><br>设置RunLoop Mode，例如 NSTimer，我们指定它运行于 <code>NSRunLoopCommonModes</code> ，这是一个Mode的集合。这样无论当前 RunLoop 运行哪个 Mode ，事件都能得到执行。</p>\n<p>例如在 AFNetworking 中，就有相关的代码，如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)startActivationDelayTimer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.activationDelayTimer = [<span class=\"built_in\">NSTimer</span></span><br><span class=\"line\">                                 timerWithTimeInterval:<span class=\"keyword\">self</span>.activationDelay target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(activationDelayTimerFired) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> mainRunLoop] addTimer:<span class=\"keyword\">self</span>.activationDelayTimer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里就是添加了一个计时器，由于指定了 <code>NSRunLoopCommonModes</code>，所以不管 RunLoop 处于什么状态，都会执行这个计时器任务。</p>\n<h1 id=\"Runloop-和-Autoreleasepool-的关系图解\"><a href=\"#Runloop-和-Autoreleasepool-的关系图解\" class=\"headerlink\" title=\"Runloop 和 Autoreleasepool 的关系图解\"></a>Runloop 和 Autoreleasepool 的关系图解</h1><p><img src=\"/images/objc_autoreleasepool.png\" alt=\"关系图解\"></p>\n<h1 id=\"Autorelease-Pool\"><a href=\"#Autorelease-Pool\" class=\"headerlink\" title=\"Autorelease Pool\"></a>Autorelease Pool</h1><p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送 <code>release</code> 消息的机制；当你想放弃对象的所有权，同时又不希望这个对象被立即释放掉（例如在一个方法中返回一个对象时），Autoreleasepool就可以发挥作用。所谓的延迟发送<code>release</code>消息是指，当我们把一个对象标记为autorelease时:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span>* str = [[[<span class=\"built_in\">NSString</span> alloc] initWithString:<span class=\"string\">@\"hello\"</span>] autorelease];</span><br></pre></td></tr></table></figure></p>\n<p>这个对象的<code>retainCount+1</code>，但不会发生 <code>release</code>；当这个变量所处的<code>autoreleasepool</code>被 <code>倾倒(drain)</code> 操作时，所有标记了autorelease的对象的 <code>retainCount-1</code>；即<code>release</code>消息的发送被延迟到<code>autoreleasepool</code>释放的时候了。<br>在 ARC 环境下，苹果引入了 <code>@autoreleasepool</code> 语法，不在需要手动调用<code>autorelease</code> 和 <code>drain</code> 等方法。</p>\n<blockquote>\n<p>提示 : 此处讨论的自动释放池不是手动创建的，是跟运行循环相关的，并非 <code>main.m</code> 中的 <code>@autoreleasepool</code></p>\n</blockquote>\n<h2 id=\"Autorelease-Pool-的用处\"><a href=\"#Autorelease-Pool-的用处\" class=\"headerlink\" title=\"Autorelease Pool 的用处\"></a>Autorelease Pool 的用处</h2><p>在 ARC 下我们并不需要手动调用<code>autorelease</code>有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确的管理好内存；因为 Cocoa Touch 的 RunLoop 中，每个 RunLoop Circle中系统都加入了 Autorelease Pool 的创建和释放。</p>\n<p>当我们需要创建和销毁大量对象时，使用手动创建的<code>autoreleasepool</code>可以有效的避免内存峰值的出现；因为如果不手动创建的话，外层系统创建的 Pool 会在整个 Runloop Circle 结束之后才执行 drain 操作，手动创建的话会在 block 结束之后就就执行 drain 操作。详情请见<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a></p>\n<p>一个普遍被使用的例子如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000000</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span>* string = <span class=\"string\">@\"abc\"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span>* array = [string componentsSeparatedByString:string];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上面的例子中如果不使用<code>autoreleasepool</code>，需要在循环结束之后释放1000000个字符串；如果使用的话会在每次循环结束的时候都进行release操作。</p>\n<h2 id=\"Autorelease-Pool-进行-Drain-的时机\"><a href=\"#Autorelease-Pool-进行-Drain-的时机\" class=\"headerlink\" title=\"Autorelease Pool 进行 Drain 的时机\"></a>Autorelease Pool 进行 Drain 的时机</h2><p>如上所述，系统在 RunLoop 中创建的 autoreleasepool 会在 RunLoop 的一个 Event 结束时进行 Drain 操作；而我们手动创建的 autoreleasepool 会在 block 执行完后进行 Drain  操作。</p>\n<p>但需要注意的是：</p>\n<ul>\n<li>当 block 以异常(exception)结束时，pool 不会进行 drain 操作</li>\n<li>Pool 的 drain 操作会把所有标记为 autorelease 的对象<code>retainCount-1</code>，但并不意味着这个对象一定会被释放掉；我们可以在 autoreleasepool 中手动 retain 该对象，以延长它的声明周期(在MRC中）</li>\n</ul>\n<h2 id=\"main-m-中的-autoreleasepool-的解释\"><a href=\"#main-m-中的-autoreleasepool-的解释\" class=\"headerlink\" title=\"main.m 中的 autoreleasepool 的解释\"></a>main.m 中的 autoreleasepool 的解释</h2><p>在 iOS 程序的 main.m 文件中有类似这样的语句：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">UIApplicationMain</span>(argc, argv, <span class=\"literal\">nil</span>, <span class=\"built_in\">NSStringFromClass</span>([AppDelegate <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在面试中问到有关autorealeasepool的知识时，也多半会问一下，这里的 pool 有什么作用？能不能去掉之类…<br>根据<a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html\" target=\"_blank\" rel=\"noopener\">苹果官方文档</a>：<code>UIApplicationMain</code>函数是整个 app 的入口，用来创建 application对象（单例）和application delegate；尽管这个函数有返回值，但是却永远不会返回，当按下Home键时，app 只是切换到了后台状态。</p>\n<p>由文档知道，UIApplication会自己创建一个 main runloop，大致可以得到下面的结论：</p>\n<ol>\n<li><code>main.m</code>中 UIApplicationMain 永远不会返回，只有在系统kill掉整个app时候，系统会把应用占用的全部内存释放出来。</li>\n<li>因为 UIApplicationMain 永远不会返回，所以这里的 autoreleasepool 就永远不会进入到drain阶段。</li>\n<li>假设真的有变量进入了main.m 中的这个 Pool（而没有被更内层的 Pool 捕获），那么这些内存实际上就是被泄露的，这个autoreleasepool 等于把这种泄露情况进行了隐藏。</li>\n<li>UIApplication自己会创建 main runlooop，在 Cocoa 的 RunLoop 中实际上也是包含 autoreleasepool 的，因此main.m中的autoreleasepool可以认为是 <strong>没有必要</strong> 的。</li>\n</ol>\n<p>另外，在基于 AppKit 框架的 Mac OS 开发中，<code>main.m</code>中就是不存在 autoreleasepool 的，这也进一步印证了上面的结论。不过因为不知道更底层的代码，加上苹果文档中不建议修改main.m 文件，所以我们也没有理由把它删掉。但是，删掉之后也不会影响 App 运行，用 <code>Instruments</code> 也没有发现内存泄露。</p>\n<h2 id=\"autoreleasepool的创建与销毁\"><a href=\"#autoreleasepool的创建与销毁\" class=\"headerlink\" title=\"autoreleasepool的创建与销毁\"></a>autoreleasepool的创建与销毁</h2><ul>\n<li>创建 : 运行循环检测到事件并启动后，就会创建自动释放池</li>\n<li>销毁 : 一次完整的运行循环结束之前，会被销毁</li>\n</ul>\n<p>以上，autoreleasepool的创建与销毁都和运行循环（RunLoop）息息相关。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html\" target=\"_blank\" rel=\"noopener\">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/RunLoop.html</a><br><a href=\"https://blog.ibireme.com/2015/05/18/RunLoop/\" target=\"_blank\" rel=\"noopener\">https://blog.ibireme.com/2015/05/18/RunLoop/</a></p>\n"},{"title":"iOS - 零散的小知识点收集","date":"2018-05-18T02:20:16.000Z","_content":"## APP启动程序执行过程\n### main函数\n### 执行UIApplicationMain函数\n1. 创建UIApplication对象\n2. 创建UIApplicationDelegate对象并复制\n3. 读取配置文件info.plist，设置程序启动的一些属性\n4. 创建应用程序的Main Runloop循环\n\n### UIApplicationDelegate对象开始处理监听到的事件\n1.程序启动成功之后，首先调用application:didFinishLaunchingWithOptions:方法，如果info.plist文件中配置了启动storyboard文件名，则加载storyboard文件。如果没有配置，则根据代码来创建UIWindow--->UIWindow的rootViewController-->显示\n\n## 类方法initialize\n- 会在类第一次被使用时调用，且只会调用一次\n- 此方法的调用是线程安全的\n\n## loadView的注意事项\n1.  用于加载指定的视图，一旦重写了这个方法，Storyboard里面就不会去加载根视图了\n2.  先于`viewDidLoad`调用\n3.  不可以调用`super.loadView()`\n4.  当`self.view == nil`时回调用此方法\n\n\n## ViewController的生命周期\n![](/images/controller_life_circle.png)\n- `loadView`：用于加载制定的根试图\n- `viewDidLoad`：试图加载完毕\n- `viewWillAppear`：界面即将显示在屏幕上\n- `viewDidAppear`：界面已经完全渲染在屏幕上\n- `viewWillDisappear`：界面即将从屏幕上消失\n- `viewDidDisappear`：界面已经完全消失\n- `dealloc`：控制器销毁\n\n## stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）\n- `+stringWithFormat`:类方法，返回一个`autorelease`的NSString实例，不用手动release，在自动释放池中会自动释放。\n- `-initWithFormat`:实例方法，返回一个自己alloc申请内存的NSString实例，根据OC内存管理黄金法则，管杀管埋，它则需要自己手动release。\n- **小结**：这两个方法只是在没有使用ARC的时候有所不同，一个需要手动release一个则是自动进入autoreleasepool，所以在使用ARC的时候他们俩几乎没有什么区别。\n\n## @synthesize是啥？什么情况下使用？\n- 首先一旦重写来属性的setter和getter方法后,系统不再自动生成带下划线的成员变量,而这行代码会创造一个带下划线前缀的实例变量名,同时使用这个属性生成getter 和 setter 方法。\n- 使用`@synthesize` 只有一个目的——给实例变量起个别名,或者说为同一个变量添加两个名字。\n- 如果要阻止自动合成，记得使用 `@dynamic` 。经典的使用场景是你知道已经在某处实现了getter/setter 方法,而编译器不知道的情况。\n- 如何使用：\n``` Objc\n@synthesize obj = _obj;\n```\n\n## 栈区/堆区/常量区\n- 操作内存的栈区速度快;栈区存储空间地址是连续的\n- 操作内存的常量区速度快;内存空间只开辟一次\n- 操作内存的堆区速度相对栈区和常量区要慢些;堆区内存空间不连续,需要寻址的过程\n``` Objc\n\t// 存储在栈区\n\t int num = 10;\n\t// 存储在常量区  \n\t NSString *str1 = @\"hello\";\n\t// 存储在堆区\n\t NSString *str2 = [NSString stringWithFormat:@\"hello_%d\",i];\n```\n\n## `NSUInteger`和`NSInteger`的区别\n- `NSUInteger` 无符号整数(没有负数)用 `%tu`\n`%tu`NSUInteger的占位符，可以适配 NSUInteger的32位设备和64位设备\n32位设备: NSUInteger是`无符号的int` (无符号表示没有正负数)\n64位设备: NSUInteger是`无符号的long`\n- `NSInteger `有符号整数(有正负数)用 `%zd`\n`%zd`NSInteger的占位符，可以适配 NSInteger的32位设备和64位设备\n32位设备: NSInteger是`有符号的int` (有符号表示有正负数)\n64位设备: NSInteger是`有符号的long`\n- 以上这种设计是为了自适应32位和64位CPU的架构.\n","source":"_posts/ios-scatter-point-collect.md","raw":"---\ntitle: iOS - 零散的小知识点收集\ndate: 2018-05-18 10:20:16\ntags: [iOS,Objc]\ncategories: [iOS,Objc]\n---\n## APP启动程序执行过程\n### main函数\n### 执行UIApplicationMain函数\n1. 创建UIApplication对象\n2. 创建UIApplicationDelegate对象并复制\n3. 读取配置文件info.plist，设置程序启动的一些属性\n4. 创建应用程序的Main Runloop循环\n\n### UIApplicationDelegate对象开始处理监听到的事件\n1.程序启动成功之后，首先调用application:didFinishLaunchingWithOptions:方法，如果info.plist文件中配置了启动storyboard文件名，则加载storyboard文件。如果没有配置，则根据代码来创建UIWindow--->UIWindow的rootViewController-->显示\n\n## 类方法initialize\n- 会在类第一次被使用时调用，且只会调用一次\n- 此方法的调用是线程安全的\n\n## loadView的注意事项\n1.  用于加载指定的视图，一旦重写了这个方法，Storyboard里面就不会去加载根视图了\n2.  先于`viewDidLoad`调用\n3.  不可以调用`super.loadView()`\n4.  当`self.view == nil`时回调用此方法\n\n\n## ViewController的生命周期\n![](/images/controller_life_circle.png)\n- `loadView`：用于加载制定的根试图\n- `viewDidLoad`：试图加载完毕\n- `viewWillAppear`：界面即将显示在屏幕上\n- `viewDidAppear`：界面已经完全渲染在屏幕上\n- `viewWillDisappear`：界面即将从屏幕上消失\n- `viewDidDisappear`：界面已经完全消失\n- `dealloc`：控制器销毁\n\n## stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）\n- `+stringWithFormat`:类方法，返回一个`autorelease`的NSString实例，不用手动release，在自动释放池中会自动释放。\n- `-initWithFormat`:实例方法，返回一个自己alloc申请内存的NSString实例，根据OC内存管理黄金法则，管杀管埋，它则需要自己手动release。\n- **小结**：这两个方法只是在没有使用ARC的时候有所不同，一个需要手动release一个则是自动进入autoreleasepool，所以在使用ARC的时候他们俩几乎没有什么区别。\n\n## @synthesize是啥？什么情况下使用？\n- 首先一旦重写来属性的setter和getter方法后,系统不再自动生成带下划线的成员变量,而这行代码会创造一个带下划线前缀的实例变量名,同时使用这个属性生成getter 和 setter 方法。\n- 使用`@synthesize` 只有一个目的——给实例变量起个别名,或者说为同一个变量添加两个名字。\n- 如果要阻止自动合成，记得使用 `@dynamic` 。经典的使用场景是你知道已经在某处实现了getter/setter 方法,而编译器不知道的情况。\n- 如何使用：\n``` Objc\n@synthesize obj = _obj;\n```\n\n## 栈区/堆区/常量区\n- 操作内存的栈区速度快;栈区存储空间地址是连续的\n- 操作内存的常量区速度快;内存空间只开辟一次\n- 操作内存的堆区速度相对栈区和常量区要慢些;堆区内存空间不连续,需要寻址的过程\n``` Objc\n\t// 存储在栈区\n\t int num = 10;\n\t// 存储在常量区  \n\t NSString *str1 = @\"hello\";\n\t// 存储在堆区\n\t NSString *str2 = [NSString stringWithFormat:@\"hello_%d\",i];\n```\n\n## `NSUInteger`和`NSInteger`的区别\n- `NSUInteger` 无符号整数(没有负数)用 `%tu`\n`%tu`NSUInteger的占位符，可以适配 NSUInteger的32位设备和64位设备\n32位设备: NSUInteger是`无符号的int` (无符号表示没有正负数)\n64位设备: NSUInteger是`无符号的long`\n- `NSInteger `有符号整数(有正负数)用 `%zd`\n`%zd`NSInteger的占位符，可以适配 NSInteger的32位设备和64位设备\n32位设备: NSInteger是`有符号的int` (有符号表示有正负数)\n64位设备: NSInteger是`有符号的long`\n- 以上这种设计是为了自适应32位和64位CPU的架构.\n","slug":"ios-scatter-point-collect","published":1,"updated":"2019-01-13T05:10:08.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2q001jl1fq0k207idv","content":"<h2 id=\"APP启动程序执行过程\"><a href=\"#APP启动程序执行过程\" class=\"headerlink\" title=\"APP启动程序执行过程\"></a>APP启动程序执行过程</h2><h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><h3 id=\"执行UIApplicationMain函数\"><a href=\"#执行UIApplicationMain函数\" class=\"headerlink\" title=\"执行UIApplicationMain函数\"></a>执行UIApplicationMain函数</h3><ol>\n<li>创建UIApplication对象</li>\n<li>创建UIApplicationDelegate对象并复制</li>\n<li>读取配置文件info.plist，设置程序启动的一些属性</li>\n<li>创建应用程序的Main Runloop循环</li>\n</ol>\n<h3 id=\"UIApplicationDelegate对象开始处理监听到的事件\"><a href=\"#UIApplicationDelegate对象开始处理监听到的事件\" class=\"headerlink\" title=\"UIApplicationDelegate对象开始处理监听到的事件\"></a>UIApplicationDelegate对象开始处理监听到的事件</h3><p>1.程序启动成功之后，首先调用application:didFinishLaunchingWithOptions:方法，如果info.plist文件中配置了启动storyboard文件名，则加载storyboard文件。如果没有配置，则根据代码来创建UIWindow—&gt;UIWindow的rootViewController–&gt;显示</p>\n<h2 id=\"类方法initialize\"><a href=\"#类方法initialize\" class=\"headerlink\" title=\"类方法initialize\"></a>类方法initialize</h2><ul>\n<li>会在类第一次被使用时调用，且只会调用一次</li>\n<li>此方法的调用是线程安全的</li>\n</ul>\n<h2 id=\"loadView的注意事项\"><a href=\"#loadView的注意事项\" class=\"headerlink\" title=\"loadView的注意事项\"></a>loadView的注意事项</h2><ol>\n<li>用于加载指定的视图，一旦重写了这个方法，Storyboard里面就不会去加载根视图了</li>\n<li>先于<code>viewDidLoad</code>调用</li>\n<li>不可以调用<code>super.loadView()</code></li>\n<li>当<code>self.view == nil</code>时回调用此方法</li>\n</ol>\n<h2 id=\"ViewController的生命周期\"><a href=\"#ViewController的生命周期\" class=\"headerlink\" title=\"ViewController的生命周期\"></a>ViewController的生命周期</h2><p><img src=\"/images/controller_life_circle.png\" alt=\"\"></p>\n<ul>\n<li><code>loadView</code>：用于加载制定的根试图</li>\n<li><code>viewDidLoad</code>：试图加载完毕</li>\n<li><code>viewWillAppear</code>：界面即将显示在屏幕上</li>\n<li><code>viewDidAppear</code>：界面已经完全渲染在屏幕上</li>\n<li><code>viewWillDisappear</code>：界面即将从屏幕上消失</li>\n<li><code>viewDidDisappear</code>：界面已经完全消失</li>\n<li><code>dealloc</code>：控制器销毁</li>\n</ul>\n<h2 id=\"stringWithFormat-和-initWithFormat-区别（关于内存，ARC，释放，性能来说）\"><a href=\"#stringWithFormat-和-initWithFormat-区别（关于内存，ARC，释放，性能来说）\" class=\"headerlink\" title=\"stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）\"></a>stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）</h2><ul>\n<li><code>+stringWithFormat</code>:类方法，返回一个<code>autorelease</code>的NSString实例，不用手动release，在自动释放池中会自动释放。</li>\n<li><code>-initWithFormat</code>:实例方法，返回一个自己alloc申请内存的NSString实例，根据OC内存管理黄金法则，管杀管埋，它则需要自己手动release。</li>\n<li><strong>小结</strong>：这两个方法只是在没有使用ARC的时候有所不同，一个需要手动release一个则是自动进入autoreleasepool，所以在使用ARC的时候他们俩几乎没有什么区别。</li>\n</ul>\n<h2 id=\"synthesize是啥？什么情况下使用？\"><a href=\"#synthesize是啥？什么情况下使用？\" class=\"headerlink\" title=\"@synthesize是啥？什么情况下使用？\"></a>@synthesize是啥？什么情况下使用？</h2><ul>\n<li>首先一旦重写来属性的setter和getter方法后,系统不再自动生成带下划线的成员变量,而这行代码会创造一个带下划线前缀的实例变量名,同时使用这个属性生成getter 和 setter 方法。</li>\n<li>使用<code>@synthesize</code> 只有一个目的——给实例变量起个别名,或者说为同一个变量添加两个名字。</li>\n<li>如果要阻止自动合成，记得使用 <code>@dynamic</code> 。经典的使用场景是你知道已经在某处实现了getter/setter 方法,而编译器不知道的情况。</li>\n<li>如何使用：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synthesize</span> obj = _obj;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"栈区-堆区-常量区\"><a href=\"#栈区-堆区-常量区\" class=\"headerlink\" title=\"栈区/堆区/常量区\"></a>栈区/堆区/常量区</h2><ul>\n<li>操作内存的栈区速度快;栈区存储空间地址是连续的</li>\n<li>操作内存的常量区速度快;内存空间只开辟一次</li>\n<li>操作内存的堆区速度相对栈区和常量区要慢些;堆区内存空间不连续,需要寻址的过程<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储在栈区</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存储在常量区  </span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str1 = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存储在堆区</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str2 = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"hello_%d\"</span>,i];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NSUInteger和NSInteger的区别\"><a href=\"#NSUInteger和NSInteger的区别\" class=\"headerlink\" title=\"NSUInteger和NSInteger的区别\"></a><code>NSUInteger</code>和<code>NSInteger</code>的区别</h2><ul>\n<li><code>NSUInteger</code> 无符号整数(没有负数)用 <code>%tu</code><br><code>%tu</code>NSUInteger的占位符，可以适配 NSUInteger的32位设备和64位设备<br>32位设备: NSUInteger是<code>无符号的int</code> (无符号表示没有正负数)<br>64位设备: NSUInteger是<code>无符号的long</code></li>\n<li><code>NSInteger</code>有符号整数(有正负数)用 <code>%zd</code><br><code>%zd</code>NSInteger的占位符，可以适配 NSInteger的32位设备和64位设备<br>32位设备: NSInteger是<code>有符号的int</code> (有符号表示有正负数)<br>64位设备: NSInteger是<code>有符号的long</code></li>\n<li>以上这种设计是为了自适应32位和64位CPU的架构.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"APP启动程序执行过程\"><a href=\"#APP启动程序执行过程\" class=\"headerlink\" title=\"APP启动程序执行过程\"></a>APP启动程序执行过程</h2><h3 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h3><h3 id=\"执行UIApplicationMain函数\"><a href=\"#执行UIApplicationMain函数\" class=\"headerlink\" title=\"执行UIApplicationMain函数\"></a>执行UIApplicationMain函数</h3><ol>\n<li>创建UIApplication对象</li>\n<li>创建UIApplicationDelegate对象并复制</li>\n<li>读取配置文件info.plist，设置程序启动的一些属性</li>\n<li>创建应用程序的Main Runloop循环</li>\n</ol>\n<h3 id=\"UIApplicationDelegate对象开始处理监听到的事件\"><a href=\"#UIApplicationDelegate对象开始处理监听到的事件\" class=\"headerlink\" title=\"UIApplicationDelegate对象开始处理监听到的事件\"></a>UIApplicationDelegate对象开始处理监听到的事件</h3><p>1.程序启动成功之后，首先调用application:didFinishLaunchingWithOptions:方法，如果info.plist文件中配置了启动storyboard文件名，则加载storyboard文件。如果没有配置，则根据代码来创建UIWindow—&gt;UIWindow的rootViewController–&gt;显示</p>\n<h2 id=\"类方法initialize\"><a href=\"#类方法initialize\" class=\"headerlink\" title=\"类方法initialize\"></a>类方法initialize</h2><ul>\n<li>会在类第一次被使用时调用，且只会调用一次</li>\n<li>此方法的调用是线程安全的</li>\n</ul>\n<h2 id=\"loadView的注意事项\"><a href=\"#loadView的注意事项\" class=\"headerlink\" title=\"loadView的注意事项\"></a>loadView的注意事项</h2><ol>\n<li>用于加载指定的视图，一旦重写了这个方法，Storyboard里面就不会去加载根视图了</li>\n<li>先于<code>viewDidLoad</code>调用</li>\n<li>不可以调用<code>super.loadView()</code></li>\n<li>当<code>self.view == nil</code>时回调用此方法</li>\n</ol>\n<h2 id=\"ViewController的生命周期\"><a href=\"#ViewController的生命周期\" class=\"headerlink\" title=\"ViewController的生命周期\"></a>ViewController的生命周期</h2><p><img src=\"/images/controller_life_circle.png\" alt=\"\"></p>\n<ul>\n<li><code>loadView</code>：用于加载制定的根试图</li>\n<li><code>viewDidLoad</code>：试图加载完毕</li>\n<li><code>viewWillAppear</code>：界面即将显示在屏幕上</li>\n<li><code>viewDidAppear</code>：界面已经完全渲染在屏幕上</li>\n<li><code>viewWillDisappear</code>：界面即将从屏幕上消失</li>\n<li><code>viewDidDisappear</code>：界面已经完全消失</li>\n<li><code>dealloc</code>：控制器销毁</li>\n</ul>\n<h2 id=\"stringWithFormat-和-initWithFormat-区别（关于内存，ARC，释放，性能来说）\"><a href=\"#stringWithFormat-和-initWithFormat-区别（关于内存，ARC，释放，性能来说）\" class=\"headerlink\" title=\"stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）\"></a>stringWithFormat 和 initWithFormat 区别（关于内存，ARC，释放，性能来说）</h2><ul>\n<li><code>+stringWithFormat</code>:类方法，返回一个<code>autorelease</code>的NSString实例，不用手动release，在自动释放池中会自动释放。</li>\n<li><code>-initWithFormat</code>:实例方法，返回一个自己alloc申请内存的NSString实例，根据OC内存管理黄金法则，管杀管埋，它则需要自己手动release。</li>\n<li><strong>小结</strong>：这两个方法只是在没有使用ARC的时候有所不同，一个需要手动release一个则是自动进入autoreleasepool，所以在使用ARC的时候他们俩几乎没有什么区别。</li>\n</ul>\n<h2 id=\"synthesize是啥？什么情况下使用？\"><a href=\"#synthesize是啥？什么情况下使用？\" class=\"headerlink\" title=\"@synthesize是啥？什么情况下使用？\"></a>@synthesize是啥？什么情况下使用？</h2><ul>\n<li>首先一旦重写来属性的setter和getter方法后,系统不再自动生成带下划线的成员变量,而这行代码会创造一个带下划线前缀的实例变量名,同时使用这个属性生成getter 和 setter 方法。</li>\n<li>使用<code>@synthesize</code> 只有一个目的——给实例变量起个别名,或者说为同一个变量添加两个名字。</li>\n<li>如果要阻止自动合成，记得使用 <code>@dynamic</code> 。经典的使用场景是你知道已经在某处实现了getter/setter 方法,而编译器不知道的情况。</li>\n<li>如何使用：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@synthesize</span> obj = _obj;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"栈区-堆区-常量区\"><a href=\"#栈区-堆区-常量区\" class=\"headerlink\" title=\"栈区/堆区/常量区\"></a>栈区/堆区/常量区</h2><ul>\n<li>操作内存的栈区速度快;栈区存储空间地址是连续的</li>\n<li>操作内存的常量区速度快;内存空间只开辟一次</li>\n<li>操作内存的堆区速度相对栈区和常量区要慢些;堆区内存空间不连续,需要寻址的过程<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储在栈区</span></span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存储在常量区  </span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str1 = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 存储在堆区</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str2 = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"hello_%d\"</span>,i];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NSUInteger和NSInteger的区别\"><a href=\"#NSUInteger和NSInteger的区别\" class=\"headerlink\" title=\"NSUInteger和NSInteger的区别\"></a><code>NSUInteger</code>和<code>NSInteger</code>的区别</h2><ul>\n<li><code>NSUInteger</code> 无符号整数(没有负数)用 <code>%tu</code><br><code>%tu</code>NSUInteger的占位符，可以适配 NSUInteger的32位设备和64位设备<br>32位设备: NSUInteger是<code>无符号的int</code> (无符号表示没有正负数)<br>64位设备: NSUInteger是<code>无符号的long</code></li>\n<li><code>NSInteger</code>有符号整数(有正负数)用 <code>%zd</code><br><code>%zd</code>NSInteger的占位符，可以适配 NSInteger的32位设备和64位设备<br>32位设备: NSInteger是<code>有符号的int</code> (有符号表示有正负数)<br>64位设备: NSInteger是<code>有符号的long</code></li>\n<li>以上这种设计是为了自适应32位和64位CPU的架构.</li>\n</ul>\n"},{"title":"硬币","date":"2016-04-22T02:01:47.000Z","_content":"\n## 硬币\n\n> 你有没有扔过一枚硬币，选择正反面?\n\n为什么就不能踏踏实实的面对这个世界\n凭什么就非得打破陈规旧世界做救世主\n你想的要的只不过是平凡日子里的快乐\n你真没必要对自己如此苛刻\n你看那奔跑的青春的身影\n你看这些年，这世界，于你而言\n多了些什么，又少了些什么\n是想要的吗\n是年少时的梦想吗\n你口口声声说着情怀，念着诗和远方\n真的还记得起当初为什么出发吗\n执念\n你知道它，却不能掌控它\n你了解它，就像它了解你\n这样你便成就了它，而放弃了自己\n有些人生理想，终会伴随着你，缠绕着你，不离不弃\n而，你永远都没有勇气对它说再见\n\n2016/04/22 北京","source":"_posts/daily-2016-0422.md","raw":"---\ntitle: 硬币\ndate: 2016-04-22 10:01:47\ntags: [Daily]\ncategories: Daily\n---\n\n## 硬币\n\n> 你有没有扔过一枚硬币，选择正反面?\n\n为什么就不能踏踏实实的面对这个世界\n凭什么就非得打破陈规旧世界做救世主\n你想的要的只不过是平凡日子里的快乐\n你真没必要对自己如此苛刻\n你看那奔跑的青春的身影\n你看这些年，这世界，于你而言\n多了些什么，又少了些什么\n是想要的吗\n是年少时的梦想吗\n你口口声声说着情怀，念着诗和远方\n真的还记得起当初为什么出发吗\n执念\n你知道它，却不能掌控它\n你了解它，就像它了解你\n这样你便成就了它，而放弃了自己\n有些人生理想，终会伴随着你，缠绕着你，不离不弃\n而，你永远都没有勇气对它说再见\n\n2016/04/22 北京","slug":"daily-2016-0422","published":1,"updated":"2019-01-13T09:49:42.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2r001kl1fq7i1tilts","content":"<h2 id=\"硬币\"><a href=\"#硬币\" class=\"headerlink\" title=\"硬币\"></a>硬币</h2><blockquote>\n<p>你有没有扔过一枚硬币，选择正反面?</p>\n</blockquote>\n<p>为什么就不能踏踏实实的面对这个世界<br>凭什么就非得打破陈规旧世界做救世主<br>你想的要的只不过是平凡日子里的快乐<br>你真没必要对自己如此苛刻<br>你看那奔跑的青春的身影<br>你看这些年，这世界，于你而言<br>多了些什么，又少了些什么<br>是想要的吗<br>是年少时的梦想吗<br>你口口声声说着情怀，念着诗和远方<br>真的还记得起当初为什么出发吗<br>执念<br>你知道它，却不能掌控它<br>你了解它，就像它了解你<br>这样你便成就了它，而放弃了自己<br>有些人生理想，终会伴随着你，缠绕着你，不离不弃<br>而，你永远都没有勇气对它说再见</p>\n<p>2016/04/22 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"硬币\"><a href=\"#硬币\" class=\"headerlink\" title=\"硬币\"></a>硬币</h2><blockquote>\n<p>你有没有扔过一枚硬币，选择正反面?</p>\n</blockquote>\n<p>为什么就不能踏踏实实的面对这个世界<br>凭什么就非得打破陈规旧世界做救世主<br>你想的要的只不过是平凡日子里的快乐<br>你真没必要对自己如此苛刻<br>你看那奔跑的青春的身影<br>你看这些年，这世界，于你而言<br>多了些什么，又少了些什么<br>是想要的吗<br>是年少时的梦想吗<br>你口口声声说着情怀，念着诗和远方<br>真的还记得起当初为什么出发吗<br>执念<br>你知道它，却不能掌控它<br>你了解它，就像它了解你<br>这样你便成就了它，而放弃了自己<br>有些人生理想，终会伴随着你，缠绕着你，不离不弃<br>而，你永远都没有勇气对它说再见</p>\n<p>2016/04/22 北京</p>\n"},{"title":"iOS - 多线程之 GCD","date":"2018-04-29T07:59:59.000Z","_content":"## GCD与 NSThread 的对比\n\n### NSThread的劣势\n- 如果要开多个线程 NSThread 必须实例化多个线程对象\n- NSThread 靠 NSObject 的分类方法实现的线程间通讯，GCD依靠 block 实现\n\n### GCD的优势\n- 让代码更加简单，易于阅读和维护\n- 使用GCD 不需要管理线程的创建/销毁/复用的过程，不用关心线程的生命周期\n- GCD会充分利用CPU的内核\n\n## 队列有哪些，任务有几种\n### 队列\n- 串行队列（Serial Dispatch Queue）\n``` Objc\ndispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_SERIAL);\n```\n- 并行队列（Concurrent Dispatch Queue）\n``` Objc\ndispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_CONCURRENT);\n```\n\n### 任务\n- 同步任务（sync）\n``` Objc\ndispatch_sync(queue, ^block);\n```\n- 异步任务（async）\n``` Objc\ndispatch_async(queue, ^block);\n```\n\n## 写一个死锁程序\n- 主队列+同步任务 = 死锁\n``` Objc\n - (void)deadlockDemo\n{\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tNSLog(@\"start”);\n\tdispatch_sync(queue, ^{\n\t\tNSLog(@\"excuting...%@\",[NSThread currentThread]);\n\t});\n\tNSLog(@\"end\");\n}\n```\n- 死锁解决办法：主队列中的同步任务放进子线程中，不使其阻塞主线程\n``` Objc\n - (void)resolveDemo\n{\n\tdispatch_async(dispatch_queue_create(\"flag\", DISPATCH_QUEUE_CONCURRENT), ^{\n\t\tNSLog(@\"start\");\n\t\tdispatch_sync(dispatch_get_main_queue(), ^{\n\t\t\tNSLog(@\"excuting...%@\",[NSThread currentThread]);\n\t\t});\n\t\tNSLog(@\"end\");\n\t});\n}\n```\n\n## 全局队列的两个参数分别代表什么？\n- 参数1：服务质量(队列对任务调度的优先级)/iOS 7.0 之前，是优先级，传入`0`在所有系统上使用默认设置\n- 参数2：预留参数，以便于扩展，一般传入`0`\n- **小结**：如果要适配 iOS 7.0 & 8.0，需要使用以下代码：\n``` Objc\n dispatch_get_global_queue(0, 0);\n```\n\n## 全局队列和并发队列的区别\n### 全局队列\n- 没有名称\n- 无论MRC & ARC都不需要考虑释放\n\n### 并发队列\n- 有名称，和 NSThread 的 name 属性作用类似\n- 如果在 `MRC` 开发时,需要使用 `dispatch_release(q);` 释放相应的对象\n\n\n### 队列和任务组合总结\n- 串行和并发决定了任务的执行方式(串行一次一个，并发一次多个)\n- 同步和异步决定了要不要开启新的线程 (同步不开，异步开)\n\n## GCD延迟执行(after)\n- 延迟操作: `dispatch_after` 这个函数默认是异步执行的\n``` Objc\n-(void)afterDemo{\n  NSLog(@\"start\");\n  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)),dispatch_get_global_queue(),^{\n    NSLog(@\"delay code\");\n  });\n  NSLog(@\"end\");\n}\n```\n\n### GCD一次性执行(once)\n- `dispatch_once_t` 内部有一把锁,能够保证线程安全.\n- **原理**：`onceToken` 有个初始值,当第一次执行时,判断是否是初始值,如果是初始值就执行函数内部的代码,执行结束之前会修改`onceToken`初始值.反之,就不执行.\n``` Objc\n- (void)onceDemo\n{\n\tNSLog(@\"mark\");\n\tstatic dispatch_once_t onceToken;\n\tNSLog(@\"result %ld\",onceToken);\n\tdispatch_once(&onceToken, ^{\n\t\tNSLog(@\"hello\");\n\t});\n}\n```\n\n## 单例设计模式（iOS）\n\n### 单例设计模式的特点\n1. 有一个全局访问点（供全局实例化单例的类方法）\n2. 单例保存在静态存储区\n3. 在内存有且只有一份\n4. 生命周期跟APP一样长\n\n\n### 如何做到被子类继承\n- 在给instance赋值时要使用`[self new];`或者`[[self alloc] init];`\n\n\n### 懒汉式\n``` Objc\n+ (instancetype)shared\n{\n\t// 保存在静态存储区\n\tstatic id instance;\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tinstance = [[self alloc] init];\n\t});\n\treturn instance;\n}\n```\n### 饿汉式\n``` Objc\n@implementation Singleton\n// 声明静态对象\nstatic id instance;\n+ (void)initialize\n{\n  // 只会开辟一次内存空间,只会被实例化一次\n  instance = [[self alloc] init];\n}\n\n+ (instancetype)shared\n{\n\treturn instance;\n}\n@end\n```\n","source":"_posts/ios-thread-gcd.md","raw":"---\ntitle: iOS - 多线程之 GCD\ndate: 2018-04-29 15:59:59\ntags: [iOS,Objc,Thread,GCD]\ncategories: [iOS,Objc]\n---\n## GCD与 NSThread 的对比\n\n### NSThread的劣势\n- 如果要开多个线程 NSThread 必须实例化多个线程对象\n- NSThread 靠 NSObject 的分类方法实现的线程间通讯，GCD依靠 block 实现\n\n### GCD的优势\n- 让代码更加简单，易于阅读和维护\n- 使用GCD 不需要管理线程的创建/销毁/复用的过程，不用关心线程的生命周期\n- GCD会充分利用CPU的内核\n\n## 队列有哪些，任务有几种\n### 队列\n- 串行队列（Serial Dispatch Queue）\n``` Objc\ndispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_SERIAL);\n```\n- 并行队列（Concurrent Dispatch Queue）\n``` Objc\ndispatch_queue_t queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_CONCURRENT);\n```\n\n### 任务\n- 同步任务（sync）\n``` Objc\ndispatch_sync(queue, ^block);\n```\n- 异步任务（async）\n``` Objc\ndispatch_async(queue, ^block);\n```\n\n## 写一个死锁程序\n- 主队列+同步任务 = 死锁\n``` Objc\n - (void)deadlockDemo\n{\n\tdispatch_queue_t queue = dispatch_get_main_queue();\n\tNSLog(@\"start”);\n\tdispatch_sync(queue, ^{\n\t\tNSLog(@\"excuting...%@\",[NSThread currentThread]);\n\t});\n\tNSLog(@\"end\");\n}\n```\n- 死锁解决办法：主队列中的同步任务放进子线程中，不使其阻塞主线程\n``` Objc\n - (void)resolveDemo\n{\n\tdispatch_async(dispatch_queue_create(\"flag\", DISPATCH_QUEUE_CONCURRENT), ^{\n\t\tNSLog(@\"start\");\n\t\tdispatch_sync(dispatch_get_main_queue(), ^{\n\t\t\tNSLog(@\"excuting...%@\",[NSThread currentThread]);\n\t\t});\n\t\tNSLog(@\"end\");\n\t});\n}\n```\n\n## 全局队列的两个参数分别代表什么？\n- 参数1：服务质量(队列对任务调度的优先级)/iOS 7.0 之前，是优先级，传入`0`在所有系统上使用默认设置\n- 参数2：预留参数，以便于扩展，一般传入`0`\n- **小结**：如果要适配 iOS 7.0 & 8.0，需要使用以下代码：\n``` Objc\n dispatch_get_global_queue(0, 0);\n```\n\n## 全局队列和并发队列的区别\n### 全局队列\n- 没有名称\n- 无论MRC & ARC都不需要考虑释放\n\n### 并发队列\n- 有名称，和 NSThread 的 name 属性作用类似\n- 如果在 `MRC` 开发时,需要使用 `dispatch_release(q);` 释放相应的对象\n\n\n### 队列和任务组合总结\n- 串行和并发决定了任务的执行方式(串行一次一个，并发一次多个)\n- 同步和异步决定了要不要开启新的线程 (同步不开，异步开)\n\n## GCD延迟执行(after)\n- 延迟操作: `dispatch_after` 这个函数默认是异步执行的\n``` Objc\n-(void)afterDemo{\n  NSLog(@\"start\");\n  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)),dispatch_get_global_queue(),^{\n    NSLog(@\"delay code\");\n  });\n  NSLog(@\"end\");\n}\n```\n\n### GCD一次性执行(once)\n- `dispatch_once_t` 内部有一把锁,能够保证线程安全.\n- **原理**：`onceToken` 有个初始值,当第一次执行时,判断是否是初始值,如果是初始值就执行函数内部的代码,执行结束之前会修改`onceToken`初始值.反之,就不执行.\n``` Objc\n- (void)onceDemo\n{\n\tNSLog(@\"mark\");\n\tstatic dispatch_once_t onceToken;\n\tNSLog(@\"result %ld\",onceToken);\n\tdispatch_once(&onceToken, ^{\n\t\tNSLog(@\"hello\");\n\t});\n}\n```\n\n## 单例设计模式（iOS）\n\n### 单例设计模式的特点\n1. 有一个全局访问点（供全局实例化单例的类方法）\n2. 单例保存在静态存储区\n3. 在内存有且只有一份\n4. 生命周期跟APP一样长\n\n\n### 如何做到被子类继承\n- 在给instance赋值时要使用`[self new];`或者`[[self alloc] init];`\n\n\n### 懒汉式\n``` Objc\n+ (instancetype)shared\n{\n\t// 保存在静态存储区\n\tstatic id instance;\n\tstatic dispatch_once_t onceToken;\n\tdispatch_once(&onceToken, ^{\n\t\tinstance = [[self alloc] init];\n\t});\n\treturn instance;\n}\n```\n### 饿汉式\n``` Objc\n@implementation Singleton\n// 声明静态对象\nstatic id instance;\n+ (void)initialize\n{\n  // 只会开辟一次内存空间,只会被实例化一次\n  instance = [[self alloc] init];\n}\n\n+ (instancetype)shared\n{\n\treturn instance;\n}\n@end\n```\n","slug":"ios-thread-gcd","published":1,"updated":"2019-01-13T05:10:12.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2t001ol1fqggtnlq8y","content":"<h2 id=\"GCD与-NSThread-的对比\"><a href=\"#GCD与-NSThread-的对比\" class=\"headerlink\" title=\"GCD与 NSThread 的对比\"></a>GCD与 NSThread 的对比</h2><h3 id=\"NSThread的劣势\"><a href=\"#NSThread的劣势\" class=\"headerlink\" title=\"NSThread的劣势\"></a>NSThread的劣势</h3><ul>\n<li>如果要开多个线程 NSThread 必须实例化多个线程对象</li>\n<li>NSThread 靠 NSObject 的分类方法实现的线程间通讯，GCD依靠 block 实现</li>\n</ul>\n<h3 id=\"GCD的优势\"><a href=\"#GCD的优势\" class=\"headerlink\" title=\"GCD的优势\"></a>GCD的优势</h3><ul>\n<li>让代码更加简单，易于阅读和维护</li>\n<li>使用GCD 不需要管理线程的创建/销毁/复用的过程，不用关心线程的生命周期</li>\n<li>GCD会充分利用CPU的内核</li>\n</ul>\n<h2 id=\"队列有哪些，任务有几种\"><a href=\"#队列有哪些，任务有几种\" class=\"headerlink\" title=\"队列有哪些，任务有几种\"></a>队列有哪些，任务有几种</h2><h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><ul>\n<li><p>串行队列（Serial Dispatch Queue）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并行队列（Concurrent Dispatch Queue）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><ul>\n<li><p>同步任务（sync）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^block);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步任务（async）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^block);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"写一个死锁程序\"><a href=\"#写一个死锁程序\" class=\"headerlink\" title=\"写一个死锁程序\"></a>写一个死锁程序</h2><ul>\n<li><p>主队列+同步任务 = 死锁</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)deadlockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start”);</span></span><br><span class=\"line\"><span class=\"string\">\tdispatch_sync(queue, ^&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tNSLog(@\"</span>excuting...%<span class=\"string\">@\",[NSThread currentThread]);</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;);</span></span><br><span class=\"line\"><span class=\"string\">\tNSLog(@\"</span>end<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>死锁解决办法：主队列中的同步任务放进子线程中，不使其阻塞主线程</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)resolveDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_async</span>(dispatch_queue_create(<span class=\"string\">\"flag\"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"excuting...%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"全局队列的两个参数分别代表什么？\"><a href=\"#全局队列的两个参数分别代表什么？\" class=\"headerlink\" title=\"全局队列的两个参数分别代表什么？\"></a>全局队列的两个参数分别代表什么？</h2><ul>\n<li>参数1：服务质量(队列对任务调度的优先级)/iOS 7.0 之前，是优先级，传入<code>0</code>在所有系统上使用默认设置</li>\n<li>参数2：预留参数，以便于扩展，一般传入<code>0</code></li>\n<li><strong>小结</strong>：如果要适配 iOS 7.0 &amp; 8.0，需要使用以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"全局队列和并发队列的区别\"><a href=\"#全局队列和并发队列的区别\" class=\"headerlink\" title=\"全局队列和并发队列的区别\"></a>全局队列和并发队列的区别</h2><h3 id=\"全局队列\"><a href=\"#全局队列\" class=\"headerlink\" title=\"全局队列\"></a>全局队列</h3><ul>\n<li>没有名称</li>\n<li>无论MRC &amp; ARC都不需要考虑释放</li>\n</ul>\n<h3 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h3><ul>\n<li>有名称，和 NSThread 的 name 属性作用类似</li>\n<li>如果在 <code>MRC</code> 开发时,需要使用 <code>dispatch_release(q);</code> 释放相应的对象</li>\n</ul>\n<h3 id=\"队列和任务组合总结\"><a href=\"#队列和任务组合总结\" class=\"headerlink\" title=\"队列和任务组合总结\"></a>队列和任务组合总结</h3><ul>\n<li>串行和并发决定了任务的执行方式(串行一次一个，并发一次多个)</li>\n<li>同步和异步决定了要不要开启新的线程 (同步不开，异步开)</li>\n</ul>\n<h2 id=\"GCD延迟执行-after\"><a href=\"#GCD延迟执行-after\" class=\"headerlink\" title=\"GCD延迟执行(after)\"></a>GCD延迟执行(after)</h2><ul>\n<li>延迟操作: <code>dispatch_after</code> 这个函数默认是异步执行的<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)afterDemo&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start\"</span>);</span><br><span class=\"line\">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span>*<span class=\"built_in\">NSEC_PER_SEC</span>)),dispatch_get_global_queue(),^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"delay code\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"GCD一次性执行-once\"><a href=\"#GCD一次性执行-once\" class=\"headerlink\" title=\"GCD一次性执行(once)\"></a>GCD一次性执行(once)</h3><ul>\n<li><code>dispatch_once_t</code> 内部有一把锁,能够保证线程安全.</li>\n<li><strong>原理</strong>：<code>onceToken</code> 有个初始值,当第一次执行时,判断是否是初始值,如果是初始值就执行函数内部的代码,执行结束之前会修改<code>onceToken</code>初始值.反之,就不执行.<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)onceDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"mark\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"result %ld\"</span>,onceToken);</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"单例设计模式（iOS）\"><a href=\"#单例设计模式（iOS）\" class=\"headerlink\" title=\"单例设计模式（iOS）\"></a>单例设计模式（iOS）</h2><h3 id=\"单例设计模式的特点\"><a href=\"#单例设计模式的特点\" class=\"headerlink\" title=\"单例设计模式的特点\"></a>单例设计模式的特点</h3><ol>\n<li>有一个全局访问点（供全局实例化单例的类方法）</li>\n<li>单例保存在静态存储区</li>\n<li>在内存有且只有一份</li>\n<li>生命周期跟APP一样长</li>\n</ol>\n<h3 id=\"如何做到被子类继承\"><a href=\"#如何做到被子类继承\" class=\"headerlink\" title=\"如何做到被子类继承\"></a>如何做到被子类继承</h3><ul>\n<li>在给instance赋值时要使用<code>[self new];</code>或者<code>[[self alloc] init];</code></li>\n</ul>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)shared</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 保存在静态存储区</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">id</span> instance;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t\tinstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明静态对象</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> instance;</span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只会开辟一次内存空间,只会被实例化一次</span></span><br><span class=\"line\">  instance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)shared</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GCD与-NSThread-的对比\"><a href=\"#GCD与-NSThread-的对比\" class=\"headerlink\" title=\"GCD与 NSThread 的对比\"></a>GCD与 NSThread 的对比</h2><h3 id=\"NSThread的劣势\"><a href=\"#NSThread的劣势\" class=\"headerlink\" title=\"NSThread的劣势\"></a>NSThread的劣势</h3><ul>\n<li>如果要开多个线程 NSThread 必须实例化多个线程对象</li>\n<li>NSThread 靠 NSObject 的分类方法实现的线程间通讯，GCD依靠 block 实现</li>\n</ul>\n<h3 id=\"GCD的优势\"><a href=\"#GCD的优势\" class=\"headerlink\" title=\"GCD的优势\"></a>GCD的优势</h3><ul>\n<li>让代码更加简单，易于阅读和维护</li>\n<li>使用GCD 不需要管理线程的创建/销毁/复用的过程，不用关心线程的生命周期</li>\n<li>GCD会充分利用CPU的内核</li>\n</ul>\n<h2 id=\"队列有哪些，任务有几种\"><a href=\"#队列有哪些，任务有几种\" class=\"headerlink\" title=\"队列有哪些，任务有几种\"></a>队列有哪些，任务有几种</h2><h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><ul>\n<li><p>串行队列（Serial Dispatch Queue）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并行队列（Concurrent Dispatch Queue）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(“flag”, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><ul>\n<li><p>同步任务（sync）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^block);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异步任务（async）</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^block);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"写一个死锁程序\"><a href=\"#写一个死锁程序\" class=\"headerlink\" title=\"写一个死锁程序\"></a>写一个死锁程序</h2><ul>\n<li><p>主队列+同步任务 = 死锁</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)deadlockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start”);</span></span><br><span class=\"line\"><span class=\"string\">\tdispatch_sync(queue, ^&#123;</span></span><br><span class=\"line\"><span class=\"string\">\t\tNSLog(@\"</span>excuting...%<span class=\"string\">@\",[NSThread currentThread]);</span></span><br><span class=\"line\"><span class=\"string\">\t&#125;);</span></span><br><span class=\"line\"><span class=\"string\">\tNSLog(@\"</span>end<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>死锁解决办法：主队列中的同步任务放进子线程中，不使其阻塞主线程</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (<span class=\"keyword\">void</span>)resolveDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_async</span>(dispatch_queue_create(<span class=\"string\">\"flag\"</span>, DISPATCH_QUEUE_CONCURRENT), ^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start\"</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"excuting...%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"全局队列的两个参数分别代表什么？\"><a href=\"#全局队列的两个参数分别代表什么？\" class=\"headerlink\" title=\"全局队列的两个参数分别代表什么？\"></a>全局队列的两个参数分别代表什么？</h2><ul>\n<li>参数1：服务质量(队列对任务调度的优先级)/iOS 7.0 之前，是优先级，传入<code>0</code>在所有系统上使用默认设置</li>\n<li>参数2：预留参数，以便于扩展，一般传入<code>0</code></li>\n<li><strong>小结</strong>：如果要适配 iOS 7.0 &amp; 8.0，需要使用以下代码：<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"全局队列和并发队列的区别\"><a href=\"#全局队列和并发队列的区别\" class=\"headerlink\" title=\"全局队列和并发队列的区别\"></a>全局队列和并发队列的区别</h2><h3 id=\"全局队列\"><a href=\"#全局队列\" class=\"headerlink\" title=\"全局队列\"></a>全局队列</h3><ul>\n<li>没有名称</li>\n<li>无论MRC &amp; ARC都不需要考虑释放</li>\n</ul>\n<h3 id=\"并发队列\"><a href=\"#并发队列\" class=\"headerlink\" title=\"并发队列\"></a>并发队列</h3><ul>\n<li>有名称，和 NSThread 的 name 属性作用类似</li>\n<li>如果在 <code>MRC</code> 开发时,需要使用 <code>dispatch_release(q);</code> 释放相应的对象</li>\n</ul>\n<h3 id=\"队列和任务组合总结\"><a href=\"#队列和任务组合总结\" class=\"headerlink\" title=\"队列和任务组合总结\"></a>队列和任务组合总结</h3><ul>\n<li>串行和并发决定了任务的执行方式(串行一次一个，并发一次多个)</li>\n<li>同步和异步决定了要不要开启新的线程 (同步不开，异步开)</li>\n</ul>\n<h2 id=\"GCD延迟执行-after\"><a href=\"#GCD延迟执行-after\" class=\"headerlink\" title=\"GCD延迟执行(after)\"></a>GCD延迟执行(after)</h2><ul>\n<li>延迟操作: <code>dispatch_after</code> 这个函数默认是异步执行的<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)afterDemo&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"start\"</span>);</span><br><span class=\"line\">  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class=\"number\">2.0</span>*<span class=\"built_in\">NSEC_PER_SEC</span>)),dispatch_get_global_queue(),^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"delay code\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"GCD一次性执行-once\"><a href=\"#GCD一次性执行-once\" class=\"headerlink\" title=\"GCD一次性执行(once)\"></a>GCD一次性执行(once)</h3><ul>\n<li><code>dispatch_once_t</code> 内部有一把锁,能够保证线程安全.</li>\n<li><strong>原理</strong>：<code>onceToken</code> 有个初始值,当第一次执行时,判断是否是初始值,如果是初始值就执行函数内部的代码,执行结束之前会修改<code>onceToken</code>初始值.反之,就不执行.<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)onceDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"mark\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"result %ld\"</span>,onceToken);</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello\"</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"单例设计模式（iOS）\"><a href=\"#单例设计模式（iOS）\" class=\"headerlink\" title=\"单例设计模式（iOS）\"></a>单例设计模式（iOS）</h2><h3 id=\"单例设计模式的特点\"><a href=\"#单例设计模式的特点\" class=\"headerlink\" title=\"单例设计模式的特点\"></a>单例设计模式的特点</h3><ol>\n<li>有一个全局访问点（供全局实例化单例的类方法）</li>\n<li>单例保存在静态存储区</li>\n<li>在内存有且只有一份</li>\n<li>生命周期跟APP一样长</li>\n</ol>\n<h3 id=\"如何做到被子类继承\"><a href=\"#如何做到被子类继承\" class=\"headerlink\" title=\"如何做到被子类继承\"></a>如何做到被子类继承</h3><ul>\n<li>在给instance赋值时要使用<code>[self new];</code>或者<code>[[self alloc] init];</code></li>\n</ul>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)shared</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 保存在静态存储区</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">id</span> instance;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">\t<span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">\t\tinstance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Singleton</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明静态对象</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">id</span> instance;</span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)initialize</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 只会开辟一次内存空间,只会被实例化一次</span></span><br><span class=\"line\">  instance = [[<span class=\"keyword\">self</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)shared</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n"},{"title":"iOS - pthread 使用和 __bridge","date":"2018-05-18T11:41:58.000Z","_content":"\npthread是POSIX thread的简写，跨平台多线程的C语言开发框架,pthread是实现多线程的技术方案之一，NSThread就是对它的封装。\n\n## pthread开启子线程的函数介绍\n```\n#import <pthread.h>\nint pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,\n\t\t\t\t   void *(*)(void *), void * __restrict);\n```\n\n### 参数\n`pthread_t *` : 线程标示符，传入指向线程标示符的指针地址。\n`pthread_attr_t *` :线程属性，传入指向线程属性的指针地。\n`void*( * )(void * )` :新线程要执行的函数(任务)，传入函数地址，即函数名。\n`void * `:传入到函数的参数。\n\n### 返回值\n- 返回int类型的值,0表示创建新线程成功,反之,创建新线程失败,返回失败的编号。\n- C语言框架里面并不是非零即真原则；因为他们认为成功的结果只有一个，但是失败的原因有很多。\n\n## pthread开启子线程的函数实现\n``` objc\n- (void)pthreadDemo {\n\t// 新线程的标示符\n\tpthread_t ID;\n\t// 创建子线程\n\tint result = pthread_create(&ID, NULL, demo, NULL);\n\t// 判断创建子线程是否成功\n\tif (result == 0) {\n\t\tNSLog(@“success”);\n\t} else {\n\t\tNSLog(@“failure”);\n\t}\n}\n```\n\n## 子线程异步执行的函数/任务\n```objc\nvoid * demo(void *param)\n{\n\tNSLog(@\"demo %@\",[NSThread currentThread]);\n\treturn NULL;\n}\n```\n\n## 小结\n- C 语言中 `void *` 与 OC 中的 id 类似。\n-  `void *(*)(void *)` 中的`(*)` 表示指向函数的指针，即函数指针，即函数名或者函数地址。\n\n\n## *__bridge*\n用作于普通的 C 指针与 OC 指针的转换，不做任何操作。\n```\nvoid *p;\nNSObject *objc = [[NSObject alloc] init];\np = (__bridge void*)objc;\n```\n这里的 `void * p` 指针直接指向了 `NSObject * objc` 这个 OC 类，p 指针并不拥有 OC 对象，跟普通的指针指向地址无疑。所以这个出现了一个问题，OC 对象被释放，p 指针也就释放了。\n## *__bridge_retained*\n用作 C 指针与 OC 指针的转换，并且也用拥有着被转换对象的所有权\n## *__bridge_transfer*\n用作 C 指针与 OC 指针的转换，并在拥有对象所有权后将原先对象所有权释放。(只支持 C 指针转换 OC 对象指针)\n其实可以理解为先将对象的引用计数器 +1，然后再将引用计数器 -1。\n","source":"_posts/ios-thread-use-pthread.md","raw":"---\ntitle: iOS - pthread 使用和 __bridge\ndate: 2018-05-18 19:41:58\ntags: [iOS,Thread,Objc]\ncategories: [iOS,Objc]\n---\n\npthread是POSIX thread的简写，跨平台多线程的C语言开发框架,pthread是实现多线程的技术方案之一，NSThread就是对它的封装。\n\n## pthread开启子线程的函数介绍\n```\n#import <pthread.h>\nint pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,\n\t\t\t\t   void *(*)(void *), void * __restrict);\n```\n\n### 参数\n`pthread_t *` : 线程标示符，传入指向线程标示符的指针地址。\n`pthread_attr_t *` :线程属性，传入指向线程属性的指针地。\n`void*( * )(void * )` :新线程要执行的函数(任务)，传入函数地址，即函数名。\n`void * `:传入到函数的参数。\n\n### 返回值\n- 返回int类型的值,0表示创建新线程成功,反之,创建新线程失败,返回失败的编号。\n- C语言框架里面并不是非零即真原则；因为他们认为成功的结果只有一个，但是失败的原因有很多。\n\n## pthread开启子线程的函数实现\n``` objc\n- (void)pthreadDemo {\n\t// 新线程的标示符\n\tpthread_t ID;\n\t// 创建子线程\n\tint result = pthread_create(&ID, NULL, demo, NULL);\n\t// 判断创建子线程是否成功\n\tif (result == 0) {\n\t\tNSLog(@“success”);\n\t} else {\n\t\tNSLog(@“failure”);\n\t}\n}\n```\n\n## 子线程异步执行的函数/任务\n```objc\nvoid * demo(void *param)\n{\n\tNSLog(@\"demo %@\",[NSThread currentThread]);\n\treturn NULL;\n}\n```\n\n## 小结\n- C 语言中 `void *` 与 OC 中的 id 类似。\n-  `void *(*)(void *)` 中的`(*)` 表示指向函数的指针，即函数指针，即函数名或者函数地址。\n\n\n## *__bridge*\n用作于普通的 C 指针与 OC 指针的转换，不做任何操作。\n```\nvoid *p;\nNSObject *objc = [[NSObject alloc] init];\np = (__bridge void*)objc;\n```\n这里的 `void * p` 指针直接指向了 `NSObject * objc` 这个 OC 类，p 指针并不拥有 OC 对象，跟普通的指针指向地址无疑。所以这个出现了一个问题，OC 对象被释放，p 指针也就释放了。\n## *__bridge_retained*\n用作 C 指针与 OC 指针的转换，并且也用拥有着被转换对象的所有权\n## *__bridge_transfer*\n用作 C 指针与 OC 指针的转换，并在拥有对象所有权后将原先对象所有权释放。(只支持 C 指针转换 OC 对象指针)\n其实可以理解为先将对象的引用计数器 +1，然后再将引用计数器 -1。\n","slug":"ios-thread-use-pthread","published":1,"updated":"2019-01-13T05:10:23.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2u001rl1fqlpfang1i","content":"<p>pthread是POSIX thread的简写，跨平台多线程的C语言开发框架,pthread是实现多线程的技术方案之一，NSThread就是对它的封装。</p>\n<h2 id=\"pthread开启子线程的函数介绍\"><a href=\"#pthread开启子线程的函数介绍\" class=\"headerlink\" title=\"pthread开启子线程的函数介绍\"></a>pthread开启子线程的函数介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;pthread.h&gt;</span><br><span class=\"line\">int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,</span><br><span class=\"line\">\t\t\t\t   void *(*)(void *), void * __restrict);</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><code>pthread_t *</code> : 线程标示符，传入指向线程标示符的指针地址。<br><code>pthread_attr_t *</code> :线程属性，传入指向线程属性的指针地。<br><code>void*( * )(void * )</code> :新线程要执行的函数(任务)，传入函数地址，即函数名。<br><code>void *</code>:传入到函数的参数。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>返回int类型的值,0表示创建新线程成功,反之,创建新线程失败,返回失败的编号。</li>\n<li>C语言框架里面并不是非零即真原则；因为他们认为成功的结果只有一个，但是失败的原因有很多。</li>\n</ul>\n<h2 id=\"pthread开启子线程的函数实现\"><a href=\"#pthread开启子线程的函数实现\" class=\"headerlink\" title=\"pthread开启子线程的函数实现\"></a>pthread开启子线程的函数实现</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pthreadDemo &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 新线程的标示符</span></span><br><span class=\"line\">\tpthread_t ID;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建子线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = pthread_create(&amp;ID, <span class=\"literal\">NULL</span>, demo, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断创建子线程是否成功</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“success”);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“failure”);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"子线程异步执行的函数-任务\"><a href=\"#子线程异步执行的函数-任务\" class=\"headerlink\" title=\"子线程异步执行的函数/任务\"></a>子线程异步执行的函数/任务</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> * demo(<span class=\"keyword\">void</span> *param)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"demo %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>C 语言中 <code>void *</code> 与 OC 中的 id 类似。</li>\n<li><code>void *(*)(void *)</code> 中的<code>(*)</code> 表示指向函数的指针，即函数指针，即函数名或者函数地址。</li>\n</ul>\n<h2 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a><em>__bridge</em></h2><p>用作于普通的 C 指针与 OC 指针的转换，不做任何操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *p;</span><br><span class=\"line\">NSObject *objc = [[NSObject alloc] init];</span><br><span class=\"line\">p = (__bridge void*)objc;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 <code>void * p</code> 指针直接指向了 <code>NSObject * objc</code> 这个 OC 类，p 指针并不拥有 OC 对象，跟普通的指针指向地址无疑。所以这个出现了一个问题，OC 对象被释放，p 指针也就释放了。</p>\n<h2 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a><em>__bridge_retained</em></h2><p>用作 C 指针与 OC 指针的转换，并且也用拥有着被转换对象的所有权</p>\n<h2 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a><em>__bridge_transfer</em></h2><p>用作 C 指针与 OC 指针的转换，并在拥有对象所有权后将原先对象所有权释放。(只支持 C 指针转换 OC 对象指针)<br>其实可以理解为先将对象的引用计数器 +1，然后再将引用计数器 -1。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>pthread是POSIX thread的简写，跨平台多线程的C语言开发框架,pthread是实现多线程的技术方案之一，NSThread就是对它的封装。</p>\n<h2 id=\"pthread开启子线程的函数介绍\"><a href=\"#pthread开启子线程的函数介绍\" class=\"headerlink\" title=\"pthread开启子线程的函数介绍\"></a>pthread开启子线程的函数介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;pthread.h&gt;</span><br><span class=\"line\">int pthread_create(pthread_t * __restrict, const pthread_attr_t * __restrict,</span><br><span class=\"line\">\t\t\t\t   void *(*)(void *), void * __restrict);</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p><code>pthread_t *</code> : 线程标示符，传入指向线程标示符的指针地址。<br><code>pthread_attr_t *</code> :线程属性，传入指向线程属性的指针地。<br><code>void*( * )(void * )</code> :新线程要执行的函数(任务)，传入函数地址，即函数名。<br><code>void *</code>:传入到函数的参数。</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><ul>\n<li>返回int类型的值,0表示创建新线程成功,反之,创建新线程失败,返回失败的编号。</li>\n<li>C语言框架里面并不是非零即真原则；因为他们认为成功的结果只有一个，但是失败的原因有很多。</li>\n</ul>\n<h2 id=\"pthread开启子线程的函数实现\"><a href=\"#pthread开启子线程的函数实现\" class=\"headerlink\" title=\"pthread开启子线程的函数实现\"></a>pthread开启子线程的函数实现</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)pthreadDemo &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 新线程的标示符</span></span><br><span class=\"line\">\tpthread_t ID;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建子线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> result = pthread_create(&amp;ID, <span class=\"literal\">NULL</span>, demo, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 判断创建子线程是否成功</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“success”);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(@“failure”);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"子线程异步执行的函数-任务\"><a href=\"#子线程异步执行的函数-任务\" class=\"headerlink\" title=\"子线程异步执行的函数/任务\"></a>子线程异步执行的函数/任务</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> * demo(<span class=\"keyword\">void</span> *param)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"demo %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>C 语言中 <code>void *</code> 与 OC 中的 id 类似。</li>\n<li><code>void *(*)(void *)</code> 中的<code>(*)</code> 表示指向函数的指针，即函数指针，即函数名或者函数地址。</li>\n</ul>\n<h2 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a><em>__bridge</em></h2><p>用作于普通的 C 指针与 OC 指针的转换，不做任何操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *p;</span><br><span class=\"line\">NSObject *objc = [[NSObject alloc] init];</span><br><span class=\"line\">p = (__bridge void*)objc;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 <code>void * p</code> 指针直接指向了 <code>NSObject * objc</code> 这个 OC 类，p 指针并不拥有 OC 对象，跟普通的指针指向地址无疑。所以这个出现了一个问题，OC 对象被释放，p 指针也就释放了。</p>\n<h2 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a><em>__bridge_retained</em></h2><p>用作 C 指针与 OC 指针的转换，并且也用拥有着被转换对象的所有权</p>\n<h2 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a><em>__bridge_transfer</em></h2><p>用作 C 指针与 OC 指针的转换，并在拥有对象所有权后将原先对象所有权释放。(只支持 C 指针转换 OC 对象指针)<br>其实可以理解为先将对象的引用计数器 +1，然后再将引用计数器 -1。</p>\n"},{"title":"iOS - 多线程之 NSOperation","date":"2018-04-29T09:14:05.000Z","_content":"\n# NSOperation\napple提供的多线程解决方案`NSOperation`是一个表示与单个任务关联的代码和数据的抽象类；因为是一个抽象类，所以不能直接使用，需要使用它的两个子类(`NSInvocationOperation` or `NSBlockOperation`) 去执行实际的操作任务；同样我们也可以通过自定义NSOperation。通常将操作添加到操作队列（`NSOperationQueue`类的实例）来执行操作。其实`NSOperation`就是对`GCD`的封装，相对于GCD来说可控性更强，并且可以加入操作依赖（`addDependency:` and `removeDependency`）。\n\n## NSInvocationOperation\n### start\n```Objc\n- (void)demo1 {\n    NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"];\n    [op start];\n}\n\n- (void)operationTask:(id)param {\n    NSLog(@\"%@\",[NSThread currentThread]);\n}\n```\n输出结果：发现在主线程中输出的结果，但`start`方法是在`当前线程`中执行的\n``` console\n2018-05-19 14:45:07.956558+0800 NSOperation练习[1324:290009] <NSThread: 0x604000078000>{number = 1, name = main}\n```\n### 将操作添加到队列\n```Objc\n- (void)demo2 {\n\tNSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"];\n\tNSOperationQueue * queue = [[NSOperationQueue alloc]init];\n\t[queue addOperation:op];\n}\n```\n输出结果：开启子线程异步执行\n``` console\n2018-05-19 14:50:53.013010+0800 NSOperation练习[1408:312296] <NSThread: 0x60400046b600>{number = 3, name = (null)}\n```\n\n## NSBlockOperation (使用较多)\n### start\n```Objc\n- (void)demo4 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"%@\",[NSThread currentThread]);\n    }];\n    [op start];\n}\n```\n输出结果：`start`方法是在`当前线程`中执行\n```console\n2018-05-19 15:06:11.837276+0800 NSOperation练习[1661:375754] <NSThread: 0x6000000745c0>{number = 1, name = main}\n```\n### 将操作添加到队列\n```Objc\n- (void)demo5 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"%@\",[NSThread currentThread]);\n    }];\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperation:op];\n}\n```\n输出结果：开启子线程异步执行\n```console\n2018-05-19 15:10:23.974301+0800 NSOperation练习[1720:389949] <NSThread: 0x60400027ea40>{number = 3, name = (null)}\n```\n### 执行块\n```Objc\n- (void)demo6 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"block 2 %@\", [NSThread currentThread]);\n    }];\n\n    [op addExecutionBlock:^{\n        NSLog(@\"block 1 %@\", [NSThread currentThread]);\n    }];\n\n\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperation:op];\n\n    NSLog(@\"%@\", op.executionBlocks);\n}\n```\n输出结果：执行块和操作享有共同的属性设置，异步执行\n```console\n2018-05-19 15:20:27.839119+0800 NSOperation练习[1882:431125] (\n    \"<__NSGlobalBlock__: 0x1086f9080>\",\n    \"<__NSGlobalBlock__: 0x1086f90c0>\"\n)\n2018-05-19 15:20:27.839131+0800 NSOperation练习[1882:431333] block 2 <NSThread: 0x60000027bbc0>{number = 3, name = (null)}\n2018-05-19 15:20:27.839133+0800 NSOperation练习[1882:431330] block 1 <NSThread: 0x604000466fc0>{number = 4, name = (null)}\n```\n### 线程间通讯\n``` Objc\n- (void)demo7{\n\t[[NSOperationQueue new] addOperationWithBlock:^{\n\t\tNSLog(@\"consuming time：%@\",[NSThread currentThread]);\n\t\t/// 回到主线程刷新UI\n\t\t[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\t\t\tNSLog(@\"refresh ui: %@\",[NSThread currentThread]);\n\t\t}];\n\t}];\n}\n```\n### 监听block执行完成\n```Objc\n- (void)demo13 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n        for (NSInteger i=0; i<5; ++i) {\n            NSLog(@\"%zd %@\",i,[NSThread currentThread]);\n        }\n    }];\n    //设置监听操作执行完成的block，必须要在把操作添加到队列之前设置\n    [op setCompletionBlock:^{\n        NSLog(@\"setCompletionBlock  %@\",[NSThread currentThread]);\n    }];\n    [[NSOperationQueue new]addOperation:op];\n}\n```\n输出结果：\n```console\n2018-05-19 16:12:00.170053+0800 NSOperation练习[2607:585084] 0 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.170267+0800 NSOperation练习[2607:585084] 1 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.170410+0800 NSOperation练习[2607:585084] 2 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171319+0800 NSOperation练习[2607:585084] 3 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171538+0800 NSOperation练习[2607:585084] 4 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171816+0800 NSOperation练习[2607:585083] setCompletionBlock  <NSThread: 0x60000027bd40>{number = 4, name = (null)}\n```\n## 自定义NSOperation\n\n### 自定义类继承NSOperation\n```Objc\n@interface CustomOperation : NSOperation\n\n@end\n```\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    DownloadOperation * op = [[DownloadOperation alloc]init];\n    [queue addOperation:op];\n}\n```\n\n### 重写main方法\n任何操作在执行时,首先会调用start方法,start方法会更新操作的状态(过滤操作)；经start方法过滤之后，只有正常可执行的操作，就会调用这个main方法，重写操作的入口方法(main方法)，就可以在这个方法里面指定操作执行的任务。`main`方法默认在子线程中异步执行\n```Objc\n- (void)main\n{\n\t\t//在这个方法中做想要做的操作，即自定义 NSOperation的目的\n    NSLog(@\"%@\",self.URLString,[NSThread currentThread]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# NSOperationQueue\n![](/images/nsopration_add_to_queue.png)\n## 使用\n`NSOperationQueue`只有一种类型，就是并发队列。在开发使用到`NSOperationQueue`时，建议将其定义为`全局`队列。\n```Objc\n// 定义为属性\n@property (nonatomic,strong) NSOperationQueue *queue;\n\n- (NSOperationQueue * )queue\n{\n    if (self.queue == nil) {\n        self.queue = [[NSOperationQueue alloc] init];\n    }\n    return self.queue;\n}\n```\n## 最大并发数\n![](/imagesnsopration_queue_maxium.png)\n`maxConcurrentOperationCount`是队列的一个属性，可以限制队列`同时执行`的任务数量，从而间接的控制了线程数量(线程可以复用)，但队列最大并发数不是线程数。如果队列最大并发数设置为`1`，那么队列实际上就是一个串行队列了。\n```Objc\n\t// 设置最大并发数 : 每次只能调度两个操作执行\n\tqueue.maxConcurrentOperationCount = 2;\n```\n\n## 验证队列的并发性\n### NSOperationQueue & NSInvocationOperation\n```Objc\n- (void)demo8 {\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    for (NSInteger i=0; i<10; ++i) {\n        NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(operationTask:) object:@(i)];\n        [queue addOperation:op];\n    }\n}\n```\n输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&异步执行效果一样，说明`NSOperationQueue`默认是并发执行\n``` console\n2018-05-19 15:01:47.478515+0800 NSOperation练习[1593:358939] <NSThread: 0x60400047a580>{number = 3, name = (null)}\n2018-05-19 15:01:47.478518+0800 NSOperation练习[1593:358938] <NSThread: 0x600000263680>{number = 4, name = (null)}\n2018-05-19 15:01:47.478519+0800 NSOperation练习[1593:358936] <NSThread: 0x60400047a500>{number = 6, name = (null)}\n2018-05-19 15:01:47.478572+0800 NSOperation练习[1593:358935] <NSThread: 0x60400047a640>{number = 5, name = (null)}\n2018-05-19 15:01:47.478740+0800 NSOperation练习[1593:358974] <NSThread: 0x600000263a40>{number = 7, name = (null)}\n2018-05-19 15:01:47.478881+0800 NSOperation练习[1593:358938] <NSThread: 0x600000263680>{number = 4, name = (null)}\n2018-05-19 15:01:47.478902+0800 NSOperation练习[1593:358939] <NSThread: 0x60400047a580>{number = 3, name = (null)}\n2018-05-19 15:01:47.479084+0800 NSOperation练习[1593:358975] <NSThread: 0x6000002636c0>{number = 8, name = (null)}\n2018-05-19 15:01:47.479096+0800 NSOperation练习[1593:358976] <NSThread: 0x600000263d00>{number = 10, name = (null)}\n2018-05-19 15:01:47.479128+0800 NSOperation练习[1593:358977] <NSThread: 0x600000263dc0>{number = 9, name = (null)}\n```\n### NSOperationQueue & NSBlockOperation\n```Objc\n- (void)demo10 {\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    for (NSInteger i=0; i<10; ++i) {\n        NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n            NSLog(@\"%@\",[NSThread currentThread]);\n        }];\n        [queue addOperation:op];\n    }\n}\n```\n输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&异步执行效果一样，说明`NSOperationQueue`默认是并发执行\n``` console\n2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456384] <NSThread: 0x60000027ef80>{number = 5, name = (null)}\n2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456319] <NSThread: 0x604000468dc0>{number = 4, name = (null)}\n2018-05-19 15:26:52.141569+0800 NSOperation练习[1984:456314] <NSThread: 0x60000027f040>{number = 3, name = (null)}\n2018-05-19 15:26:52.141641+0800 NSOperation练习[1984:456313] <NSThread: 0x604000469d80>{number = 6, name = (null)}\n2018-05-19 15:26:52.141661+0800 NSOperation练习[1984:456385] <NSThread: 0x60000027ee80>{number = 8, name = (null)}\n2018-05-19 15:26:52.141676+0800 NSOperation练习[1984:456318] <NSThread: 0x604000469c40>{number = 7, name = (null)}\n2018-05-19 15:26:52.141928+0800 NSOperation练习[1984:456384] <NSThread: 0x60000027ef80>{number = 5, name = (null)}\n2018-05-19 15:26:52.141945+0800 NSOperation练习[1984:456319] <NSThread: 0x604000468dc0>{number = 4, name = (null)}\n2018-05-19 15:26:52.141954+0800 NSOperation练习[1984:456314] <NSThread: 0x60000027f040>{number = 3, name = (null)}\n2018-05-19 15:26:52.142048+0800 NSOperation练习[1984:456386] <NSThread: 0x60000027f380>{number = 9, name = (null)}\n```\n## 队列暂停继续和取消全部\n### isSuspended:\n暂停和继续队列的属性；YES代表暂停队列，NO代表恢复队列。将队列挂起之后，队列中的操作就不会被调度，但是正在执行的操作不受影响\n`operationCount`: 操作计数,没有执行和没有执行完的操作,都会计算在操作计数之内\n > 注意 : 如果先暂停队列,再添加操作到队列,队列不会调度操作执行.所以在暂停队列之前要判断队列中有没有任务.如果没有操作就不暂停队列.\n\n```Objc\n#pragma mark - 演示队列的暂停\n- (IBAction)pause:(id)sender\n{\n    // 暂停队列之前判断队列中有无操作\n    if (self.queue.operationCount == 0) {\n        return;\n    }\n\n    // 暂停队列\n    self.queue.suspended = YES;\n    NSLog(@\"pause %zd\",self.queue.operationCount);\n}\n```\n### cancelAllOperations:\n取消队列中的全部操作；旦调用的 `cancelAllOperations`方法，队列中的操作，都会被移除，正在执行的操作除外；正在执行的操作取消不了，如果要取消，需要自定义NSOperation；队列取消全部操作时，会有一定的时间延迟。\n```Objc\n- (IBAction)cancelAll:(id)sender\n{\n    [self.queue cancelAllOperations];\n    NSLog(@\"cancelAll %zd\",self.queue.operationCount);\n}\n```\n# qualityOfService\n服务质量的枚举：\n```Objc\ntypedef NS_ENUM(NSInteger, NSQualityOfService) {\n    NSQualityOfServiceUserInteractive = 0x21,\n    NSQualityOfServiceUserInitiated = 0x19,\n    NSQualityOfServiceUtility = 0x11,\n    NSQualityOfServiceBackground = 0x09,\n    NSQualityOfServiceDefault = -1\n} API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));\n```\n## operation\n让队列里面的操作有更多的机会被队列调度执行，类似于线程优先级\n```Objc\n- (void)demo11 {\n    NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"op1 block %@\",[NSThread currentThread]);\n    }];\n    for (NSInteger i=0; i<5; ++i) {\n        [op1 addExecutionBlock:^{\n           NSLog(@\"opt1 %@\",[NSThread currentThread]);\n        }];\n    }\n    op1.qualityOfService = NSQualityOfServiceBackground;\n\n    NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"op2 block %@\",[NSThread currentThread]);\n    }];\n    for (NSInteger i=0; i<5; ++i) {\n        [op2 addExecutionBlock:^{\n            NSLog(@\"opt2 %@\",[NSThread currentThread]);\n        }];\n    }\n\n    op2.qualityOfService = NSQualityOfServiceUserInteractive;\n\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperations:@[op1,op2] waitUntilFinished:false];\n}\n```\n输出结果：op2优先于op1执行\n```console\n2018-05-19 16:05:46.292652+0800 NSOperation练习[2511:564443] op2 block <NSThread: 0x600000278580>{number = 4, name = (null)}\n2018-05-19 16:05:46.292656+0800 NSOperation练习[2511:564453] opt2 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.292654+0800 NSOperation练习[2511:564445] opt2 <NSThread: 0x604000470ac0>{number = 6, name = (null)}\n2018-05-19 16:05:46.292709+0800 NSOperation练习[2511:564454] opt2 <NSThread: 0x604000470c40>{number = 8, name = (null)}\n2018-05-19 16:05:46.292933+0800 NSOperation练习[2511:564453] opt2 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.292937+0800 NSOperation练习[2511:564443] opt2 <NSThread: 0x600000278580>{number = 4, name = (null)}\n2018-05-19 16:05:46.292944+0800 NSOperation练习[2511:564446] opt1 <NSThread: 0x604000470b00>{number = 5, name = (null)}\n2018-05-19 16:05:46.292960+0800 NSOperation练习[2511:564444] op1 block <NSThread: 0x604000470b80>{number = 3, name = (null)}\n2018-05-19 16:05:46.293083+0800 NSOperation练习[2511:564454] opt1 <NSThread: 0x604000470c40>{number = 8, name = (null)}\n2018-05-19 16:05:46.293089+0800 NSOperation练习[2511:564453] opt1 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.294076+0800 NSOperation练习[2511:564446] opt1 <NSThread: 0x604000470b00>{number = 5, name = (null)}\n2018-05-19 16:05:46.294207+0800 NSOperation练习[2511:564444] opt1 <NSThread: 0x604000470b80>{number = 3, name = (null)}\n```\n## queue\n```Objc\n- (void)demo12 {\n    NSOperationQueue * q1 = [[NSOperationQueue alloc]init];\n    NSOperationQueue * q2 = [[NSOperationQueue alloc]init];\n\n    q1.qualityOfService = NSQualityOfServiceBackground;\n    q2.qualityOfService = NSQualityOfServiceUserInteractive;\n\n    for (NSInteger i=0; i<5; ++i) {\n        [q1 addOperationWithBlock:^{\n           NSLog(@\"q1\");\n        }];\n        [q2 addOperationWithBlock:^{\n            NSLog(@\"q2\");\n        }];\n    }\n}\n```\n输出结果：q2优先于q1执行\n```console\n2018-05-19 16:05:11.965991+0800 NSOperation练习[2487:561497] q2 <NSThread: 0x604000274e00>{number = 4, name = (null)}\n2018-05-19 16:05:11.965998+0800 NSOperation练习[2487:561496] q2 <NSThread: 0x600000275740>{number = 3, name = (null)}\n2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561516] q2 <NSThread: 0x600000275940>{number = 5, name = (null)}\n2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561517] q2 <NSThread: 0x604000274f80>{number = 6, name = (null)}\n2018-05-19 16:05:11.966316+0800 NSOperation练习[2487:561516] q2 <NSThread: 0x600000275940>{number = 5, name = (null)}\n2018-05-19 16:05:11.968284+0800 NSOperation练习[2487:561494] q1 <NSThread: 0x600000263840>{number = 7, name = (null)}\n2018-05-19 16:05:11.968303+0800 NSOperation练习[2487:561495] q1 <NSThread: 0x604000275680>{number = 8, name = (null)}\n2018-05-19 16:05:11.968376+0800 NSOperation练习[2487:561517] q1 <NSThread: 0x604000274f80>{number = 6, name = (null)}\n2018-05-19 16:05:11.968409+0800 NSOperation练习[2487:561496] q1 <NSThread: 0x600000275740>{number = 3, name = (null)}\n2018-05-19 16:05:11.969839+0800 NSOperation练习[2487:561494] q1 <NSThread: 0x600000263840>{number = 7, name = (null)}\n```\n# 支持KVO的属性\n```\nisCancelled - read-only   //是否取消\n\nisAsynchronous - read-only //是否异步\n\nisExecuting - read-only  //是否正在执行\n\nisFinished - read-only\t//是否结束\n\nisReady - read-only\t//是否就绪\n\ndependencies - read-only\t//依赖的其他的操作\n\nqueuePriority - readable and writable\t//队列优先级\n\ncompletionBlock - readable and writable\t//结束回调\n```\n\n# 操作间依赖\n## 需求实例\n场景：用户需要先登录->付费->下载->通知用户\n```Objc\n- (void)dependency\n{\n    NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"login %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"pay %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"download %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op4 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"notice user %@\",[NSThread currentThread]);\n    }];\n}\n```\n## 添加依赖\n```Objc\n[op2 addDependency:op1]; // 操作2依赖于操作1\n[op3 addDependency:op2]; // 操作3依赖于操作2\n[op4 addDependency:op3]; // 操作4依赖于操作3\n\n// waitUntilFinished : 是否等到指定的操作执行结束再执行后面的代码\n[self.queue addOperations:@[op1,op2,op3] waitUntilFinished:NO];\n\n// 通知用户的操作在主线程中执行\n[[NSOperationQueue mainQueue] addOperation:op4];\n\n// 验证 waitUntilFinished\nNSLog(@\"end\");\n```\n## 小结\n- 不能循环建立操作间依赖关系.否则,队列不调度操作执行\n- 操作间可以跨队列建立依赖关系\n- 要将操作间的依赖建立好了之后,再添加到队列中（先建立操作依赖关系，再把操作添加到队列）\n\n# NSOperation和GCD的区别\n![](/images/gcd_and_nop_relationship.png)\n## GCD\nGCD `iOS 4.0` 推出，针对多核处理器的并发技术。GCD属于C语言的框架。将任务封装在block中，如果要停止已经加入 队列(queue) 的 任务(block) 需要写复杂的代码。只能设置队列的优先级不能设置任务的优先级。\n### 高级功能\n- barrier\n- once\n- after\n- group\n\n## NSOperation\nNSOperation `iOS 2.0` 推出，但在苹果推出 GCD 之后，对NSOperation的底层全部重写。NSOperation属于OC 框架，更加面向对象，底层是对 GCD 的封装。支持取消掉队列中的任务(正在执行的除外)，还可以设置队列中每个操作的优先级\n### 高级功能\n- 最大操作并发数(GCD不好做)\n- 继续/暂停/全部取消\n- 跨队列设置操作的依赖关系\n","source":"_posts/ios-thread-nsoperation.md","raw":"---\ntitle: iOS - 多线程之 NSOperation\ndate: 2018-04-29 17:14:05\ntags: [iOS,Objc,Thread,NSOperation]\ncategories: [iOS,Objc]\n---\n\n# NSOperation\napple提供的多线程解决方案`NSOperation`是一个表示与单个任务关联的代码和数据的抽象类；因为是一个抽象类，所以不能直接使用，需要使用它的两个子类(`NSInvocationOperation` or `NSBlockOperation`) 去执行实际的操作任务；同样我们也可以通过自定义NSOperation。通常将操作添加到操作队列（`NSOperationQueue`类的实例）来执行操作。其实`NSOperation`就是对`GCD`的封装，相对于GCD来说可控性更强，并且可以加入操作依赖（`addDependency:` and `removeDependency`）。\n\n## NSInvocationOperation\n### start\n```Objc\n- (void)demo1 {\n    NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"];\n    [op start];\n}\n\n- (void)operationTask:(id)param {\n    NSLog(@\"%@\",[NSThread currentThread]);\n}\n```\n输出结果：发现在主线程中输出的结果，但`start`方法是在`当前线程`中执行的\n``` console\n2018-05-19 14:45:07.956558+0800 NSOperation练习[1324:290009] <NSThread: 0x604000078000>{number = 1, name = main}\n```\n### 将操作添加到队列\n```Objc\n- (void)demo2 {\n\tNSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(oprationTask:) object:@\"InvocationOperation\"];\n\tNSOperationQueue * queue = [[NSOperationQueue alloc]init];\n\t[queue addOperation:op];\n}\n```\n输出结果：开启子线程异步执行\n``` console\n2018-05-19 14:50:53.013010+0800 NSOperation练习[1408:312296] <NSThread: 0x60400046b600>{number = 3, name = (null)}\n```\n\n## NSBlockOperation (使用较多)\n### start\n```Objc\n- (void)demo4 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"%@\",[NSThread currentThread]);\n    }];\n    [op start];\n}\n```\n输出结果：`start`方法是在`当前线程`中执行\n```console\n2018-05-19 15:06:11.837276+0800 NSOperation练习[1661:375754] <NSThread: 0x6000000745c0>{number = 1, name = main}\n```\n### 将操作添加到队列\n```Objc\n- (void)demo5 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"%@\",[NSThread currentThread]);\n    }];\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperation:op];\n}\n```\n输出结果：开启子线程异步执行\n```console\n2018-05-19 15:10:23.974301+0800 NSOperation练习[1720:389949] <NSThread: 0x60400027ea40>{number = 3, name = (null)}\n```\n### 执行块\n```Objc\n- (void)demo6 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"block 2 %@\", [NSThread currentThread]);\n    }];\n\n    [op addExecutionBlock:^{\n        NSLog(@\"block 1 %@\", [NSThread currentThread]);\n    }];\n\n\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperation:op];\n\n    NSLog(@\"%@\", op.executionBlocks);\n}\n```\n输出结果：执行块和操作享有共同的属性设置，异步执行\n```console\n2018-05-19 15:20:27.839119+0800 NSOperation练习[1882:431125] (\n    \"<__NSGlobalBlock__: 0x1086f9080>\",\n    \"<__NSGlobalBlock__: 0x1086f90c0>\"\n)\n2018-05-19 15:20:27.839131+0800 NSOperation练习[1882:431333] block 2 <NSThread: 0x60000027bbc0>{number = 3, name = (null)}\n2018-05-19 15:20:27.839133+0800 NSOperation练习[1882:431330] block 1 <NSThread: 0x604000466fc0>{number = 4, name = (null)}\n```\n### 线程间通讯\n``` Objc\n- (void)demo7{\n\t[[NSOperationQueue new] addOperationWithBlock:^{\n\t\tNSLog(@\"consuming time：%@\",[NSThread currentThread]);\n\t\t/// 回到主线程刷新UI\n\t\t[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\t\t\tNSLog(@\"refresh ui: %@\",[NSThread currentThread]);\n\t\t}];\n\t}];\n}\n```\n### 监听block执行完成\n```Objc\n- (void)demo13 {\n    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n        for (NSInteger i=0; i<5; ++i) {\n            NSLog(@\"%zd %@\",i,[NSThread currentThread]);\n        }\n    }];\n    //设置监听操作执行完成的block，必须要在把操作添加到队列之前设置\n    [op setCompletionBlock:^{\n        NSLog(@\"setCompletionBlock  %@\",[NSThread currentThread]);\n    }];\n    [[NSOperationQueue new]addOperation:op];\n}\n```\n输出结果：\n```console\n2018-05-19 16:12:00.170053+0800 NSOperation练习[2607:585084] 0 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.170267+0800 NSOperation练习[2607:585084] 1 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.170410+0800 NSOperation练习[2607:585084] 2 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171319+0800 NSOperation练习[2607:585084] 3 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171538+0800 NSOperation练习[2607:585084] 4 <NSThread: 0x60000027bd80>{number = 3, name = (null)}\n2018-05-19 16:12:00.171816+0800 NSOperation练习[2607:585083] setCompletionBlock  <NSThread: 0x60000027bd40>{number = 4, name = (null)}\n```\n## 自定义NSOperation\n\n### 自定义类继承NSOperation\n```Objc\n@interface CustomOperation : NSOperation\n\n@end\n```\n```Objc\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    DownloadOperation * op = [[DownloadOperation alloc]init];\n    [queue addOperation:op];\n}\n```\n\n### 重写main方法\n任何操作在执行时,首先会调用start方法,start方法会更新操作的状态(过滤操作)；经start方法过滤之后，只有正常可执行的操作，就会调用这个main方法，重写操作的入口方法(main方法)，就可以在这个方法里面指定操作执行的任务。`main`方法默认在子线程中异步执行\n```Objc\n- (void)main\n{\n\t\t//在这个方法中做想要做的操作，即自定义 NSOperation的目的\n    NSLog(@\"%@\",self.URLString,[NSThread currentThread]);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# NSOperationQueue\n![](/images/nsopration_add_to_queue.png)\n## 使用\n`NSOperationQueue`只有一种类型，就是并发队列。在开发使用到`NSOperationQueue`时，建议将其定义为`全局`队列。\n```Objc\n// 定义为属性\n@property (nonatomic,strong) NSOperationQueue *queue;\n\n- (NSOperationQueue * )queue\n{\n    if (self.queue == nil) {\n        self.queue = [[NSOperationQueue alloc] init];\n    }\n    return self.queue;\n}\n```\n## 最大并发数\n![](/imagesnsopration_queue_maxium.png)\n`maxConcurrentOperationCount`是队列的一个属性，可以限制队列`同时执行`的任务数量，从而间接的控制了线程数量(线程可以复用)，但队列最大并发数不是线程数。如果队列最大并发数设置为`1`，那么队列实际上就是一个串行队列了。\n```Objc\n\t// 设置最大并发数 : 每次只能调度两个操作执行\n\tqueue.maxConcurrentOperationCount = 2;\n```\n\n## 验证队列的并发性\n### NSOperationQueue & NSInvocationOperation\n```Objc\n- (void)demo8 {\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    for (NSInteger i=0; i<10; ++i) {\n        NSInvocationOperation * op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(operationTask:) object:@(i)];\n        [queue addOperation:op];\n    }\n}\n```\n输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&异步执行效果一样，说明`NSOperationQueue`默认是并发执行\n``` console\n2018-05-19 15:01:47.478515+0800 NSOperation练习[1593:358939] <NSThread: 0x60400047a580>{number = 3, name = (null)}\n2018-05-19 15:01:47.478518+0800 NSOperation练习[1593:358938] <NSThread: 0x600000263680>{number = 4, name = (null)}\n2018-05-19 15:01:47.478519+0800 NSOperation练习[1593:358936] <NSThread: 0x60400047a500>{number = 6, name = (null)}\n2018-05-19 15:01:47.478572+0800 NSOperation练习[1593:358935] <NSThread: 0x60400047a640>{number = 5, name = (null)}\n2018-05-19 15:01:47.478740+0800 NSOperation练习[1593:358974] <NSThread: 0x600000263a40>{number = 7, name = (null)}\n2018-05-19 15:01:47.478881+0800 NSOperation练习[1593:358938] <NSThread: 0x600000263680>{number = 4, name = (null)}\n2018-05-19 15:01:47.478902+0800 NSOperation练习[1593:358939] <NSThread: 0x60400047a580>{number = 3, name = (null)}\n2018-05-19 15:01:47.479084+0800 NSOperation练习[1593:358975] <NSThread: 0x6000002636c0>{number = 8, name = (null)}\n2018-05-19 15:01:47.479096+0800 NSOperation练习[1593:358976] <NSThread: 0x600000263d00>{number = 10, name = (null)}\n2018-05-19 15:01:47.479128+0800 NSOperation练习[1593:358977] <NSThread: 0x600000263dc0>{number = 9, name = (null)}\n```\n### NSOperationQueue & NSBlockOperation\n```Objc\n- (void)demo10 {\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    for (NSInteger i=0; i<10; ++i) {\n        NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{\n            NSLog(@\"%@\",[NSThread currentThread]);\n        }];\n        [queue addOperation:op];\n    }\n}\n```\n输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&异步执行效果一样，说明`NSOperationQueue`默认是并发执行\n``` console\n2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456384] <NSThread: 0x60000027ef80>{number = 5, name = (null)}\n2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456319] <NSThread: 0x604000468dc0>{number = 4, name = (null)}\n2018-05-19 15:26:52.141569+0800 NSOperation练习[1984:456314] <NSThread: 0x60000027f040>{number = 3, name = (null)}\n2018-05-19 15:26:52.141641+0800 NSOperation练习[1984:456313] <NSThread: 0x604000469d80>{number = 6, name = (null)}\n2018-05-19 15:26:52.141661+0800 NSOperation练习[1984:456385] <NSThread: 0x60000027ee80>{number = 8, name = (null)}\n2018-05-19 15:26:52.141676+0800 NSOperation练习[1984:456318] <NSThread: 0x604000469c40>{number = 7, name = (null)}\n2018-05-19 15:26:52.141928+0800 NSOperation练习[1984:456384] <NSThread: 0x60000027ef80>{number = 5, name = (null)}\n2018-05-19 15:26:52.141945+0800 NSOperation练习[1984:456319] <NSThread: 0x604000468dc0>{number = 4, name = (null)}\n2018-05-19 15:26:52.141954+0800 NSOperation练习[1984:456314] <NSThread: 0x60000027f040>{number = 3, name = (null)}\n2018-05-19 15:26:52.142048+0800 NSOperation练习[1984:456386] <NSThread: 0x60000027f380>{number = 9, name = (null)}\n```\n## 队列暂停继续和取消全部\n### isSuspended:\n暂停和继续队列的属性；YES代表暂停队列，NO代表恢复队列。将队列挂起之后，队列中的操作就不会被调度，但是正在执行的操作不受影响\n`operationCount`: 操作计数,没有执行和没有执行完的操作,都会计算在操作计数之内\n > 注意 : 如果先暂停队列,再添加操作到队列,队列不会调度操作执行.所以在暂停队列之前要判断队列中有没有任务.如果没有操作就不暂停队列.\n\n```Objc\n#pragma mark - 演示队列的暂停\n- (IBAction)pause:(id)sender\n{\n    // 暂停队列之前判断队列中有无操作\n    if (self.queue.operationCount == 0) {\n        return;\n    }\n\n    // 暂停队列\n    self.queue.suspended = YES;\n    NSLog(@\"pause %zd\",self.queue.operationCount);\n}\n```\n### cancelAllOperations:\n取消队列中的全部操作；旦调用的 `cancelAllOperations`方法，队列中的操作，都会被移除，正在执行的操作除外；正在执行的操作取消不了，如果要取消，需要自定义NSOperation；队列取消全部操作时，会有一定的时间延迟。\n```Objc\n- (IBAction)cancelAll:(id)sender\n{\n    [self.queue cancelAllOperations];\n    NSLog(@\"cancelAll %zd\",self.queue.operationCount);\n}\n```\n# qualityOfService\n服务质量的枚举：\n```Objc\ntypedef NS_ENUM(NSInteger, NSQualityOfService) {\n    NSQualityOfServiceUserInteractive = 0x21,\n    NSQualityOfServiceUserInitiated = 0x19,\n    NSQualityOfServiceUtility = 0x11,\n    NSQualityOfServiceBackground = 0x09,\n    NSQualityOfServiceDefault = -1\n} API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));\n```\n## operation\n让队列里面的操作有更多的机会被队列调度执行，类似于线程优先级\n```Objc\n- (void)demo11 {\n    NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^{\n       NSLog(@\"op1 block %@\",[NSThread currentThread]);\n    }];\n    for (NSInteger i=0; i<5; ++i) {\n        [op1 addExecutionBlock:^{\n           NSLog(@\"opt1 %@\",[NSThread currentThread]);\n        }];\n    }\n    op1.qualityOfService = NSQualityOfServiceBackground;\n\n    NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"op2 block %@\",[NSThread currentThread]);\n    }];\n    for (NSInteger i=0; i<5; ++i) {\n        [op2 addExecutionBlock:^{\n            NSLog(@\"opt2 %@\",[NSThread currentThread]);\n        }];\n    }\n\n    op2.qualityOfService = NSQualityOfServiceUserInteractive;\n\n    NSOperationQueue * queue = [[NSOperationQueue alloc]init];\n    [queue addOperations:@[op1,op2] waitUntilFinished:false];\n}\n```\n输出结果：op2优先于op1执行\n```console\n2018-05-19 16:05:46.292652+0800 NSOperation练习[2511:564443] op2 block <NSThread: 0x600000278580>{number = 4, name = (null)}\n2018-05-19 16:05:46.292656+0800 NSOperation练习[2511:564453] opt2 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.292654+0800 NSOperation练习[2511:564445] opt2 <NSThread: 0x604000470ac0>{number = 6, name = (null)}\n2018-05-19 16:05:46.292709+0800 NSOperation练习[2511:564454] opt2 <NSThread: 0x604000470c40>{number = 8, name = (null)}\n2018-05-19 16:05:46.292933+0800 NSOperation练习[2511:564453] opt2 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.292937+0800 NSOperation练习[2511:564443] opt2 <NSThread: 0x600000278580>{number = 4, name = (null)}\n2018-05-19 16:05:46.292944+0800 NSOperation练习[2511:564446] opt1 <NSThread: 0x604000470b00>{number = 5, name = (null)}\n2018-05-19 16:05:46.292960+0800 NSOperation练习[2511:564444] op1 block <NSThread: 0x604000470b80>{number = 3, name = (null)}\n2018-05-19 16:05:46.293083+0800 NSOperation练习[2511:564454] opt1 <NSThread: 0x604000470c40>{number = 8, name = (null)}\n2018-05-19 16:05:46.293089+0800 NSOperation练习[2511:564453] opt1 <NSThread: 0x600000278680>{number = 7, name = (null)}\n2018-05-19 16:05:46.294076+0800 NSOperation练习[2511:564446] opt1 <NSThread: 0x604000470b00>{number = 5, name = (null)}\n2018-05-19 16:05:46.294207+0800 NSOperation练习[2511:564444] opt1 <NSThread: 0x604000470b80>{number = 3, name = (null)}\n```\n## queue\n```Objc\n- (void)demo12 {\n    NSOperationQueue * q1 = [[NSOperationQueue alloc]init];\n    NSOperationQueue * q2 = [[NSOperationQueue alloc]init];\n\n    q1.qualityOfService = NSQualityOfServiceBackground;\n    q2.qualityOfService = NSQualityOfServiceUserInteractive;\n\n    for (NSInteger i=0; i<5; ++i) {\n        [q1 addOperationWithBlock:^{\n           NSLog(@\"q1\");\n        }];\n        [q2 addOperationWithBlock:^{\n            NSLog(@\"q2\");\n        }];\n    }\n}\n```\n输出结果：q2优先于q1执行\n```console\n2018-05-19 16:05:11.965991+0800 NSOperation练习[2487:561497] q2 <NSThread: 0x604000274e00>{number = 4, name = (null)}\n2018-05-19 16:05:11.965998+0800 NSOperation练习[2487:561496] q2 <NSThread: 0x600000275740>{number = 3, name = (null)}\n2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561516] q2 <NSThread: 0x600000275940>{number = 5, name = (null)}\n2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561517] q2 <NSThread: 0x604000274f80>{number = 6, name = (null)}\n2018-05-19 16:05:11.966316+0800 NSOperation练习[2487:561516] q2 <NSThread: 0x600000275940>{number = 5, name = (null)}\n2018-05-19 16:05:11.968284+0800 NSOperation练习[2487:561494] q1 <NSThread: 0x600000263840>{number = 7, name = (null)}\n2018-05-19 16:05:11.968303+0800 NSOperation练习[2487:561495] q1 <NSThread: 0x604000275680>{number = 8, name = (null)}\n2018-05-19 16:05:11.968376+0800 NSOperation练习[2487:561517] q1 <NSThread: 0x604000274f80>{number = 6, name = (null)}\n2018-05-19 16:05:11.968409+0800 NSOperation练习[2487:561496] q1 <NSThread: 0x600000275740>{number = 3, name = (null)}\n2018-05-19 16:05:11.969839+0800 NSOperation练习[2487:561494] q1 <NSThread: 0x600000263840>{number = 7, name = (null)}\n```\n# 支持KVO的属性\n```\nisCancelled - read-only   //是否取消\n\nisAsynchronous - read-only //是否异步\n\nisExecuting - read-only  //是否正在执行\n\nisFinished - read-only\t//是否结束\n\nisReady - read-only\t//是否就绪\n\ndependencies - read-only\t//依赖的其他的操作\n\nqueuePriority - readable and writable\t//队列优先级\n\ncompletionBlock - readable and writable\t//结束回调\n```\n\n# 操作间依赖\n## 需求实例\n场景：用户需要先登录->付费->下载->通知用户\n```Objc\n- (void)dependency\n{\n    NSBlockOperation * op1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"login %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"pay %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"download %@\",[NSThread currentThread]);\n    }];\n\n    NSBlockOperation * op4 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"notice user %@\",[NSThread currentThread]);\n    }];\n}\n```\n## 添加依赖\n```Objc\n[op2 addDependency:op1]; // 操作2依赖于操作1\n[op3 addDependency:op2]; // 操作3依赖于操作2\n[op4 addDependency:op3]; // 操作4依赖于操作3\n\n// waitUntilFinished : 是否等到指定的操作执行结束再执行后面的代码\n[self.queue addOperations:@[op1,op2,op3] waitUntilFinished:NO];\n\n// 通知用户的操作在主线程中执行\n[[NSOperationQueue mainQueue] addOperation:op4];\n\n// 验证 waitUntilFinished\nNSLog(@\"end\");\n```\n## 小结\n- 不能循环建立操作间依赖关系.否则,队列不调度操作执行\n- 操作间可以跨队列建立依赖关系\n- 要将操作间的依赖建立好了之后,再添加到队列中（先建立操作依赖关系，再把操作添加到队列）\n\n# NSOperation和GCD的区别\n![](/images/gcd_and_nop_relationship.png)\n## GCD\nGCD `iOS 4.0` 推出，针对多核处理器的并发技术。GCD属于C语言的框架。将任务封装在block中，如果要停止已经加入 队列(queue) 的 任务(block) 需要写复杂的代码。只能设置队列的优先级不能设置任务的优先级。\n### 高级功能\n- barrier\n- once\n- after\n- group\n\n## NSOperation\nNSOperation `iOS 2.0` 推出，但在苹果推出 GCD 之后，对NSOperation的底层全部重写。NSOperation属于OC 框架，更加面向对象，底层是对 GCD 的封装。支持取消掉队列中的任务(正在执行的除外)，还可以设置队列中每个操作的优先级\n### 高级功能\n- 最大操作并发数(GCD不好做)\n- 继续/暂停/全部取消\n- 跨队列设置操作的依赖关系\n","slug":"ios-thread-nsoperation","published":1,"updated":"2019-01-13T05:10:17.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2w001wl1fqxjgjot8h","content":"<h1 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h1><p>apple提供的多线程解决方案<code>NSOperation</code>是一个表示与单个任务关联的代码和数据的抽象类；因为是一个抽象类，所以不能直接使用，需要使用它的两个子类(<code>NSInvocationOperation</code> or <code>NSBlockOperation</code>) 去执行实际的操作任务；同样我们也可以通过自定义NSOperation。通常将操作添加到操作队列（<code>NSOperationQueue</code>类的实例）来执行操作。其实<code>NSOperation</code>就是对<code>GCD</code>的封装，相对于GCD来说可控性更强，并且可以加入操作依赖（<code>addDependency:</code> and <code>removeDependency</code>）。</p>\n<h2 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h2><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oprationTask:) object:<span class=\"string\">@\"InvocationOperation\"</span>];</span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operationTask:(<span class=\"keyword\">id</span>)param &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：发现在主线程中输出的结果，但<code>start</code>方法是在<code>当前线程</code>中执行的<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 14:45:07.956558+0800 NSOperation练习[1324:290009] &lt;NSThread: 0x604000078000&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"将操作添加到队列\"><a href=\"#将操作添加到队列\" class=\"headerlink\" title=\"将操作添加到队列\"></a>将操作添加到队列</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo2 &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oprationTask:) object:<span class=\"string\">@\"InvocationOperation\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">\t[queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：开启子线程异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 14:50:53.013010+0800 NSOperation练习[1408:312296] &lt;NSThread: 0x60400046b600&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"NSBlockOperation-使用较多\"><a href=\"#NSBlockOperation-使用较多\" class=\"headerlink\" title=\"NSBlockOperation (使用较多)\"></a>NSBlockOperation (使用较多)</h2><h3 id=\"start-1\"><a href=\"#start-1\" class=\"headerlink\" title=\"start\"></a>start</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo4 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<code>start</code>方法是在<code>当前线程</code>中执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:06:11.837276+0800 NSOperation练习[1661:375754] &lt;NSThread: 0x6000000745c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"将操作添加到队列-1\"><a href=\"#将操作添加到队列-1\" class=\"headerlink\" title=\"将操作添加到队列\"></a>将操作添加到队列</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo5 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：开启子线程异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:10:23.974301+0800 NSOperation练习[1720:389949] &lt;NSThread: 0x60400027ea40&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"执行块\"><a href=\"#执行块\" class=\"headerlink\" title=\"执行块\"></a>执行块</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo6 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block 2 %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block 1 %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, op.executionBlocks);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：执行块和操作享有共同的属性设置，异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:20:27.839119+0800 NSOperation练习[1882:431125] (</span><br><span class=\"line\">    \"&lt;__NSGlobalBlock__: 0x1086f9080&gt;\",</span><br><span class=\"line\">    \"&lt;__NSGlobalBlock__: 0x1086f90c0&gt;\"</span><br><span class=\"line\">)</span><br><span class=\"line\">2018-05-19 15:20:27.839131+0800 NSOperation练习[1882:431333] block 2 &lt;NSThread: 0x60000027bbc0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:20:27.839133+0800 NSOperation练习[1882:431330] block 1 &lt;NSThread: 0x604000466fc0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"线程间通讯\"><a href=\"#线程间通讯\" class=\"headerlink\" title=\"线程间通讯\"></a>线程间通讯</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo7&#123;</span><br><span class=\"line\">\t[[<span class=\"built_in\">NSOperationQueue</span> new] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"consuming time：%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t<span class=\"comment\">/// 回到主线程刷新UI</span></span><br><span class=\"line\">\t\t[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"refresh ui: %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"监听block执行完成\"><a href=\"#监听block执行完成\" class=\"headerlink\" title=\"监听block执行完成\"></a>监听block执行完成</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo13 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd %@\"</span>,i,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">//设置监听操作执行完成的block，必须要在把操作添加到队列之前设置</span></span><br><span class=\"line\">    [op setCompletionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"setCompletionBlock  %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> new]addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:12:00.170053+0800 NSOperation练习[2607:585084] 0 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.170267+0800 NSOperation练习[2607:585084] 1 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.170410+0800 NSOperation练习[2607:585084] 2 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171319+0800 NSOperation练习[2607:585084] 3 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171538+0800 NSOperation练习[2607:585084] 4 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171816+0800 NSOperation练习[2607:585083] setCompletionBlock  &lt;NSThread: 0x60000027bd40&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义NSOperation\"><a href=\"#自定义NSOperation\" class=\"headerlink\" title=\"自定义NSOperation\"></a>自定义NSOperation</h2><h3 id=\"自定义类继承NSOperation\"><a href=\"#自定义类继承NSOperation\" class=\"headerlink\" title=\"自定义类继承NSOperation\"></a>自定义类继承NSOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> : <span class=\"title\">NSOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    DownloadOperation * op = [[DownloadOperation alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写main方法\"><a href=\"#重写main方法\" class=\"headerlink\" title=\"重写main方法\"></a>重写main方法</h3><p>任何操作在执行时,首先会调用start方法,start方法会更新操作的状态(过滤操作)；经start方法过滤之后，只有正常可执行的操作，就会调用这个main方法，重写操作的入口方法(main方法)，就可以在这个方法里面指定操作执行的任务。<code>main</code>方法默认在子线程中异步执行<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//在这个方法中做想要做的操作，即自定义 NSOperation的目的</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"keyword\">self</span>.URLString,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h1><p><img src=\"/images/nsopration_add_to_queue.png\" alt=\"\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p><code>NSOperationQueue</code>只有一种类型，就是并发队列。在开发使用到<code>NSOperationQueue</code>时，建议将其定义为<code>全局</code>队列。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义为属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> *queue;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSOperationQueue</span> * )queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"最大并发数\"><a href=\"#最大并发数\" class=\"headerlink\" title=\"最大并发数\"></a>最大并发数</h2><p><img src=\"/imagesnsopration_queue_maxium.png\" alt=\"\"><br><code>maxConcurrentOperationCount</code>是队列的一个属性，可以限制队列<code>同时执行</code>的任务数量，从而间接的控制了线程数量(线程可以复用)，但队列最大并发数不是线程数。如果队列最大并发数设置为<code>1</code>，那么队列实际上就是一个串行队列了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置最大并发数 : 每次只能调度两个操作执行</span></span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"验证队列的并发性\"><a href=\"#验证队列的并发性\" class=\"headerlink\" title=\"验证队列的并发性\"></a>验证队列的并发性</h2><h3 id=\"NSOperationQueue-amp-NSInvocationOperation\"><a href=\"#NSOperationQueue-amp-NSInvocationOperation\" class=\"headerlink\" title=\"NSOperationQueue &amp; NSInvocationOperation\"></a>NSOperationQueue &amp; NSInvocationOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo8 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(operationTask:) object:@(i)];</span><br><span class=\"line\">        [queue addOperation:op];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明<code>NSOperationQueue</code>默认是并发执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:01:47.478515+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478518+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478519+0800 NSOperation练习[1593:358936] &lt;NSThread: 0x60400047a500&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478572+0800 NSOperation练习[1593:358935] &lt;NSThread: 0x60400047a640&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478740+0800 NSOperation练习[1593:358974] &lt;NSThread: 0x600000263a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478881+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478902+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479084+0800 NSOperation练习[1593:358975] &lt;NSThread: 0x6000002636c0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479096+0800 NSOperation练习[1593:358976] &lt;NSThread: 0x600000263d00&gt;&#123;number = 10, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479128+0800 NSOperation练习[1593:358977] &lt;NSThread: 0x600000263dc0&gt;&#123;number = 9, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NSOperationQueue-amp-NSBlockOperation\"><a href=\"#NSOperationQueue-amp-NSBlockOperation\" class=\"headerlink\" title=\"NSOperationQueue &amp; NSBlockOperation\"></a>NSOperationQueue &amp; NSBlockOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo10 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [queue addOperation:op];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明<code>NSOperationQueue</code>默认是并发执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141569+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141641+0800 NSOperation练习[1984:456313] &lt;NSThread: 0x604000469d80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141661+0800 NSOperation练习[1984:456385] &lt;NSThread: 0x60000027ee80&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141676+0800 NSOperation练习[1984:456318] &lt;NSThread: 0x604000469c40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141928+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141945+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141954+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.142048+0800 NSOperation练习[1984:456386] &lt;NSThread: 0x60000027f380&gt;&#123;number = 9, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"队列暂停继续和取消全部\"><a href=\"#队列暂停继续和取消全部\" class=\"headerlink\" title=\"队列暂停继续和取消全部\"></a>队列暂停继续和取消全部</h2><h3 id=\"isSuspended\"><a href=\"#isSuspended\" class=\"headerlink\" title=\"isSuspended:\"></a>isSuspended:</h3><p>暂停和继续队列的属性；YES代表暂停队列，NO代表恢复队列。将队列挂起之后，队列中的操作就不会被调度，但是正在执行的操作不受影响<br><code>operationCount</code>: 操作计数,没有执行和没有执行完的操作,都会计算在操作计数之内</p>\n<blockquote>\n<p>注意 : 如果先暂停队列,再添加操作到队列,队列不会调度操作执行.所以在暂停队列之前要判断队列中有没有任务.如果没有操作就不暂停队列.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - 演示队列的暂停</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)pause:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 暂停队列之前判断队列中有无操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue.operationCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 暂停队列</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.queue.suspended = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"pause %zd\"</span>,<span class=\"keyword\">self</span>.queue.operationCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cancelAllOperations\"><a href=\"#cancelAllOperations\" class=\"headerlink\" title=\"cancelAllOperations:\"></a>cancelAllOperations:</h3><p>取消队列中的全部操作；旦调用的 <code>cancelAllOperations</code>方法，队列中的操作，都会被移除，正在执行的操作除外；正在执行的操作取消不了，如果要取消，需要自定义NSOperation；队列取消全部操作时，会有一定的时间延迟。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)cancelAll:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.queue cancelAllOperations];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancelAll %zd\"</span>,<span class=\"keyword\">self</span>.queue.operationCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"qualityOfService\"><a href=\"#qualityOfService\" class=\"headerlink\" title=\"qualityOfService\"></a>qualityOfService</h1><p>服务质量的枚举：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSQualityOfService</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUserInteractive</span> = <span class=\"number\">0x21</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUserInitiated</span> = <span class=\"number\">0x19</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUtility</span> = <span class=\"number\">0x11</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceBackground</span> = <span class=\"number\">0x09</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceDefault</span> = <span class=\"number\">-1</span></span><br><span class=\"line\">&#125; API_AVAILABLE(macos(<span class=\"number\">10.10</span>), ios(<span class=\"number\">8.0</span>), watchos(<span class=\"number\">2.0</span>), tvos(<span class=\"number\">9.0</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"operation\"><a href=\"#operation\" class=\"headerlink\" title=\"operation\"></a>operation</h2><p>让队列里面的操作有更多的机会被队列调度执行，类似于线程优先级<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo11 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"op1 block %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [op1 addExecutionBlock:^&#123;</span><br><span class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"opt1 %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    op1.qualityOfService = <span class=\"built_in\">NSQualityOfServiceBackground</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"op2 block %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [op2 addExecutionBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"opt2 %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    op2.qualityOfService = <span class=\"built_in\">NSQualityOfServiceUserInteractive</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperations:@[op1,op2] waitUntilFinished:<span class=\"literal\">false</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：op2优先于op1执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:05:46.292652+0800 NSOperation练习[2511:564443] op2 block &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292656+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292654+0800 NSOperation练习[2511:564445] opt2 &lt;NSThread: 0x604000470ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292709+0800 NSOperation练习[2511:564454] opt2 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292933+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292937+0800 NSOperation练习[2511:564443] opt2 &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292944+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292960+0800 NSOperation练习[2511:564444] op1 block &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.293083+0800 NSOperation练习[2511:564454] opt1 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.293089+0800 NSOperation练习[2511:564453] opt1 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.294076+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.294207+0800 NSOperation练习[2511:564444] opt1 &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo12 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * q1 = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * q2 = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    q1.qualityOfService = <span class=\"built_in\">NSQualityOfServiceBackground</span>;</span><br><span class=\"line\">    q2.qualityOfService = <span class=\"built_in\">NSQualityOfServiceUserInteractive</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [q1 addOperationWithBlock:^&#123;</span><br><span class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"q1\"</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [q2 addOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"q2\"</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：q2优先于q1执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:05:11.965991+0800 NSOperation练习[2487:561497] q2 &lt;NSThread: 0x604000274e00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.965998+0800 NSOperation练习[2487:561496] q2 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561517] q2 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966316+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968284+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968303+0800 NSOperation练习[2487:561495] q1 &lt;NSThread: 0x604000275680&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968376+0800 NSOperation练习[2487:561517] q1 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968409+0800 NSOperation练习[2487:561496] q1 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.969839+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"支持KVO的属性\"><a href=\"#支持KVO的属性\" class=\"headerlink\" title=\"支持KVO的属性\"></a>支持KVO的属性</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isCancelled - read-only   //是否取消</span><br><span class=\"line\"></span><br><span class=\"line\">isAsynchronous - read-only //是否异步</span><br><span class=\"line\"></span><br><span class=\"line\">isExecuting - read-only  //是否正在执行</span><br><span class=\"line\"></span><br><span class=\"line\">isFinished - read-only\t//是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">isReady - read-only\t//是否就绪</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies - read-only\t//依赖的其他的操作</span><br><span class=\"line\"></span><br><span class=\"line\">queuePriority - readable and writable\t//队列优先级</span><br><span class=\"line\"></span><br><span class=\"line\">completionBlock - readable and writable\t//结束回调</span><br></pre></td></tr></table></figure>\n<h1 id=\"操作间依赖\"><a href=\"#操作间依赖\" class=\"headerlink\" title=\"操作间依赖\"></a>操作间依赖</h1><h2 id=\"需求实例\"><a href=\"#需求实例\" class=\"headerlink\" title=\"需求实例\"></a>需求实例</h2><p>场景：用户需要先登录-&gt;付费-&gt;下载-&gt;通知用户<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dependency</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"login %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"pay %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"download %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op4 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"notice user %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[op2 addDependency:op1]; <span class=\"comment\">// 操作2依赖于操作1</span></span><br><span class=\"line\">[op3 addDependency:op2]; <span class=\"comment\">// 操作3依赖于操作2</span></span><br><span class=\"line\">[op4 addDependency:op3]; <span class=\"comment\">// 操作4依赖于操作3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// waitUntilFinished : 是否等到指定的操作执行结束再执行后面的代码</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.queue addOperations:@[op1,op2,op3] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通知用户的操作在主线程中执行</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperation:op4];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证 waitUntilFinished</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>不能循环建立操作间依赖关系.否则,队列不调度操作执行</li>\n<li>操作间可以跨队列建立依赖关系</li>\n<li>要将操作间的依赖建立好了之后,再添加到队列中（先建立操作依赖关系，再把操作添加到队列）</li>\n</ul>\n<h1 id=\"NSOperation和GCD的区别\"><a href=\"#NSOperation和GCD的区别\" class=\"headerlink\" title=\"NSOperation和GCD的区别\"></a>NSOperation和GCD的区别</h1><p><img src=\"/images/gcd_and_nop_relationship.png\" alt=\"\"></p>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>GCD <code>iOS 4.0</code> 推出，针对多核处理器的并发技术。GCD属于C语言的框架。将任务封装在block中，如果要停止已经加入 队列(queue) 的 任务(block) 需要写复杂的代码。只能设置队列的优先级不能设置任务的优先级。</p>\n<h3 id=\"高级功能\"><a href=\"#高级功能\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h3><ul>\n<li>barrier</li>\n<li>once</li>\n<li>after</li>\n<li>group</li>\n</ul>\n<h2 id=\"NSOperation-1\"><a href=\"#NSOperation-1\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>NSOperation <code>iOS 2.0</code> 推出，但在苹果推出 GCD 之后，对NSOperation的底层全部重写。NSOperation属于OC 框架，更加面向对象，底层是对 GCD 的封装。支持取消掉队列中的任务(正在执行的除外)，还可以设置队列中每个操作的优先级</p>\n<h3 id=\"高级功能-1\"><a href=\"#高级功能-1\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h3><ul>\n<li>最大操作并发数(GCD不好做)</li>\n<li>继续/暂停/全部取消</li>\n<li>跨队列设置操作的依赖关系</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h1><p>apple提供的多线程解决方案<code>NSOperation</code>是一个表示与单个任务关联的代码和数据的抽象类；因为是一个抽象类，所以不能直接使用，需要使用它的两个子类(<code>NSInvocationOperation</code> or <code>NSBlockOperation</code>) 去执行实际的操作任务；同样我们也可以通过自定义NSOperation。通常将操作添加到操作队列（<code>NSOperationQueue</code>类的实例）来执行操作。其实<code>NSOperation</code>就是对<code>GCD</code>的封装，相对于GCD来说可控性更强，并且可以加入操作依赖（<code>addDependency:</code> and <code>removeDependency</code>）。</p>\n<h2 id=\"NSInvocationOperation\"><a href=\"#NSInvocationOperation\" class=\"headerlink\" title=\"NSInvocationOperation\"></a>NSInvocationOperation</h2><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo1 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oprationTask:) object:<span class=\"string\">@\"InvocationOperation\"</span>];</span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)operationTask:(<span class=\"keyword\">id</span>)param &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：发现在主线程中输出的结果，但<code>start</code>方法是在<code>当前线程</code>中执行的<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 14:45:07.956558+0800 NSOperation练习[1324:290009] &lt;NSThread: 0x604000078000&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"将操作添加到队列\"><a href=\"#将操作添加到队列\" class=\"headerlink\" title=\"将操作添加到队列\"></a>将操作添加到队列</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo2 &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(oprationTask:) object:<span class=\"string\">@\"InvocationOperation\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">\t[queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：开启子线程异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 14:50:53.013010+0800 NSOperation练习[1408:312296] &lt;NSThread: 0x60400046b600&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"NSBlockOperation-使用较多\"><a href=\"#NSBlockOperation-使用较多\" class=\"headerlink\" title=\"NSBlockOperation (使用较多)\"></a>NSBlockOperation (使用较多)</h2><h3 id=\"start-1\"><a href=\"#start-1\" class=\"headerlink\" title=\"start\"></a>start</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo4 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<code>start</code>方法是在<code>当前线程</code>中执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:06:11.837276+0800 NSOperation练习[1661:375754] &lt;NSThread: 0x6000000745c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"将操作添加到队列-1\"><a href=\"#将操作添加到队列-1\" class=\"headerlink\" title=\"将操作添加到队列\"></a>将操作添加到队列</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo5 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：开启子线程异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:10:23.974301+0800 NSOperation练习[1720:389949] &lt;NSThread: 0x60400027ea40&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"执行块\"><a href=\"#执行块\" class=\"headerlink\" title=\"执行块\"></a>执行块</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo6 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block 2 %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block 1 %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, op.executionBlocks);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：执行块和操作享有共同的属性设置，异步执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:20:27.839119+0800 NSOperation练习[1882:431125] (</span><br><span class=\"line\">    \"&lt;__NSGlobalBlock__: 0x1086f9080&gt;\",</span><br><span class=\"line\">    \"&lt;__NSGlobalBlock__: 0x1086f90c0&gt;\"</span><br><span class=\"line\">)</span><br><span class=\"line\">2018-05-19 15:20:27.839131+0800 NSOperation练习[1882:431333] block 2 &lt;NSThread: 0x60000027bbc0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:20:27.839133+0800 NSOperation练习[1882:431330] block 1 &lt;NSThread: 0x604000466fc0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"线程间通讯\"><a href=\"#线程间通讯\" class=\"headerlink\" title=\"线程间通讯\"></a>线程间通讯</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo7&#123;</span><br><span class=\"line\">\t[[<span class=\"built_in\">NSOperationQueue</span> new] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"consuming time：%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t<span class=\"comment\">/// 回到主线程刷新UI</span></span><br><span class=\"line\">\t\t[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"refresh ui: %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">\t\t&#125;];</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"监听block执行完成\"><a href=\"#监听block执行完成\" class=\"headerlink\" title=\"监听block执行完成\"></a>监听block执行完成</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo13 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%zd %@\"</span>,i,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">//设置监听操作执行完成的block，必须要在把操作添加到队列之前设置</span></span><br><span class=\"line\">    [op setCompletionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"setCompletionBlock  %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSOperationQueue</span> new]addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:12:00.170053+0800 NSOperation练习[2607:585084] 0 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.170267+0800 NSOperation练习[2607:585084] 1 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.170410+0800 NSOperation练习[2607:585084] 2 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171319+0800 NSOperation练习[2607:585084] 3 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171538+0800 NSOperation练习[2607:585084] 4 &lt;NSThread: 0x60000027bd80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:12:00.171816+0800 NSOperation练习[2607:585083] setCompletionBlock  &lt;NSThread: 0x60000027bd40&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"自定义NSOperation\"><a href=\"#自定义NSOperation\" class=\"headerlink\" title=\"自定义NSOperation\"></a>自定义NSOperation</h2><h3 id=\"自定义类继承NSOperation\"><a href=\"#自定义类继承NSOperation\" class=\"headerlink\" title=\"自定义类继承NSOperation\"></a>自定义类继承NSOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">CustomOperation</span> : <span class=\"title\">NSOperation</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    DownloadOperation * op = [[DownloadOperation alloc]init];</span><br><span class=\"line\">    [queue addOperation:op];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重写main方法\"><a href=\"#重写main方法\" class=\"headerlink\" title=\"重写main方法\"></a>重写main方法</h3><p>任何操作在执行时,首先会调用start方法,start方法会更新操作的状态(过滤操作)；经start方法过滤之后，只有正常可执行的操作，就会调用这个main方法，重写操作的入口方法(main方法)，就可以在这个方法里面指定操作执行的任务。<code>main</code>方法默认在子线程中异步执行<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//在这个方法中做想要做的操作，即自定义 NSOperation的目的</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,<span class=\"keyword\">self</span>.URLString,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"NSOperationQueue\"><a href=\"#NSOperationQueue\" class=\"headerlink\" title=\"NSOperationQueue\"></a>NSOperationQueue</h1><p><img src=\"/images/nsopration_add_to_queue.png\" alt=\"\"></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p><code>NSOperationQueue</code>只有一种类型，就是并发队列。在开发使用到<code>NSOperationQueue</code>时，建议将其定义为<code>全局</code>队列。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义为属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSOperationQueue</span> *queue;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSOperationQueue</span> * )queue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"最大并发数\"><a href=\"#最大并发数\" class=\"headerlink\" title=\"最大并发数\"></a>最大并发数</h2><p><img src=\"/imagesnsopration_queue_maxium.png\" alt=\"\"><br><code>maxConcurrentOperationCount</code>是队列的一个属性，可以限制队列<code>同时执行</code>的任务数量，从而间接的控制了线程数量(线程可以复用)，但队列最大并发数不是线程数。如果队列最大并发数设置为<code>1</code>，那么队列实际上就是一个串行队列了。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置最大并发数 : 每次只能调度两个操作执行</span></span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"验证队列的并发性\"><a href=\"#验证队列的并发性\" class=\"headerlink\" title=\"验证队列的并发性\"></a>验证队列的并发性</h2><h3 id=\"NSOperationQueue-amp-NSInvocationOperation\"><a href=\"#NSOperationQueue-amp-NSInvocationOperation\" class=\"headerlink\" title=\"NSOperationQueue &amp; NSInvocationOperation\"></a>NSOperationQueue &amp; NSInvocationOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo8 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSInvocationOperation</span> * op = [[<span class=\"built_in\">NSInvocationOperation</span> alloc]initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(operationTask:) object:@(i)];</span><br><span class=\"line\">        [queue addOperation:op];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明<code>NSOperationQueue</code>默认是并发执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:01:47.478515+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478518+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478519+0800 NSOperation练习[1593:358936] &lt;NSThread: 0x60400047a500&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478572+0800 NSOperation练习[1593:358935] &lt;NSThread: 0x60400047a640&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478740+0800 NSOperation练习[1593:358974] &lt;NSThread: 0x600000263a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478881+0800 NSOperation练习[1593:358938] &lt;NSThread: 0x600000263680&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.478902+0800 NSOperation练习[1593:358939] &lt;NSThread: 0x60400047a580&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479084+0800 NSOperation练习[1593:358975] &lt;NSThread: 0x6000002636c0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479096+0800 NSOperation练习[1593:358976] &lt;NSThread: 0x600000263d00&gt;&#123;number = 10, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:01:47.479128+0800 NSOperation练习[1593:358977] &lt;NSThread: 0x600000263dc0&gt;&#123;number = 9, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"NSOperationQueue-amp-NSBlockOperation\"><a href=\"#NSOperationQueue-amp-NSBlockOperation\" class=\"headerlink\" title=\"NSOperationQueue &amp; NSBlockOperation\"></a>NSOperationQueue &amp; NSBlockOperation</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo10 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSBlockOperation</span> * op = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [queue addOperation:op];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：会开启多条线程,不是顺序执行.与GCD中并发队列&amp;异步执行效果一样，说明<code>NSOperationQueue</code>默认是并发执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141566+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141569+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141641+0800 NSOperation练习[1984:456313] &lt;NSThread: 0x604000469d80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141661+0800 NSOperation练习[1984:456385] &lt;NSThread: 0x60000027ee80&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141676+0800 NSOperation练习[1984:456318] &lt;NSThread: 0x604000469c40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141928+0800 NSOperation练习[1984:456384] &lt;NSThread: 0x60000027ef80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141945+0800 NSOperation练习[1984:456319] &lt;NSThread: 0x604000468dc0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.141954+0800 NSOperation练习[1984:456314] &lt;NSThread: 0x60000027f040&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 15:26:52.142048+0800 NSOperation练习[1984:456386] &lt;NSThread: 0x60000027f380&gt;&#123;number = 9, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"队列暂停继续和取消全部\"><a href=\"#队列暂停继续和取消全部\" class=\"headerlink\" title=\"队列暂停继续和取消全部\"></a>队列暂停继续和取消全部</h2><h3 id=\"isSuspended\"><a href=\"#isSuspended\" class=\"headerlink\" title=\"isSuspended:\"></a>isSuspended:</h3><p>暂停和继续队列的属性；YES代表暂停队列，NO代表恢复队列。将队列挂起之后，队列中的操作就不会被调度，但是正在执行的操作不受影响<br><code>operationCount</code>: 操作计数,没有执行和没有执行完的操作,都会计算在操作计数之内</p>\n<blockquote>\n<p>注意 : 如果先暂停队列,再添加操作到队列,队列不会调度操作执行.所以在暂停队列之前要判断队列中有没有任务.如果没有操作就不暂停队列.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#pragma mark - 演示队列的暂停</span></span><br><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)pause:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 暂停队列之前判断队列中有无操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.queue.operationCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 暂停队列</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.queue.suspended = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"pause %zd\"</span>,<span class=\"keyword\">self</span>.queue.operationCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cancelAllOperations\"><a href=\"#cancelAllOperations\" class=\"headerlink\" title=\"cancelAllOperations:\"></a>cancelAllOperations:</h3><p>取消队列中的全部操作；旦调用的 <code>cancelAllOperations</code>方法，队列中的操作，都会被移除，正在执行的操作除外；正在执行的操作取消不了，如果要取消，需要自定义NSOperation；队列取消全部操作时，会有一定的时间延迟。<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">IBAction</span>)cancelAll:(<span class=\"keyword\">id</span>)sender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.queue cancelAllOperations];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"cancelAll %zd\"</span>,<span class=\"keyword\">self</span>.queue.operationCount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"qualityOfService\"><a href=\"#qualityOfService\" class=\"headerlink\" title=\"qualityOfService\"></a>qualityOfService</h1><p>服务质量的枚举：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>, <span class=\"built_in\">NSQualityOfService</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUserInteractive</span> = <span class=\"number\">0x21</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUserInitiated</span> = <span class=\"number\">0x19</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceUtility</span> = <span class=\"number\">0x11</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceBackground</span> = <span class=\"number\">0x09</span>,</span><br><span class=\"line\">    <span class=\"built_in\">NSQualityOfServiceDefault</span> = <span class=\"number\">-1</span></span><br><span class=\"line\">&#125; API_AVAILABLE(macos(<span class=\"number\">10.10</span>), ios(<span class=\"number\">8.0</span>), watchos(<span class=\"number\">2.0</span>), tvos(<span class=\"number\">9.0</span>));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"operation\"><a href=\"#operation\" class=\"headerlink\" title=\"operation\"></a>operation</h2><p>让队列里面的操作有更多的机会被队列调度执行，类似于线程优先级<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo11 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"op1 block %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [op1 addExecutionBlock:^&#123;</span><br><span class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"opt1 %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    op1.qualityOfService = <span class=\"built_in\">NSQualityOfServiceBackground</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"op2 block %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [op2 addExecutionBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"opt2 %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    op2.qualityOfService = <span class=\"built_in\">NSQualityOfServiceUserInteractive</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    [queue addOperations:@[op1,op2] waitUntilFinished:<span class=\"literal\">false</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：op2优先于op1执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:05:46.292652+0800 NSOperation练习[2511:564443] op2 block &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292656+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292654+0800 NSOperation练习[2511:564445] opt2 &lt;NSThread: 0x604000470ac0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292709+0800 NSOperation练习[2511:564454] opt2 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292933+0800 NSOperation练习[2511:564453] opt2 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292937+0800 NSOperation练习[2511:564443] opt2 &lt;NSThread: 0x600000278580&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292944+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.292960+0800 NSOperation练习[2511:564444] op1 block &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.293083+0800 NSOperation练习[2511:564454] opt1 &lt;NSThread: 0x604000470c40&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.293089+0800 NSOperation练习[2511:564453] opt1 &lt;NSThread: 0x600000278680&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.294076+0800 NSOperation练习[2511:564446] opt1 &lt;NSThread: 0x604000470b00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:46.294207+0800 NSOperation练习[2511:564444] opt1 &lt;NSThread: 0x604000470b80&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)demo12 &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * q1 = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\">    <span class=\"built_in\">NSOperationQueue</span> * q2 = [[<span class=\"built_in\">NSOperationQueue</span> alloc]init];</span><br><span class=\"line\"></span><br><span class=\"line\">    q1.qualityOfService = <span class=\"built_in\">NSQualityOfServiceBackground</span>;</span><br><span class=\"line\">    q2.qualityOfService = <span class=\"built_in\">NSQualityOfServiceUserInteractive</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">        [q1 addOperationWithBlock:^&#123;</span><br><span class=\"line\">           <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"q1\"</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [q2 addOperationWithBlock:^&#123;</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"q2\"</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：q2优先于q1执行<br><figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-19 16:05:11.965991+0800 NSOperation练习[2487:561497] q2 &lt;NSThread: 0x604000274e00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.965998+0800 NSOperation练习[2487:561496] q2 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966106+0800 NSOperation练习[2487:561517] q2 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.966316+0800 NSOperation练习[2487:561516] q2 &lt;NSThread: 0x600000275940&gt;&#123;number = 5, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968284+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968303+0800 NSOperation练习[2487:561495] q1 &lt;NSThread: 0x604000275680&gt;&#123;number = 8, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968376+0800 NSOperation练习[2487:561517] q1 &lt;NSThread: 0x604000274f80&gt;&#123;number = 6, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.968409+0800 NSOperation练习[2487:561496] q1 &lt;NSThread: 0x600000275740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2018-05-19 16:05:11.969839+0800 NSOperation练习[2487:561494] q1 &lt;NSThread: 0x600000263840&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"支持KVO的属性\"><a href=\"#支持KVO的属性\" class=\"headerlink\" title=\"支持KVO的属性\"></a>支持KVO的属性</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isCancelled - read-only   //是否取消</span><br><span class=\"line\"></span><br><span class=\"line\">isAsynchronous - read-only //是否异步</span><br><span class=\"line\"></span><br><span class=\"line\">isExecuting - read-only  //是否正在执行</span><br><span class=\"line\"></span><br><span class=\"line\">isFinished - read-only\t//是否结束</span><br><span class=\"line\"></span><br><span class=\"line\">isReady - read-only\t//是否就绪</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies - read-only\t//依赖的其他的操作</span><br><span class=\"line\"></span><br><span class=\"line\">queuePriority - readable and writable\t//队列优先级</span><br><span class=\"line\"></span><br><span class=\"line\">completionBlock - readable and writable\t//结束回调</span><br></pre></td></tr></table></figure>\n<h1 id=\"操作间依赖\"><a href=\"#操作间依赖\" class=\"headerlink\" title=\"操作间依赖\"></a>操作间依赖</h1><h2 id=\"需求实例\"><a href=\"#需求实例\" class=\"headerlink\" title=\"需求实例\"></a>需求实例</h2><p>场景：用户需要先登录-&gt;付费-&gt;下载-&gt;通知用户<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dependency</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"login %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"pay %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"download %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSBlockOperation</span> * op4 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"notice user %@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[op2 addDependency:op1]; <span class=\"comment\">// 操作2依赖于操作1</span></span><br><span class=\"line\">[op3 addDependency:op2]; <span class=\"comment\">// 操作3依赖于操作2</span></span><br><span class=\"line\">[op4 addDependency:op3]; <span class=\"comment\">// 操作4依赖于操作3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// waitUntilFinished : 是否等到指定的操作执行结束再执行后面的代码</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.queue addOperations:@[op1,op2,op3] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通知用户的操作在主线程中执行</span></span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperation:op4];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证 waitUntilFinished</span></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>不能循环建立操作间依赖关系.否则,队列不调度操作执行</li>\n<li>操作间可以跨队列建立依赖关系</li>\n<li>要将操作间的依赖建立好了之后,再添加到队列中（先建立操作依赖关系，再把操作添加到队列）</li>\n</ul>\n<h1 id=\"NSOperation和GCD的区别\"><a href=\"#NSOperation和GCD的区别\" class=\"headerlink\" title=\"NSOperation和GCD的区别\"></a>NSOperation和GCD的区别</h1><p><img src=\"/images/gcd_and_nop_relationship.png\" alt=\"\"></p>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>GCD <code>iOS 4.0</code> 推出，针对多核处理器的并发技术。GCD属于C语言的框架。将任务封装在block中，如果要停止已经加入 队列(queue) 的 任务(block) 需要写复杂的代码。只能设置队列的优先级不能设置任务的优先级。</p>\n<h3 id=\"高级功能\"><a href=\"#高级功能\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h3><ul>\n<li>barrier</li>\n<li>once</li>\n<li>after</li>\n<li>group</li>\n</ul>\n<h2 id=\"NSOperation-1\"><a href=\"#NSOperation-1\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>NSOperation <code>iOS 2.0</code> 推出，但在苹果推出 GCD 之后，对NSOperation的底层全部重写。NSOperation属于OC 框架，更加面向对象，底层是对 GCD 的封装。支持取消掉队列中的任务(正在执行的除外)，还可以设置队列中每个操作的优先级</p>\n<h3 id=\"高级功能-1\"><a href=\"#高级功能-1\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h3><ul>\n<li>最大操作并发数(GCD不好做)</li>\n<li>继续/暂停/全部取消</li>\n<li>跨队列设置操作的依赖关系</li>\n</ul>\n"},{"title":"iOS - TableView 的重用机制及优化","date":"2018-05-18T13:41:01.000Z","_content":"## iOS-TableView的重用机制\n### 什么是Cell的重用？\n重用机制，简单的说意思是一行一行cell的复用\n### 为什么要重用？\n为了做到显示和数据分离，UITableViewCell的实现而且不是为每一个数据项创建一个tableCell，是仅仅创建屏幕可显示最大个数的cell，然后反复使用这些cell，对cell做单独的显示配置，来达到既不影响显示效果，又能充分节省内存的目的；当屏幕滚动出现新Cell的时候，就会调用方法获取新出现的Cell,而有的Cell则会滚动到屏幕的外面\n### 如何实现Cell的重用？\n通过UITableView的`dequeueReusableCellWithIdentifier `函数实现，从字面理解就是`出列可重用的Cell`，简单来说就是有一个Cell池，里面存放了之前从屏幕滚动消失的Cell\n### 重用机制的实现原理\n进入UITableView的头文件可以发现：\n```objc\n@property (nonatomic, readonly) NSArray<UITableViewCell *> *visibleCells;\n@property (nonatomic, readonly) NSDictionary<NSString *, UITableViewCell *> * reusableTableCells;\n```\n`visibleCells`内显示当前显示的cells\n`reusableTableCells`保存可重用的cells，可复用的cell使用字典是因为可复用的可能cell不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式。\n\n- 执行思路：\ntableView显示之初，reusableTableCells为空，假如一个界面显示5个Cell，界面慢慢向上拖动，当cell1完全从屏幕上小时的时，cell6（cell6是新创建的cell,因为reusableTableCells为空）完全展示在界面上时；cell1移入到reusableTableCells中，继续拖动,展示cell7会从reusableTableCells中取出缓存的cell1,以此类推…\n\n### 注意\n并非仅仅有拖动超出屏幕的时候才会更新reusableTableCells,`reloadData`和`reloadRowsAtIndex`时也会更新并操作reusableTableCells\n\n## UITableViewCell的性能优化\n![](/images/uitableviewcell_optimize.png)\n## 扩展：UITableView delegate/dataSource方法执行顺序\n```Objc\n1.//有多少组\n-(NSInteger)numberOfSectionsInTableView:(UITableView * )tableView\n2.//cell 页眉高度\n-(CGFloat)tableView:(UITableView * )tableView heightForHeaderInSection:(NSInteger)section\n3.//cell页脚高度\n-(CGFloat)tableView:(UITableView * )tableView heightForFooterInSection:(NSInteger)section\n4.//每组有多少行\n-(NSInteger)tableView:(UITableView * )tableView numberOfRowsInSection:(NSInteger)section\n5.//cell高度\n-(CGFloat)tableView:(UITableView * )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath\n6.//布局UITableviewcell\n-(UITableViewCell )tableView:(UITableView * )tableView cellForRowAtIndexPath:(NSIndexPath * )indexPath\n```\n","source":"_posts/ios-uitableview-optimize.md","raw":"---\ntitle: iOS - TableView 的重用机制及优化\ndate: 2018-05-18 21:41:01\ntags: [iOS,UITableView]\ncategories: [iOS]\n---\n## iOS-TableView的重用机制\n### 什么是Cell的重用？\n重用机制，简单的说意思是一行一行cell的复用\n### 为什么要重用？\n为了做到显示和数据分离，UITableViewCell的实现而且不是为每一个数据项创建一个tableCell，是仅仅创建屏幕可显示最大个数的cell，然后反复使用这些cell，对cell做单独的显示配置，来达到既不影响显示效果，又能充分节省内存的目的；当屏幕滚动出现新Cell的时候，就会调用方法获取新出现的Cell,而有的Cell则会滚动到屏幕的外面\n### 如何实现Cell的重用？\n通过UITableView的`dequeueReusableCellWithIdentifier `函数实现，从字面理解就是`出列可重用的Cell`，简单来说就是有一个Cell池，里面存放了之前从屏幕滚动消失的Cell\n### 重用机制的实现原理\n进入UITableView的头文件可以发现：\n```objc\n@property (nonatomic, readonly) NSArray<UITableViewCell *> *visibleCells;\n@property (nonatomic, readonly) NSDictionary<NSString *, UITableViewCell *> * reusableTableCells;\n```\n`visibleCells`内显示当前显示的cells\n`reusableTableCells`保存可重用的cells，可复用的cell使用字典是因为可复用的可能cell不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式。\n\n- 执行思路：\ntableView显示之初，reusableTableCells为空，假如一个界面显示5个Cell，界面慢慢向上拖动，当cell1完全从屏幕上小时的时，cell6（cell6是新创建的cell,因为reusableTableCells为空）完全展示在界面上时；cell1移入到reusableTableCells中，继续拖动,展示cell7会从reusableTableCells中取出缓存的cell1,以此类推…\n\n### 注意\n并非仅仅有拖动超出屏幕的时候才会更新reusableTableCells,`reloadData`和`reloadRowsAtIndex`时也会更新并操作reusableTableCells\n\n## UITableViewCell的性能优化\n![](/images/uitableviewcell_optimize.png)\n## 扩展：UITableView delegate/dataSource方法执行顺序\n```Objc\n1.//有多少组\n-(NSInteger)numberOfSectionsInTableView:(UITableView * )tableView\n2.//cell 页眉高度\n-(CGFloat)tableView:(UITableView * )tableView heightForHeaderInSection:(NSInteger)section\n3.//cell页脚高度\n-(CGFloat)tableView:(UITableView * )tableView heightForFooterInSection:(NSInteger)section\n4.//每组有多少行\n-(NSInteger)tableView:(UITableView * )tableView numberOfRowsInSection:(NSInteger)section\n5.//cell高度\n-(CGFloat)tableView:(UITableView * )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath\n6.//布局UITableviewcell\n-(UITableViewCell )tableView:(UITableView * )tableView cellForRowAtIndexPath:(NSIndexPath * )indexPath\n```\n","slug":"ios-uitableview-optimize","published":1,"updated":"2019-01-13T05:10:27.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d2y001zl1fq2o7m4jwe","content":"<h2 id=\"iOS-TableView的重用机制\"><a href=\"#iOS-TableView的重用机制\" class=\"headerlink\" title=\"iOS-TableView的重用机制\"></a>iOS-TableView的重用机制</h2><h3 id=\"什么是Cell的重用？\"><a href=\"#什么是Cell的重用？\" class=\"headerlink\" title=\"什么是Cell的重用？\"></a>什么是Cell的重用？</h3><p>重用机制，简单的说意思是一行一行cell的复用</p>\n<h3 id=\"为什么要重用？\"><a href=\"#为什么要重用？\" class=\"headerlink\" title=\"为什么要重用？\"></a>为什么要重用？</h3><p>为了做到显示和数据分离，UITableViewCell的实现而且不是为每一个数据项创建一个tableCell，是仅仅创建屏幕可显示最大个数的cell，然后反复使用这些cell，对cell做单独的显示配置，来达到既不影响显示效果，又能充分节省内存的目的；当屏幕滚动出现新Cell的时候，就会调用方法获取新出现的Cell,而有的Cell则会滚动到屏幕的外面</p>\n<h3 id=\"如何实现Cell的重用？\"><a href=\"#如何实现Cell的重用？\" class=\"headerlink\" title=\"如何实现Cell的重用？\"></a>如何实现Cell的重用？</h3><p>通过UITableView的<code>dequeueReusableCellWithIdentifier</code>函数实现，从字面理解就是<code>出列可重用的Cell</code>，简单来说就是有一个Cell池，里面存放了之前从屏幕滚动消失的Cell</p>\n<h3 id=\"重用机制的实现原理\"><a href=\"#重用机制的实现原理\" class=\"headerlink\" title=\"重用机制的实现原理\"></a>重用机制的实现原理</h3><p>进入UITableView的头文件可以发现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">UITableViewCell</span> *&gt; *visibleCells;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">UITableViewCell</span> *&gt; * reusableTableCells;</span><br></pre></td></tr></table></figure></p>\n<p><code>visibleCells</code>内显示当前显示的cells<br><code>reusableTableCells</code>保存可重用的cells，可复用的cell使用字典是因为可复用的可能cell不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式。</p>\n<ul>\n<li>执行思路：<br>tableView显示之初，reusableTableCells为空，假如一个界面显示5个Cell，界面慢慢向上拖动，当cell1完全从屏幕上小时的时，cell6（cell6是新创建的cell,因为reusableTableCells为空）完全展示在界面上时；cell1移入到reusableTableCells中，继续拖动,展示cell7会从reusableTableCells中取出缓存的cell1,以此类推…</li>\n</ul>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>并非仅仅有拖动超出屏幕的时候才会更新reusableTableCells,<code>reloadData</code>和<code>reloadRowsAtIndex</code>时也会更新并操作reusableTableCells</p>\n<h2 id=\"UITableViewCell的性能优化\"><a href=\"#UITableViewCell的性能优化\" class=\"headerlink\" title=\"UITableViewCell的性能优化\"></a>UITableViewCell的性能优化</h2><p><img src=\"/images/uitableviewcell_optimize.png\" alt=\"\"></p>\n<h2 id=\"扩展：UITableView-delegate-dataSource方法执行顺序\"><a href=\"#扩展：UITableView-delegate-dataSource方法执行顺序\" class=\"headerlink\" title=\"扩展：UITableView delegate/dataSource方法执行顺序\"></a>扩展：UITableView delegate/dataSource方法执行顺序</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span><span class=\"comment\">//有多少组</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSInteger</span>)numberOfSectionsInTableView:(<span class=\"built_in\">UITableView</span> * )tableView</span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"comment\">//cell 页眉高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">3.</span><span class=\"comment\">//cell页脚高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForFooterInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">4.</span><span class=\"comment\">//每组有多少行</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">5.</span><span class=\"comment\">//cell高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> )indexPath</span><br><span class=\"line\"><span class=\"number\">6.</span><span class=\"comment\">//布局UITableviewcell</span></span><br><span class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> )tableView:(<span class=\"built_in\">UITableView</span> * )tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> * )indexPath</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"iOS-TableView的重用机制\"><a href=\"#iOS-TableView的重用机制\" class=\"headerlink\" title=\"iOS-TableView的重用机制\"></a>iOS-TableView的重用机制</h2><h3 id=\"什么是Cell的重用？\"><a href=\"#什么是Cell的重用？\" class=\"headerlink\" title=\"什么是Cell的重用？\"></a>什么是Cell的重用？</h3><p>重用机制，简单的说意思是一行一行cell的复用</p>\n<h3 id=\"为什么要重用？\"><a href=\"#为什么要重用？\" class=\"headerlink\" title=\"为什么要重用？\"></a>为什么要重用？</h3><p>为了做到显示和数据分离，UITableViewCell的实现而且不是为每一个数据项创建一个tableCell，是仅仅创建屏幕可显示最大个数的cell，然后反复使用这些cell，对cell做单独的显示配置，来达到既不影响显示效果，又能充分节省内存的目的；当屏幕滚动出现新Cell的时候，就会调用方法获取新出现的Cell,而有的Cell则会滚动到屏幕的外面</p>\n<h3 id=\"如何实现Cell的重用？\"><a href=\"#如何实现Cell的重用？\" class=\"headerlink\" title=\"如何实现Cell的重用？\"></a>如何实现Cell的重用？</h3><p>通过UITableView的<code>dequeueReusableCellWithIdentifier</code>函数实现，从字面理解就是<code>出列可重用的Cell</code>，简单来说就是有一个Cell池，里面存放了之前从屏幕滚动消失的Cell</p>\n<h3 id=\"重用机制的实现原理\"><a href=\"#重用机制的实现原理\" class=\"headerlink\" title=\"重用机制的实现原理\"></a>重用机制的实现原理</h3><p>进入UITableView的头文件可以发现：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">UITableViewCell</span> *&gt; *visibleCells;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">readonly</span>) <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"built_in\">UITableViewCell</span> *&gt; * reusableTableCells;</span><br></pre></td></tr></table></figure></p>\n<p><code>visibleCells</code>内显示当前显示的cells<br><code>reusableTableCells</code>保存可重用的cells，可复用的cell使用字典是因为可复用的可能cell不只有一种样式，这里需要字典指定key(也就是reuseIdentifier)来查找是否有可重用样式。</p>\n<ul>\n<li>执行思路：<br>tableView显示之初，reusableTableCells为空，假如一个界面显示5个Cell，界面慢慢向上拖动，当cell1完全从屏幕上小时的时，cell6（cell6是新创建的cell,因为reusableTableCells为空）完全展示在界面上时；cell1移入到reusableTableCells中，继续拖动,展示cell7会从reusableTableCells中取出缓存的cell1,以此类推…</li>\n</ul>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>并非仅仅有拖动超出屏幕的时候才会更新reusableTableCells,<code>reloadData</code>和<code>reloadRowsAtIndex</code>时也会更新并操作reusableTableCells</p>\n<h2 id=\"UITableViewCell的性能优化\"><a href=\"#UITableViewCell的性能优化\" class=\"headerlink\" title=\"UITableViewCell的性能优化\"></a>UITableViewCell的性能优化</h2><p><img src=\"/images/uitableviewcell_optimize.png\" alt=\"\"></p>\n<h2 id=\"扩展：UITableView-delegate-dataSource方法执行顺序\"><a href=\"#扩展：UITableView-delegate-dataSource方法执行顺序\" class=\"headerlink\" title=\"扩展：UITableView delegate/dataSource方法执行顺序\"></a>扩展：UITableView delegate/dataSource方法执行顺序</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span><span class=\"comment\">//有多少组</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSInteger</span>)numberOfSectionsInTableView:(<span class=\"built_in\">UITableView</span> * )tableView</span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"comment\">//cell 页眉高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForHeaderInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">3.</span><span class=\"comment\">//cell页脚高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForFooterInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">4.</span><span class=\"comment\">//每组有多少行</span></span><br><span class=\"line\">-(<span class=\"built_in\">NSInteger</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView numberOfRowsInSection:(<span class=\"built_in\">NSInteger</span>)section</span><br><span class=\"line\"><span class=\"number\">5.</span><span class=\"comment\">//cell高度</span></span><br><span class=\"line\">-(<span class=\"built_in\">CGFloat</span>)tableView:(<span class=\"built_in\">UITableView</span> * )tableView heightForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> )indexPath</span><br><span class=\"line\"><span class=\"number\">6.</span><span class=\"comment\">//布局UITableviewcell</span></span><br><span class=\"line\">-(<span class=\"built_in\">UITableViewCell</span> )tableView:(<span class=\"built_in\">UITableView</span> * )tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> * )indexPath</span><br></pre></td></tr></table></figure>\n"},{"title":"iOS - UIWebView & JSContext & WKWebView","date":"2018-05-08T09:33:53.000Z","_content":"# UIWebView\n> A view that embeds web content in your app.\n\n## UIWebView 的JS注入\n> 案例 : 移除网页的某些不需要展示的标签\n\n- 准备网页地址 : http://m.dianping.com/tuan/deal/5501525\n\n### 浏览器终端中演示JS代码删除网页中元素\n* 需要处理的网页\n![](/images/webpage_demand_process.png)\n---\n*  网页处理的步骤\n``` javascript\n以删除导航为例 :\n  1.先找到该节点 : var headerTag = document.getElementsByTagName('header')[0];\n  2.再找到父节点 : headerTag.parentNode\n  3.最后用它的父节点删除该节点 : headerTag.parentNode.removeChild(headerTag);\n\n  合并: var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\n```\n* 删除导航\n``` javascript\nvar headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\n```\n* 删除底部悬停按钮\n``` javascript\nvar footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\n```\n* 删除底部布局\n``` javascript\nvar footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\n```\n* 处理之后的网页\n![](/images/webpage_process_after.png)\n\n---\n### OC调用JS 实现 JS注入\n> OC和JS的交互需要使用UIWebView的代理方法作为桥梁实现\n\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\t[self.webView loadRequest:[NSURLRequest requestWithURL:URL]];\n\n\t// 设置代理\n\tself.webView.delegate = self;\n}\n```\n* 网页加载完时调用的代理方法\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * ) webView;\n```\n* 网页加载完成之后,调用JS代码的OC方法\n``` objc\n- (nullable NSString * )stringByEvaluatingJavaScriptFromString:(NSString * )script;\n```\n\n### JS注入的具体实现\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// OC调用JS代码\n\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];\n}\n\n```\n\n## UIWebView监听网页标签的点击(JS调用OC)\n> 案例 : 点击网页某个标签跳转到苹果原生控制器\n> 核心思想 : 拦截webView上所有的网络请求\n\n### JS调用OC需要实现的代理方法\n``` objc\n-(BOOL) webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType;\n```\n\n### JS注入给标签添加点击事件\n- 网页标签添加点击事件\n``` objc\n[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n```\n\n- 标签的点击事件注入到JS\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给标签添加点击事件\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n\n  \t// OC调用JS代码\n\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];\n}\n```\n\n> * 给标签添加点击事件的目的 : 使标签可点击\n> * 点击事件发送网络请求的目的 : 可以拦截到标签的点击事件\n> * 自定义协议的目的 : 给事件设计一个特殊的标记,如果拦截到请求,就通过特殊的标记来区别要做的事情\n\n### 拦截webView上所有的网络请求,筛选请求\n``` objc\n/**\n 1.JS与OC交互的桥梁\n 2.可以拦截webView上所有的请求\n 3.给标签添加点击事件,点击事件主要就是发送请求;发送的请求是自定义协议的,目的是为了做标记.\n */\n- (BOOL)webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType\n{\n\tNSLog(@\"%@\",request.URL.absoluteString);\n\n\t// 拿到网页的请求地址\n\tNSString * URLString = request.URL.absoluteString;\n\t// 判断网页的请求地址协议是否是我们自定义的那个\n\tNSRange range = [URLString rangeOfString:@\"custom://techbird.me\"];\n\tif (range.length > 0) {\n\t\t// 点击网页中的图片,实现OC原生界面的跳转\n\t\tTestViewController * VC = [[TestViewController alloc] init];\n\t\t[self.navigationController pushViewController:VC animated:YES];\n\t\treturn NO;\n\t}\n\treturn YES;\n}\n```\n# JSContext\nJSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口\n\n## JSContexts实现OC与JS交互\n- 获取上下文\n``` objc\nJSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n```\n## 使用JSContext 实现 JS调用OC\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\tNSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]];\n\t[self.webView loadRequest:request];\n\tself.webView.delegate = self;\n\n\t// 获取上下文\n\tJSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\t// 监听图片标签点击\n\tcontext[@\"imgtag\"] = ^ {\n\t\t[self.navigationController pushViewController:[TestViewController new] animated:YES];\n\t};\n\t// 监听购买标签点击\n\tcontext[@\"buytag\"] = ^ {\n\t\t[self.navigationController pushViewController:[Test1ViewController new] animated:YES];\n\t};\n}\n```\n### 使用JSContext 实现 JS注入\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拿到JS的上下文\n\tJSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\n\t// 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给图片标签添加点击事件 : 自定义协议\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function imgtagclick() {imgtag();};\"];\n\n\t// 给以过期的购买标签重新添加点击事件\n\t[JSStringM appendString:@\"var buyBtnTag = document.getElementsByClassName('buy-btn btn-gray')[0]; buyBtnTag.onclick = function buybtnclick() {buytag();};\"];\n\n\t// 执行这个JS代码\n\t[context evaluateScript:JSStringM];\n}\n```\n\n# WKWebView\n> Starting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView.\n\n## WKWebView的OC和JS交互\n\n- 使用前导入头文件\n``` objc\n   #import <WebKit/WebKit.h>\n```\n\n- 遵守代理协议\n``` objc\nwebView.navigationDelegate = self;\n```\n\n### 代理方法介绍\n- 面即将开始加载时调用 (拦截网页的网络请求 : JS调用OC)\n``` objc\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;\n```\n- 页面开始加载时调用\n``` objc\n- (void)webView:(WKWebView * )webView didStartProvisionalNavigation:(WKNavigation * )navigation;\n```\n- 收到响应后,决定是否跳转,即是否把这个链接对应的网页加载到WKWebView上\n``` objc\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationResponse:(WKNavigationResponse * )navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;\n```\n- 当内容开始返回时调用,即服务器已经在向客户端发送网页数据\n``` objc\n- (void)webView:(WKWebView * )webView didCommitNavigation:(WKNavigation * )navigation;\n```\n- 页面加载完成之后调用 (OC调用JS : JS注入)\n``` objc\n- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation;\n```\n- 页面加载失败时调用\n``` objc\n- (void)webView:(WKWebView * )webView didFailProvisionalNavigation:(WKNavigation * )navigation;\n```\n### 准备WKWebView\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t// 创建WKWebView\n\tWKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t[self.view addSubview:webView];\n\twebView.backgroundColor = [UIColor redColor];\n\tself.webView = webView;\n\n\t// 设置代理\n\tself.webView.navigationDelegate = self;\n\n\t// 加载的网页\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\tNSURLRequest * request = [NSURLRequest requestWithURL:URL];\n\t[self.webView loadRequest:request];\n}\n```\n### OC调用JS : JS注入 (类似UIWebView)\n``` objc\n// 页面加载完成之后调用\n- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给标签添加点击事件 : 自定义协议\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n\n\t// OC调用JS代码\n\t[webView evaluateJavaScript:JSStringM completionHandler:nil];\n}\n```\n### JS调用OC : (类似UIWebView)\n``` objc\n// 在发送请求之前，决定是否跳转\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler\n{\n\tNSLog(@\"在发送请求之前，决定是否跳转 decidePolicyForNavigationAction\");\n\n\tNSString * URLString = navigationAction.request.URL.absoluteString;\n\tNSLog(@\"监测到的WKWebView上的请求 %@\",URLString);\n\n\tNSRange range = [URLString rangeOfString:@\"custom://\"];\n\tif (range.length > 0) {\n\n\t\t[self.navigationController pushViewController:[[TestViewController alloc] init] animated:YES];\n\n\t\t// 不允许跳转,即不加载这个链接对应的内容\n\t\tdecisionHandler(WKNavigationActionPolicyCancel);\n\t} else {\n\t\t// 允许跳转,即加载这个链接对应的内容\n\t\tdecisionHandler(WKNavigationActionPolicyAllow);\n\t}\n}\n```\n\n## WKWebView 监听加载进度\n### 初始化WKWebView和进度条\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t// 创建进度条\n\tself.progress = [[UIProgressView alloc] init];\n\tself.progress.frame = CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, 10);\n\t[self.view addSubview:self.progress];\n\tself.progress.progress = 0;\n\n\t// 创建WKWebView\n\tWKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t[self.view addSubview:webView];\n\twebView.backgroundColor = [UIColor redColor];\n\tself.webView = webView;\n\n\t// 设置代理\n\tself.webView.navigationDelegate = self;\n\n\t// 加载的网页\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\tNSURLRequest * request = [NSURLRequest requestWithURL:URL];\n\t[self.webView loadRequest:request];\n\n\t// KVO添加进度监听\n\t[webView addObserver:self forKeyPath:@\"estimatedProgress\" options:NSKeyValueObservingOptionNew context:nil];\n}\n```\n### KVO监听进度\n``` objc\n- (void)observeValueForKeyPath:(NSString * )keyPath ofObject:(id)object change:(NSDictionary * )change context:(void * )context {\n\n\tif (object == self.webView && [keyPath isEqualToString:@\"estimatedProgress\"]) {\n\n\t\tCGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];\n\n\t\tNSLog(@\"进度 %f\",newprogress);\n\n\t\tif (newprogress != 1.000000) {\n\n\t\t\t// 网页加载时就展示进度\n\t\t\tself.progress.hidden = NO;\n\t\t\tself.progress.progress = newprogress;\n\n\t\t} else {\n\t\t\t// 网页加载完成就进度\n\t\t\tself.progress.hidden = YES;\n\t\t}\n\t}\n}\n```\n## WKWebView 其他\n### WKUIDelegate\n- 创建一个新的WebView\n``` objc\n-(WKWebView * )webView:(WKWebView * )webView createWebViewWithConfiguration:(WKWebViewConfiguration * )configuration forNavigationAction:(WKNavigationAction * )navigationAction windowFeatures:(WKWindowFeatures * )windowFeatures;\n```\n- 弹出警告的提示框时调用\n ``` objc\n/**\n *  弹出警告的提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           警告框中的内容\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptAlertPanelWithMessage:(NSString * )message initiatedByFrame:(void (^)())completionHandler;\n```\n- 弹出确认的提示框时调用\n``` objc\n/**\n *  弹出确认的提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           确认框中的内容\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptConfirmPanelWithMessage:(NSString * )message initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(BOOL result))completionHandler;\n```\n- 弹出输入提示框时调用\n``` objc\n/**\n *  弹出输入提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           确认框中的内容\n *  @param defaultText       默认的输入框文本信息\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptTextInputPanelWithPrompt:(NSString * )prompt defaultText:(nullable NSString * )defaultText initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;\n```\n\n### Bug Tips\nhttps://github.com/ShingoFukuyama/WKWebViewTips\n","source":"_posts/ios-uiwebview-and-jscontext-and-wkwebview.md","raw":"---\ntitle: iOS - UIWebView & JSContext & WKWebView\ndate: 2018-05-08 17:33:53\ntags: [iOS,Network,WebView]\ncategories: iOS\n---\n# UIWebView\n> A view that embeds web content in your app.\n\n## UIWebView 的JS注入\n> 案例 : 移除网页的某些不需要展示的标签\n\n- 准备网页地址 : http://m.dianping.com/tuan/deal/5501525\n\n### 浏览器终端中演示JS代码删除网页中元素\n* 需要处理的网页\n![](/images/webpage_demand_process.png)\n---\n*  网页处理的步骤\n``` javascript\n以删除导航为例 :\n  1.先找到该节点 : var headerTag = document.getElementsByTagName('header')[0];\n  2.再找到父节点 : headerTag.parentNode\n  3.最后用它的父节点删除该节点 : headerTag.parentNode.removeChild(headerTag);\n\n  合并: var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\n```\n* 删除导航\n``` javascript\nvar headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\n```\n* 删除底部悬停按钮\n``` javascript\nvar footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\n```\n* 删除底部布局\n``` javascript\nvar footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\n```\n* 处理之后的网页\n![](/images/webpage_process_after.png)\n\n---\n### OC调用JS 实现 JS注入\n> OC和JS的交互需要使用UIWebView的代理方法作为桥梁实现\n\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\t[self.webView loadRequest:[NSURLRequest requestWithURL:URL]];\n\n\t// 设置代理\n\tself.webView.delegate = self;\n}\n```\n* 网页加载完时调用的代理方法\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * ) webView;\n```\n* 网页加载完成之后,调用JS代码的OC方法\n``` objc\n- (nullable NSString * )stringByEvaluatingJavaScriptFromString:(NSString * )script;\n```\n\n### JS注入的具体实现\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// OC调用JS代码\n\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];\n}\n\n```\n\n## UIWebView监听网页标签的点击(JS调用OC)\n> 案例 : 点击网页某个标签跳转到苹果原生控制器\n> 核心思想 : 拦截webView上所有的网络请求\n\n### JS调用OC需要实现的代理方法\n``` objc\n-(BOOL) webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType;\n```\n\n### JS注入给标签添加点击事件\n- 网页标签添加点击事件\n``` objc\n[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n```\n\n- 标签的点击事件注入到JS\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给标签添加点击事件\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n\n  \t// OC调用JS代码\n\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];\n}\n```\n\n> * 给标签添加点击事件的目的 : 使标签可点击\n> * 点击事件发送网络请求的目的 : 可以拦截到标签的点击事件\n> * 自定义协议的目的 : 给事件设计一个特殊的标记,如果拦截到请求,就通过特殊的标记来区别要做的事情\n\n### 拦截webView上所有的网络请求,筛选请求\n``` objc\n/**\n 1.JS与OC交互的桥梁\n 2.可以拦截webView上所有的请求\n 3.给标签添加点击事件,点击事件主要就是发送请求;发送的请求是自定义协议的,目的是为了做标记.\n */\n- (BOOL)webView:(UIWebView * )webView shouldStartLoadWithRequest:(NSURLRequest * )request navigationType:(UIWebViewNavigationType)navigationType\n{\n\tNSLog(@\"%@\",request.URL.absoluteString);\n\n\t// 拿到网页的请求地址\n\tNSString * URLString = request.URL.absoluteString;\n\t// 判断网页的请求地址协议是否是我们自定义的那个\n\tNSRange range = [URLString rangeOfString:@\"custom://techbird.me\"];\n\tif (range.length > 0) {\n\t\t// 点击网页中的图片,实现OC原生界面的跳转\n\t\tTestViewController * VC = [[TestViewController alloc] init];\n\t\t[self.navigationController pushViewController:VC animated:YES];\n\t\treturn NO;\n\t}\n\treturn YES;\n}\n```\n# JSContext\nJSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口\n\n## JSContexts实现OC与JS交互\n- 获取上下文\n``` objc\nJSContext *context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n```\n## 使用JSContext 实现 JS调用OC\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\tNSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"]];\n\t[self.webView loadRequest:request];\n\tself.webView.delegate = self;\n\n\t// 获取上下文\n\tJSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\t// 监听图片标签点击\n\tcontext[@\"imgtag\"] = ^ {\n\t\t[self.navigationController pushViewController:[TestViewController new] animated:YES];\n\t};\n\t// 监听购买标签点击\n\tcontext[@\"buytag\"] = ^ {\n\t\t[self.navigationController pushViewController:[Test1ViewController new] animated:YES];\n\t};\n}\n```\n### 使用JSContext 实现 JS注入\n``` objc\n- (void)webViewDidFinishLoad:(UIWebView * )webView\n{\n\t// 拿到JS的上下文\n\tJSContext * context = [self.webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\n\t// 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给图片标签添加点击事件 : 自定义协议\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function imgtagclick() {imgtag();};\"];\n\n\t// 给以过期的购买标签重新添加点击事件\n\t[JSStringM appendString:@\"var buyBtnTag = document.getElementsByClassName('buy-btn btn-gray')[0]; buyBtnTag.onclick = function buybtnclick() {buytag();};\"];\n\n\t// 执行这个JS代码\n\t[context evaluateScript:JSStringM];\n}\n```\n\n# WKWebView\n> Starting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView.\n\n## WKWebView的OC和JS交互\n\n- 使用前导入头文件\n``` objc\n   #import <WebKit/WebKit.h>\n```\n\n- 遵守代理协议\n``` objc\nwebView.navigationDelegate = self;\n```\n\n### 代理方法介绍\n- 面即将开始加载时调用 (拦截网页的网络请求 : JS调用OC)\n``` objc\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;\n```\n- 页面开始加载时调用\n``` objc\n- (void)webView:(WKWebView * )webView didStartProvisionalNavigation:(WKNavigation * )navigation;\n```\n- 收到响应后,决定是否跳转,即是否把这个链接对应的网页加载到WKWebView上\n``` objc\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationResponse:(WKNavigationResponse * )navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;\n```\n- 当内容开始返回时调用,即服务器已经在向客户端发送网页数据\n``` objc\n- (void)webView:(WKWebView * )webView didCommitNavigation:(WKNavigation * )navigation;\n```\n- 页面加载完成之后调用 (OC调用JS : JS注入)\n``` objc\n- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation;\n```\n- 页面加载失败时调用\n``` objc\n- (void)webView:(WKWebView * )webView didFailProvisionalNavigation:(WKNavigation * )navigation;\n```\n### 准备WKWebView\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t// 创建WKWebView\n\tWKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t[self.view addSubview:webView];\n\twebView.backgroundColor = [UIColor redColor];\n\tself.webView = webView;\n\n\t// 设置代理\n\tself.webView.navigationDelegate = self;\n\n\t// 加载的网页\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\tNSURLRequest * request = [NSURLRequest requestWithURL:URL];\n\t[self.webView loadRequest:request];\n}\n```\n### OC调用JS : JS注入 (类似UIWebView)\n``` objc\n// 页面加载完成之后调用\n- (void)webView:(WKWebView * )webView didFinishNavigation:(WKNavigation * )navigation\n{\n\t// 拼接JS的代码\n\tNSMutableString * JSStringM = [NSMutableString string];\n\n\t// 删除导航\n\t[JSStringM appendString:@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"];\n\t// 删除底部悬停按钮\n\t[JSStringM appendString:@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"];\n\t// 删除底部布局\n\t[JSStringM appendString:@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"];\n\n\t// 给标签添加点击事件 : 自定义协议\n\t[JSStringM appendString:@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function(){window.location.href = 'custom://techbird.me'};\"];\n\n\t// OC调用JS代码\n\t[webView evaluateJavaScript:JSStringM completionHandler:nil];\n}\n```\n### JS调用OC : (类似UIWebView)\n``` objc\n// 在发送请求之前，决定是否跳转\n- (void)webView:(WKWebView * )webView decidePolicyForNavigationAction:(WKNavigationAction * )navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler\n{\n\tNSLog(@\"在发送请求之前，决定是否跳转 decidePolicyForNavigationAction\");\n\n\tNSString * URLString = navigationAction.request.URL.absoluteString;\n\tNSLog(@\"监测到的WKWebView上的请求 %@\",URLString);\n\n\tNSRange range = [URLString rangeOfString:@\"custom://\"];\n\tif (range.length > 0) {\n\n\t\t[self.navigationController pushViewController:[[TestViewController alloc] init] animated:YES];\n\n\t\t// 不允许跳转,即不加载这个链接对应的内容\n\t\tdecisionHandler(WKNavigationActionPolicyCancel);\n\t} else {\n\t\t// 允许跳转,即加载这个链接对应的内容\n\t\tdecisionHandler(WKNavigationActionPolicyAllow);\n\t}\n}\n```\n\n## WKWebView 监听加载进度\n### 初始化WKWebView和进度条\n``` objc\n- (void)viewDidLoad {\n\t[super viewDidLoad];\n\n\t// 创建进度条\n\tself.progress = [[UIProgressView alloc] init];\n\tself.progress.frame = CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, 10);\n\t[self.view addSubview:self.progress];\n\tself.progress.progress = 0;\n\n\t// 创建WKWebView\n\tWKWebView * webView = [[WKWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t[self.view addSubview:webView];\n\twebView.backgroundColor = [UIColor redColor];\n\tself.webView = webView;\n\n\t// 设置代理\n\tself.webView.navigationDelegate = self;\n\n\t// 加载的网页\n\tNSURL * URL = [NSURL URLWithString:@\"http://m.dianping.com/tuan/deal/5501525\"];\n\tNSURLRequest * request = [NSURLRequest requestWithURL:URL];\n\t[self.webView loadRequest:request];\n\n\t// KVO添加进度监听\n\t[webView addObserver:self forKeyPath:@\"estimatedProgress\" options:NSKeyValueObservingOptionNew context:nil];\n}\n```\n### KVO监听进度\n``` objc\n- (void)observeValueForKeyPath:(NSString * )keyPath ofObject:(id)object change:(NSDictionary * )change context:(void * )context {\n\n\tif (object == self.webView && [keyPath isEqualToString:@\"estimatedProgress\"]) {\n\n\t\tCGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];\n\n\t\tNSLog(@\"进度 %f\",newprogress);\n\n\t\tif (newprogress != 1.000000) {\n\n\t\t\t// 网页加载时就展示进度\n\t\t\tself.progress.hidden = NO;\n\t\t\tself.progress.progress = newprogress;\n\n\t\t} else {\n\t\t\t// 网页加载完成就进度\n\t\t\tself.progress.hidden = YES;\n\t\t}\n\t}\n}\n```\n## WKWebView 其他\n### WKUIDelegate\n- 创建一个新的WebView\n``` objc\n-(WKWebView * )webView:(WKWebView * )webView createWebViewWithConfiguration:(WKWebViewConfiguration * )configuration forNavigationAction:(WKNavigationAction * )navigationAction windowFeatures:(WKWindowFeatures * )windowFeatures;\n```\n- 弹出警告的提示框时调用\n ``` objc\n/**\n *  弹出警告的提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           警告框中的内容\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptAlertPanelWithMessage:(NSString * )message initiatedByFrame:(void (^)())completionHandler;\n```\n- 弹出确认的提示框时调用\n``` objc\n/**\n *  弹出确认的提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           确认框中的内容\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptConfirmPanelWithMessage:(NSString * )message initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(BOOL result))completionHandler;\n```\n- 弹出输入提示框时调用\n``` objc\n/**\n *  弹出输入提示框时调用\n *\n *  @param webView           实现该代理的webview\n *  @param message           确认框中的内容\n *  @param defaultText       默认的输入框文本信息\n *  @param frame             主窗口\n *  @param completionHandler 警告框消失调用\n */\n-(void)webView:(WKWebView * )webView runJavaScriptTextInputPanelWithPrompt:(NSString * )prompt defaultText:(nullable NSString * )defaultText initiatedByFrame:(WKFrameInfo * )frame completionHandler:(void (^)(NSString * __nullable result))completionHandler;\n```\n\n### Bug Tips\nhttps://github.com/ShingoFukuyama/WKWebViewTips\n","slug":"ios-uiwebview-and-jscontext-and-wkwebview","published":1,"updated":"2019-01-13T05:10:32.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d300022l1fqbqs2t7uj","content":"<h1 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h1><blockquote>\n<p>A view that embeds web content in your app.</p>\n</blockquote>\n<h2 id=\"UIWebView-的JS注入\"><a href=\"#UIWebView-的JS注入\" class=\"headerlink\" title=\"UIWebView 的JS注入\"></a>UIWebView 的JS注入</h2><blockquote>\n<p>案例 : 移除网页的某些不需要展示的标签</p>\n</blockquote>\n<ul>\n<li>准备网页地址 : <a href=\"http://m.dianping.com/tuan/deal/5501525\" target=\"_blank\" rel=\"noopener\">http://m.dianping.com/tuan/deal/5501525</a></li>\n</ul>\n<h3 id=\"浏览器终端中演示JS代码删除网页中元素\"><a href=\"#浏览器终端中演示JS代码删除网页中元素\" class=\"headerlink\" title=\"浏览器终端中演示JS代码删除网页中元素\"></a>浏览器终端中演示JS代码删除网页中元素</h3><ul>\n<li>需要处理的网页<br><img src=\"/images/webpage_demand_process.png\" alt=\"\"></li>\n</ul>\n<hr>\n<ul>\n<li><p>网页处理的步骤</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以删除导航为例 :</span><br><span class=\"line\">  <span class=\"number\">1.</span>先找到该节点 : <span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"number\">2.</span>再找到父节点 : headerTag.parentNode</span><br><span class=\"line\">  <span class=\"number\">3.</span>最后用它的父节点删除该节点 : headerTag.parentNode.removeChild(headerTag);</span><br><span class=\"line\"></span><br><span class=\"line\">  合并: <span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];headerTag.parentNode.removeChild(headerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除导航</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];headerTag.parentNode.removeChild(headerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除底部悬停按钮</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> footerBtnTag = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'footer-btn-fix'</span>)[<span class=\"number\">0</span>]; footerBtnTag.parentNode.removeChild(footerBtnTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除底部布局</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> footerTag = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'footer'</span>)[<span class=\"number\">0</span>]; footerTag.parentNode.removeChild(footerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理之后的网页<br><img src=\"/images/webpage_process_after.png\" alt=\"\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"OC调用JS-实现-JS注入\"><a href=\"#OC调用JS-实现-JS注入\" class=\"headerlink\" title=\"OC调用JS 实现 JS注入\"></a>OC调用JS 实现 JS注入</h3><blockquote>\n<p>OC和JS的交互需要使用UIWebView的代理方法作为桥梁实现</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:[<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL]];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>网页加载完时调用的代理方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * ) webView;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>网页加载完成之后,调用JS代码的OC方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> * )stringByEvaluatingJavaScriptFromString:(<span class=\"built_in\">NSString</span> * )script;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"JS注入的具体实现\"><a href=\"#JS注入的具体实现\" class=\"headerlink\" title=\"JS注入的具体实现\"></a>JS注入的具体实现</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"UIWebView监听网页标签的点击-JS调用OC\"><a href=\"#UIWebView监听网页标签的点击-JS调用OC\" class=\"headerlink\" title=\"UIWebView监听网页标签的点击(JS调用OC)\"></a>UIWebView监听网页标签的点击(JS调用OC)</h2><blockquote>\n<p>案例 : 点击网页某个标签跳转到苹果原生控制器<br>核心思想 : 拦截webView上所有的网络请求</p>\n</blockquote>\n<h3 id=\"JS调用OC需要实现的代理方法\"><a href=\"#JS调用OC需要实现的代理方法\" class=\"headerlink\" title=\"JS调用OC需要实现的代理方法\"></a>JS调用OC需要实现的代理方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">BOOL</span>) webView:(<span class=\"built_in\">UIWebView</span> * )webView shouldStartLoadWithRequest:(<span class=\"built_in\">NSURLRequest</span> * )request navigationType:(<span class=\"built_in\">UIWebViewNavigationType</span>)navigationType;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS注入给标签添加点击事件\"><a href=\"#JS注入给标签添加点击事件\" class=\"headerlink\" title=\"JS注入给标签添加点击事件\"></a>JS注入给标签添加点击事件</h3><ul>\n<li><p>网页标签添加点击事件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标签的点击事件注入到JS</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给标签添加点击事件</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>给标签添加点击事件的目的 : 使标签可点击</li>\n<li>点击事件发送网络请求的目的 : 可以拦截到标签的点击事件</li>\n<li>自定义协议的目的 : 给事件设计一个特殊的标记,如果拦截到请求,就通过特殊的标记来区别要做的事情</li>\n</ul>\n</blockquote>\n<h3 id=\"拦截webView上所有的网络请求-筛选请求\"><a href=\"#拦截webView上所有的网络请求-筛选请求\" class=\"headerlink\" title=\"拦截webView上所有的网络请求,筛选请求\"></a>拦截webView上所有的网络请求,筛选请求</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 1.JS与OC交互的桥梁</span></span><br><span class=\"line\"><span class=\"comment\"> 2.可以拦截webView上所有的请求</span></span><br><span class=\"line\"><span class=\"comment\"> 3.给标签添加点击事件,点击事件主要就是发送请求;发送的请求是自定义协议的,目的是为了做标记.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)webView:(<span class=\"built_in\">UIWebView</span> * )webView shouldStartLoadWithRequest:(<span class=\"built_in\">NSURLRequest</span> * )request navigationType:(<span class=\"built_in\">UIWebViewNavigationType</span>)navigationType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,request.URL.absoluteString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 拿到网页的请求地址</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> * URLString = request.URL.absoluteString;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断网页的请求地址协议是否是我们自定义的那个</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSRange</span> range = [URLString rangeOfString:<span class=\"string\">@\"custom://techbird.me\"</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 点击网页中的图片,实现OC原生界面的跳转</span></span><br><span class=\"line\">\t\tTestViewController * VC = [[TestViewController alloc] init];</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:VC animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSContext\"><a href=\"#JSContext\" class=\"headerlink\" title=\"JSContext\"></a>JSContext</h1><p>JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口</p>\n<h2 id=\"JSContexts实现OC与JS交互\"><a href=\"#JSContexts实现OC与JS交互\" class=\"headerlink\" title=\"JSContexts实现OC与JS交互\"></a>JSContexts实现OC与JS交互</h2><ul>\n<li>获取上下文<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSContext *context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"使用JSContext-实现-JS调用OC\"><a href=\"#使用JSContext-实现-JS调用OC\" class=\"headerlink\" title=\"使用JSContext 实现 JS调用OC\"></a>使用JSContext 实现 JS调用OC</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>]];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取上下文</span></span><br><span class=\"line\">\tJSContext * context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 监听图片标签点击</span></span><br><span class=\"line\">\tcontext[<span class=\"string\">@\"imgtag\"</span>] = ^ &#123;</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[TestViewController new] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 监听购买标签点击</span></span><br><span class=\"line\">\tcontext[<span class=\"string\">@\"buytag\"</span>] = ^ &#123;</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[Test1ViewController new] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用JSContext-实现-JS注入\"><a href=\"#使用JSContext-实现-JS注入\" class=\"headerlink\" title=\"使用JSContext 实现 JS注入\"></a>使用JSContext 实现 JS注入</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拿到JS的上下文</span></span><br><span class=\"line\">\tJSContext * context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message</span></span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给图片标签添加点击事件 : 自定义协议</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function imgtagclick() &#123;imgtag();&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给以过期的购买标签重新添加点击事件</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var buyBtnTag = document.getElementsByClassName('buy-btn btn-gray')[0]; buyBtnTag.onclick = function buybtnclick() &#123;buytag();&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 执行这个JS代码</span></span><br><span class=\"line\">\t[context evaluateScript:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"WKWebView\"><a href=\"#WKWebView\" class=\"headerlink\" title=\"WKWebView\"></a>WKWebView</h1><blockquote>\n<p>Starting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView.</p>\n</blockquote>\n<h2 id=\"WKWebView的OC和JS交互\"><a href=\"#WKWebView的OC和JS交互\" class=\"headerlink\" title=\"WKWebView的OC和JS交互\"></a>WKWebView的OC和JS交互</h2><ul>\n<li><p>使用前导入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;WebKit/WebKit.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>遵守代理协议</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"代理方法介绍\"><a href=\"#代理方法介绍\" class=\"headerlink\" title=\"代理方法介绍\"></a>代理方法介绍</h3><ul>\n<li><p>面即将开始加载时调用 (拦截网页的网络请求 : JS调用OC)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面开始加载时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didStartProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>收到响应后,决定是否跳转,即是否把这个链接对应的网页加载到WKWebView上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationResponse:(<span class=\"built_in\">WKNavigationResponse</span> * )navigationResponse decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationResponsePolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当内容开始返回时调用,即服务器已经在向客户端发送网页数据</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didCommitNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面加载完成之后调用 (OC调用JS : JS注入)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFinishNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面加载失败时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFailProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"准备WKWebView\"><a href=\"#准备WKWebView\" class=\"headerlink\" title=\"准备WKWebView\"></a>准备WKWebView</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建WKWebView</span></span><br><span class=\"line\">\t<span class=\"built_in\">WKWebView</span> * webView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:[<span class=\"built_in\">UIScreen</span> mainScreen].bounds];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:webView];</span><br><span class=\"line\">\twebView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView = webView;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载的网页</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"OC调用JS-JS注入-类似UIWebView\"><a href=\"#OC调用JS-JS注入-类似UIWebView\" class=\"headerlink\" title=\"OC调用JS : JS注入 (类似UIWebView)\"></a>OC调用JS : JS注入 (类似UIWebView)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 页面加载完成之后调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFinishNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给标签添加点击事件 : 自定义协议</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView evaluateJavaScript:JSStringM completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS调用OC-类似UIWebView\"><a href=\"#JS调用OC-类似UIWebView\" class=\"headerlink\" title=\"JS调用OC : (类似UIWebView)\"></a>JS调用OC : (类似UIWebView)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在发送请求之前，决定是否跳转</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"在发送请求之前，决定是否跳转 decidePolicyForNavigationAction\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> * URLString = navigationAction.request.URL.absoluteString;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"监测到的WKWebView上的请求 %@\"</span>,URLString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSRange</span> range = [URLString rangeOfString:<span class=\"string\">@\"custom://\"</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[[TestViewController alloc] init] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 不允许跳转,即不加载这个链接对应的内容</span></span><br><span class=\"line\">\t\tdecisionHandler(<span class=\"built_in\">WKNavigationActionPolicyCancel</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 允许跳转,即加载这个链接对应的内容</span></span><br><span class=\"line\">\t\tdecisionHandler(<span class=\"built_in\">WKNavigationActionPolicyAllow</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WKWebView-监听加载进度\"><a href=\"#WKWebView-监听加载进度\" class=\"headerlink\" title=\"WKWebView 监听加载进度\"></a>WKWebView 监听加载进度</h2><h3 id=\"初始化WKWebView和进度条\"><a href=\"#初始化WKWebView和进度条\" class=\"headerlink\" title=\"初始化WKWebView和进度条\"></a>初始化WKWebView和进度条</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建进度条</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress = [[<span class=\"built_in\">UIProgressView</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">64</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.progress];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress.progress = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建WKWebView</span></span><br><span class=\"line\">\t<span class=\"built_in\">WKWebView</span> * webView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:[<span class=\"built_in\">UIScreen</span> mainScreen].bounds];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:webView];</span><br><span class=\"line\">\twebView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView = webView;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载的网页</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// KVO添加进度监听</span></span><br><span class=\"line\">\t[webView addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"estimatedProgress\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KVO监听进度\"><a href=\"#KVO监听进度\" class=\"headerlink\" title=\"KVO监听进度\"></a>KVO监听进度</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> * )change context:(<span class=\"keyword\">void</span> * )context &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (object == <span class=\"keyword\">self</span>.webView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"estimatedProgress\"</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">CGFloat</span> newprogress = [[change objectForKey:<span class=\"built_in\">NSKeyValueChangeNewKey</span>] doubleValue];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"进度 %f\"</span>,newprogress);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (newprogress != <span class=\"number\">1.000000</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 网页加载时就展示进度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.hidden = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.progress = newprogress;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 网页加载完成就进度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.hidden = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WKWebView-其他\"><a href=\"#WKWebView-其他\" class=\"headerlink\" title=\"WKWebView 其他\"></a>WKWebView 其他</h2><h3 id=\"WKUIDelegate\"><a href=\"#WKUIDelegate\" class=\"headerlink\" title=\"WKUIDelegate\"></a>WKUIDelegate</h3><ul>\n<li><p>创建一个新的WebView</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">WKWebView</span> * )webView:(<span class=\"built_in\">WKWebView</span> * )webView createWebViewWithConfiguration:(<span class=\"built_in\">WKWebViewConfiguration</span> * )configuration forNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction windowFeatures:(<span class=\"built_in\">WKWindowFeatures</span> * )windowFeatures;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出警告的提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出警告的提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           警告框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptAlertPanelWithMessage:(<span class=\"built_in\">NSString</span> * )message initiatedByFrame:(<span class=\"keyword\">void</span> (^)())completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出确认的提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出确认的提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           确认框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptConfirmPanelWithMessage:(<span class=\"built_in\">NSString</span> * )message initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> * )frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">BOOL</span> result))completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出输入提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出输入提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           确认框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param defaultText       默认的输入框文本信息</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptTextInputPanelWithPrompt:(<span class=\"built_in\">NSString</span> * )prompt defaultText:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> * )defaultText initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> * )frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span> * __<span class=\"keyword\">nullable</span> result))completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Bug-Tips\"><a href=\"#Bug-Tips\" class=\"headerlink\" title=\"Bug Tips\"></a>Bug Tips</h3><p><a href=\"https://github.com/ShingoFukuyama/WKWebViewTips\" target=\"_blank\" rel=\"noopener\">https://github.com/ShingoFukuyama/WKWebViewTips</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h1><blockquote>\n<p>A view that embeds web content in your app.</p>\n</blockquote>\n<h2 id=\"UIWebView-的JS注入\"><a href=\"#UIWebView-的JS注入\" class=\"headerlink\" title=\"UIWebView 的JS注入\"></a>UIWebView 的JS注入</h2><blockquote>\n<p>案例 : 移除网页的某些不需要展示的标签</p>\n</blockquote>\n<ul>\n<li>准备网页地址 : <a href=\"http://m.dianping.com/tuan/deal/5501525\" target=\"_blank\" rel=\"noopener\">http://m.dianping.com/tuan/deal/5501525</a></li>\n</ul>\n<h3 id=\"浏览器终端中演示JS代码删除网页中元素\"><a href=\"#浏览器终端中演示JS代码删除网页中元素\" class=\"headerlink\" title=\"浏览器终端中演示JS代码删除网页中元素\"></a>浏览器终端中演示JS代码删除网页中元素</h3><ul>\n<li>需要处理的网页<br><img src=\"/images/webpage_demand_process.png\" alt=\"\"></li>\n</ul>\n<hr>\n<ul>\n<li><p>网页处理的步骤</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以删除导航为例 :</span><br><span class=\"line\">  <span class=\"number\">1.</span>先找到该节点 : <span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"number\">2.</span>再找到父节点 : headerTag.parentNode</span><br><span class=\"line\">  <span class=\"number\">3.</span>最后用它的父节点删除该节点 : headerTag.parentNode.removeChild(headerTag);</span><br><span class=\"line\"></span><br><span class=\"line\">  合并: <span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];headerTag.parentNode.removeChild(headerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除导航</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headerTag = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'header'</span>)[<span class=\"number\">0</span>];headerTag.parentNode.removeChild(headerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除底部悬停按钮</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> footerBtnTag = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'footer-btn-fix'</span>)[<span class=\"number\">0</span>]; footerBtnTag.parentNode.removeChild(footerBtnTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除底部布局</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> footerTag = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'footer'</span>)[<span class=\"number\">0</span>]; footerTag.parentNode.removeChild(footerTag);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理之后的网页<br><img src=\"/images/webpage_process_after.png\" alt=\"\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"OC调用JS-实现-JS注入\"><a href=\"#OC调用JS-实现-JS注入\" class=\"headerlink\" title=\"OC调用JS 实现 JS注入\"></a>OC调用JS 实现 JS注入</h3><blockquote>\n<p>OC和JS的交互需要使用UIWebView的代理方法作为桥梁实现</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:[<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL]];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>网页加载完时调用的代理方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * ) webView;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>网页加载完成之后,调用JS代码的OC方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> * )stringByEvaluatingJavaScriptFromString:(<span class=\"built_in\">NSString</span> * )script;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"JS注入的具体实现\"><a href=\"#JS注入的具体实现\" class=\"headerlink\" title=\"JS注入的具体实现\"></a>JS注入的具体实现</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"UIWebView监听网页标签的点击-JS调用OC\"><a href=\"#UIWebView监听网页标签的点击-JS调用OC\" class=\"headerlink\" title=\"UIWebView监听网页标签的点击(JS调用OC)\"></a>UIWebView监听网页标签的点击(JS调用OC)</h2><blockquote>\n<p>案例 : 点击网页某个标签跳转到苹果原生控制器<br>核心思想 : 拦截webView上所有的网络请求</p>\n</blockquote>\n<h3 id=\"JS调用OC需要实现的代理方法\"><a href=\"#JS调用OC需要实现的代理方法\" class=\"headerlink\" title=\"JS调用OC需要实现的代理方法\"></a>JS调用OC需要实现的代理方法</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">BOOL</span>) webView:(<span class=\"built_in\">UIWebView</span> * )webView shouldStartLoadWithRequest:(<span class=\"built_in\">NSURLRequest</span> * )request navigationType:(<span class=\"built_in\">UIWebViewNavigationType</span>)navigationType;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS注入给标签添加点击事件\"><a href=\"#JS注入给标签添加点击事件\" class=\"headerlink\" title=\"JS注入给标签添加点击事件\"></a>JS注入给标签添加点击事件</h3><ul>\n<li><p>网页标签添加点击事件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标签的点击事件注入到JS</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给标签添加点击事件</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  \t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView stringByEvaluatingJavaScriptFromString:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>给标签添加点击事件的目的 : 使标签可点击</li>\n<li>点击事件发送网络请求的目的 : 可以拦截到标签的点击事件</li>\n<li>自定义协议的目的 : 给事件设计一个特殊的标记,如果拦截到请求,就通过特殊的标记来区别要做的事情</li>\n</ul>\n</blockquote>\n<h3 id=\"拦截webView上所有的网络请求-筛选请求\"><a href=\"#拦截webView上所有的网络请求-筛选请求\" class=\"headerlink\" title=\"拦截webView上所有的网络请求,筛选请求\"></a>拦截webView上所有的网络请求,筛选请求</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> 1.JS与OC交互的桥梁</span></span><br><span class=\"line\"><span class=\"comment\"> 2.可以拦截webView上所有的请求</span></span><br><span class=\"line\"><span class=\"comment\"> 3.给标签添加点击事件,点击事件主要就是发送请求;发送的请求是自定义协议的,目的是为了做标记.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)webView:(<span class=\"built_in\">UIWebView</span> * )webView shouldStartLoadWithRequest:(<span class=\"built_in\">NSURLRequest</span> * )request navigationType:(<span class=\"built_in\">UIWebViewNavigationType</span>)navigationType</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,request.URL.absoluteString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 拿到网页的请求地址</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> * URLString = request.URL.absoluteString;</span><br><span class=\"line\">\t<span class=\"comment\">// 判断网页的请求地址协议是否是我们自定义的那个</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSRange</span> range = [URLString rangeOfString:<span class=\"string\">@\"custom://techbird.me\"</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 点击网页中的图片,实现OC原生界面的跳转</span></span><br><span class=\"line\">\t\tTestViewController * VC = [[TestViewController alloc] init];</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:VC animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"JSContext\"><a href=\"#JSContext\" class=\"headerlink\" title=\"JSContext\"></a>JSContext</h1><p>JSContext是JavaScript的运行上下文，他主要作用是执行js代码和注册native方法接口</p>\n<h2 id=\"JSContexts实现OC与JS交互\"><a href=\"#JSContexts实现OC与JS交互\" class=\"headerlink\" title=\"JSContexts实现OC与JS交互\"></a>JSContexts实现OC与JS交互</h2><ul>\n<li>获取上下文<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSContext *context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"使用JSContext-实现-JS调用OC\"><a href=\"#使用JSContext-实现-JS调用OC\" class=\"headerlink\" title=\"使用JSContext 实现 JS调用OC\"></a>使用JSContext 实现 JS调用OC</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:[<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>]];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取上下文</span></span><br><span class=\"line\">\tJSContext * context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 监听图片标签点击</span></span><br><span class=\"line\">\tcontext[<span class=\"string\">@\"imgtag\"</span>] = ^ &#123;</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[TestViewController new] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 监听购买标签点击</span></span><br><span class=\"line\">\tcontext[<span class=\"string\">@\"buytag\"</span>] = ^ &#123;</span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[Test1ViewController new] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用JSContext-实现-JS注入\"><a href=\"#使用JSContext-实现-JS注入\" class=\"headerlink\" title=\"使用JSContext 实现 JS注入\"></a>使用JSContext 实现 JS注入</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webViewDidFinishLoad:(<span class=\"built_in\">UIWebView</span> * )webView</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拿到JS的上下文</span></span><br><span class=\"line\">\tJSContext * context = [<span class=\"keyword\">self</span>.webView valueForKeyPath:<span class=\"string\">@\"documentView.webView.mainFrame.javaScriptContext\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 直接调用JS的函数,还可以向函数里面传入需要的参数.在XCode中向JS中的alert传入需要的message</span></span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给图片标签添加点击事件 : 自定义协议</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function imgtagclick() &#123;imgtag();&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给以过期的购买标签重新添加点击事件</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var buyBtnTag = document.getElementsByClassName('buy-btn btn-gray')[0]; buyBtnTag.onclick = function buybtnclick() &#123;buytag();&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 执行这个JS代码</span></span><br><span class=\"line\">\t[context evaluateScript:JSStringM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"WKWebView\"><a href=\"#WKWebView\" class=\"headerlink\" title=\"WKWebView\"></a>WKWebView</h1><blockquote>\n<p>Starting in iOS 8.0 and OS X 10.10, use WKWebView to add web content to your app. Do not use UIWebView or WebView.</p>\n</blockquote>\n<h2 id=\"WKWebView的OC和JS交互\"><a href=\"#WKWebView的OC和JS交互\" class=\"headerlink\" title=\"WKWebView的OC和JS交互\"></a>WKWebView的OC和JS交互</h2><ul>\n<li><p>使用前导入头文件</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;WebKit/WebKit.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>遵守代理协议</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"代理方法介绍\"><a href=\"#代理方法介绍\" class=\"headerlink\" title=\"代理方法介绍\"></a>代理方法介绍</h3><ul>\n<li><p>面即将开始加载时调用 (拦截网页的网络请求 : JS调用OC)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面开始加载时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didStartProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>收到响应后,决定是否跳转,即是否把这个链接对应的网页加载到WKWebView上</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationResponse:(<span class=\"built_in\">WKNavigationResponse</span> * )navigationResponse decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationResponsePolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当内容开始返回时调用,即服务器已经在向客户端发送网页数据</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didCommitNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面加载完成之后调用 (OC调用JS : JS注入)</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFinishNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>页面加载失败时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFailProvisionalNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"准备WKWebView\"><a href=\"#准备WKWebView\" class=\"headerlink\" title=\"准备WKWebView\"></a>准备WKWebView</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建WKWebView</span></span><br><span class=\"line\">\t<span class=\"built_in\">WKWebView</span> * webView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:[<span class=\"built_in\">UIScreen</span> mainScreen].bounds];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:webView];</span><br><span class=\"line\">\twebView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView = webView;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载的网页</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"OC调用JS-JS注入-类似UIWebView\"><a href=\"#OC调用JS-JS注入-类似UIWebView\" class=\"headerlink\" title=\"OC调用JS : JS注入 (类似UIWebView)\"></a>OC调用JS : JS注入 (类似UIWebView)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 页面加载完成之后调用</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView didFinishNavigation:(<span class=\"built_in\">WKNavigation</span> * )navigation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 拼接JS的代码</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableString</span> * JSStringM = [<span class=\"built_in\">NSMutableString</span> string];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除导航</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var headerTag = document.getElementsByTagName('header')[0];headerTag.parentNode.removeChild(headerTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部悬停按钮</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerBtnTag = document.getElementsByClassName('footer-btn-fix')[0]; footerBtnTag.parentNode.removeChild(footerBtnTag);\"</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// 删除底部布局</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var footerTag = document.getElementsByClassName('footer')[0]; footerTag.parentNode.removeChild(footerTag);\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 给标签添加点击事件 : 自定义协议</span></span><br><span class=\"line\">\t[JSStringM appendString:<span class=\"string\">@\"var figureTag = document.getElementsByTagName('figure')[0].children[0]; figureTag.onclick = function()&#123;window.location.href = 'custom://techbird.me'&#125;;\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// OC调用JS代码</span></span><br><span class=\"line\">\t[webView evaluateJavaScript:JSStringM completionHandler:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JS调用OC-类似UIWebView\"><a href=\"#JS调用OC-类似UIWebView\" class=\"headerlink\" title=\"JS调用OC : (类似UIWebView)\"></a>JS调用OC : (类似UIWebView)</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在发送请求之前，决定是否跳转</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView decidePolicyForNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction decisionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"在发送请求之前，决定是否跳转 decidePolicyForNavigationAction\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSString</span> * URLString = navigationAction.request.URL.absoluteString;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"监测到的WKWebView上的请求 %@\"</span>,URLString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">NSRange</span> range = [URLString rangeOfString:<span class=\"string\">@\"custom://\"</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (range.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t[<span class=\"keyword\">self</span>.navigationController pushViewController:[[TestViewController alloc] init] animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 不允许跳转,即不加载这个链接对应的内容</span></span><br><span class=\"line\">\t\tdecisionHandler(<span class=\"built_in\">WKNavigationActionPolicyCancel</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 允许跳转,即加载这个链接对应的内容</span></span><br><span class=\"line\">\t\tdecisionHandler(<span class=\"built_in\">WKNavigationActionPolicyAllow</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WKWebView-监听加载进度\"><a href=\"#WKWebView-监听加载进度\" class=\"headerlink\" title=\"WKWebView 监听加载进度\"></a>WKWebView 监听加载进度</h2><h3 id=\"初始化WKWebView和进度条\"><a href=\"#初始化WKWebView和进度条\" class=\"headerlink\" title=\"初始化WKWebView和进度条\"></a>初始化WKWebView和进度条</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">\t[<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建进度条</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress = [[<span class=\"built_in\">UIProgressView</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">64</span>, [<span class=\"built_in\">UIScreen</span> mainScreen].bounds.size.width, <span class=\"number\">10</span>);</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:<span class=\"keyword\">self</span>.progress];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.progress.progress = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建WKWebView</span></span><br><span class=\"line\">\t<span class=\"built_in\">WKWebView</span> * webView = [[<span class=\"built_in\">WKWebView</span> alloc] initWithFrame:[<span class=\"built_in\">UIScreen</span> mainScreen].bounds];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.view addSubview:webView];</span><br><span class=\"line\">\twebView.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView = webView;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 设置代理</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.webView.navigationDelegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载的网页</span></span><br><span class=\"line\">\t<span class=\"built_in\">NSURL</span> * URL = [<span class=\"built_in\">NSURL</span> URLWithString:<span class=\"string\">@\"http://m.dianping.com/tuan/deal/5501525\"</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">NSURLRequest</span> * request = [<span class=\"built_in\">NSURLRequest</span> requestWithURL:URL];</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span>.webView loadRequest:request];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// KVO添加进度监听</span></span><br><span class=\"line\">\t[webView addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"estimatedProgress\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"KVO监听进度\"><a href=\"#KVO监听进度\" class=\"headerlink\" title=\"KVO监听进度\"></a>KVO监听进度</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> * )keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span> * )change context:(<span class=\"keyword\">void</span> * )context &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (object == <span class=\"keyword\">self</span>.webView &amp;&amp; [keyPath isEqualToString:<span class=\"string\">@\"estimatedProgress\"</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">CGFloat</span> newprogress = [[change objectForKey:<span class=\"built_in\">NSKeyValueChangeNewKey</span>] doubleValue];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"进度 %f\"</span>,newprogress);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (newprogress != <span class=\"number\">1.000000</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 网页加载时就展示进度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.hidden = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.progress = newprogress;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 网页加载完成就进度</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">self</span>.progress.hidden = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"WKWebView-其他\"><a href=\"#WKWebView-其他\" class=\"headerlink\" title=\"WKWebView 其他\"></a>WKWebView 其他</h2><h3 id=\"WKUIDelegate\"><a href=\"#WKUIDelegate\" class=\"headerlink\" title=\"WKUIDelegate\"></a>WKUIDelegate</h3><ul>\n<li><p>创建一个新的WebView</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"built_in\">WKWebView</span> * )webView:(<span class=\"built_in\">WKWebView</span> * )webView createWebViewWithConfiguration:(<span class=\"built_in\">WKWebViewConfiguration</span> * )configuration forNavigationAction:(<span class=\"built_in\">WKNavigationAction</span> * )navigationAction windowFeatures:(<span class=\"built_in\">WKWindowFeatures</span> * )windowFeatures;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出警告的提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出警告的提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           警告框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptAlertPanelWithMessage:(<span class=\"built_in\">NSString</span> * )message initiatedByFrame:(<span class=\"keyword\">void</span> (^)())completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出确认的提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出确认的提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           确认框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptConfirmPanelWithMessage:(<span class=\"built_in\">NSString</span> * )message initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> * )frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">BOOL</span> result))completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>弹出输入提示框时调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  弹出输入提示框时调用</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param webView           实现该代理的webview</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param message           确认框中的内容</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param defaultText       默认的输入框文本信息</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param frame             主窗口</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param completionHandler 警告框消失调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)webView:(<span class=\"built_in\">WKWebView</span> * )webView runJavaScriptTextInputPanelWithPrompt:(<span class=\"built_in\">NSString</span> * )prompt defaultText:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> * )defaultText initiatedByFrame:(<span class=\"built_in\">WKFrameInfo</span> * )frame completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">NSString</span> * __<span class=\"keyword\">nullable</span> result))completionHandler;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Bug-Tips\"><a href=\"#Bug-Tips\" class=\"headerlink\" title=\"Bug Tips\"></a>Bug Tips</h3><p><a href=\"https://github.com/ShingoFukuyama/WKWebViewTips\" target=\"_blank\" rel=\"noopener\">https://github.com/ShingoFukuyama/WKWebViewTips</a></p>\n"},{"title":"线性代数的知识结构图","date":"2018-07-15T16:42:17.000Z","_content":"如题，给「线性代数」做了点小总结。\n\n## 行列式\n![行列式](/images/linearmaths_det.png)\n## 矩阵\n![矩阵](/images/linearmaths_matrix.png)\n## n维向量\n![n维向量](/images/linearmaths_vector.png)\n## 线性方程组\n![线性方程组](/images/linearmaths_equations.png)\n## 特征值/特征向量\n![特征值/特征向量](/images/linearmaths_eigenvalue.png)\n## 二次型\n![二次型](/images/linearmaths_quadratic.png)\n","source":"_posts/linear-maths.md","raw":"---\ntitle: 线性代数的知识结构图\ndate: 2018-07-16 00:42:17\n---\n如题，给「线性代数」做了点小总结。\n\n## 行列式\n![行列式](/images/linearmaths_det.png)\n## 矩阵\n![矩阵](/images/linearmaths_matrix.png)\n## n维向量\n![n维向量](/images/linearmaths_vector.png)\n## 线性方程组\n![线性方程组](/images/linearmaths_equations.png)\n## 特征值/特征向量\n![特征值/特征向量](/images/linearmaths_eigenvalue.png)\n## 二次型\n![二次型](/images/linearmaths_quadratic.png)\n","slug":"linear-maths","published":1,"updated":"2019-01-13T05:09:04.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d310025l1fqnpz6gmp1","content":"<p>如题，给「线性代数」做了点小总结。</p>\n<h2 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h2><p><img src=\"/images/linearmaths_det.png\" alt=\"行列式\"></p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><p><img src=\"/images/linearmaths_matrix.png\" alt=\"矩阵\"></p>\n<h2 id=\"n维向量\"><a href=\"#n维向量\" class=\"headerlink\" title=\"n维向量\"></a>n维向量</h2><p><img src=\"/images/linearmaths_vector.png\" alt=\"n维向量\"></p>\n<h2 id=\"线性方程组\"><a href=\"#线性方程组\" class=\"headerlink\" title=\"线性方程组\"></a>线性方程组</h2><p><img src=\"/images/linearmaths_equations.png\" alt=\"线性方程组\"></p>\n<h2 id=\"特征值-特征向量\"><a href=\"#特征值-特征向量\" class=\"headerlink\" title=\"特征值/特征向量\"></a>特征值/特征向量</h2><p><img src=\"/images/linearmaths_eigenvalue.png\" alt=\"特征值/特征向量\"></p>\n<h2 id=\"二次型\"><a href=\"#二次型\" class=\"headerlink\" title=\"二次型\"></a>二次型</h2><p><img src=\"/images/linearmaths_quadratic.png\" alt=\"二次型\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如题，给「线性代数」做了点小总结。</p>\n<h2 id=\"行列式\"><a href=\"#行列式\" class=\"headerlink\" title=\"行列式\"></a>行列式</h2><p><img src=\"/images/linearmaths_det.png\" alt=\"行列式\"></p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><p><img src=\"/images/linearmaths_matrix.png\" alt=\"矩阵\"></p>\n<h2 id=\"n维向量\"><a href=\"#n维向量\" class=\"headerlink\" title=\"n维向量\"></a>n维向量</h2><p><img src=\"/images/linearmaths_vector.png\" alt=\"n维向量\"></p>\n<h2 id=\"线性方程组\"><a href=\"#线性方程组\" class=\"headerlink\" title=\"线性方程组\"></a>线性方程组</h2><p><img src=\"/images/linearmaths_equations.png\" alt=\"线性方程组\"></p>\n<h2 id=\"特征值-特征向量\"><a href=\"#特征值-特征向量\" class=\"headerlink\" title=\"特征值/特征向量\"></a>特征值/特征向量</h2><p><img src=\"/images/linearmaths_eigenvalue.png\" alt=\"特征值/特征向量\"></p>\n<h2 id=\"二次型\"><a href=\"#二次型\" class=\"headerlink\" title=\"二次型\"></a>二次型</h2><p><img src=\"/images/linearmaths_quadratic.png\" alt=\"二次型\"></p>\n"},{"title":"平凡的世界","date":"2018-01-09T02:01:47.000Z","_content":"\n## 平凡的世界\n\n![平凡的世界](/images/read/read_pfdsj.JPG)\n> 不要见怪，不要见外，田。\n> 命运总是不如人愿。\n> 但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来。\n>虽然这些东西在实际感受中给人带来的并不都是欢乐。\n\n坦率的说，我是没有‘勇气’来写自己对着这本书的感受的，因为在书中我热爱的每一个角色，都没有得到我预想的故事的结局。比如我是不能释怀田晓霞的离去的，也请原谅我是这么的狭隘，不能理解所谓的社会背景下就应该有怎样的结局，故事在作者厚重的笔下让我喘不过气，让我难受，让我忍不住为他们的苦难泪眼迷蒙。\n\n是的，我想要晓霞去赴古塔山杜梨树下与少平一点四十五分的约定！我不能接受田晓霞的死去，孙少平与田晓霞的爱情故事是这部现实主义小说中最为浪漫的一道彩虹，他们让我知道真正的爱情是超越门第，超越贫富，甚至超越生死的。虽然他们的社会身份有着巨大的差异，但在思想上却达到完美的融合。他们被彼此的气质所吸引，在海阔天空的思想交流中建立起深厚的友谊，而后又在更深的理解中将友情升华为爱情。这样的爱情稳固而坚贞，能够经受岁月的磨砺而焕然如新。\n\n也是的，生活中无处不有纠结与挣扎，而现实与精神的双重痛苦常常使人彻底堕落，只有在无比的痛苦中还能巍然站立，有力把握着生活马车的车辕的人才是真正的强者！孙少安和孙少平就是这样的强者，他们经历过巨大的艰难与痛苦，却把艰难痛苦都当作人生的财富，始终紧握生活的马鞭，奔向各自道路的未知远方。\n\n伟大的作品是用平实的语言去描写亘古不变的人情人性，虽然路遥的身躯早已回归到最亲爱的大地中去，而他却从未远离我们，因为他早已把灵魂注入到书中字里行间。他是孙少平，是小说中的每一处花开花落，草长莺飞，更是人物内心微妙地悸动和涌起地波澜。而这些融入他所有生命精华的著作也必将留芳于世，感动着现在以及以后的人们。\n\n后记：在2018年研究生考试结束之后读这本书对我来说是合适的，《平凡的世界》之所以能感动这么多人是因为展现出平凡人在艰难的生活中仍能保持高尚的精神和灵魂，永远用一种积极向上的态度去面对一切苦难，相比于生活赐予少平的苦难和他对待生活的态度也只会使我更有勇气去面对未来我将要经历的一切…\n\n2018/01/09 北京","source":"_posts/read-pfdsj.md","raw":"---\ntitle: 平凡的世界\ndate: 2018-01-09 10:01:47\ntags: [Readed]\ncategories: Readed\n---\n\n## 平凡的世界\n\n![平凡的世界](/images/read/read_pfdsj.JPG)\n> 不要见怪，不要见外，田。\n> 命运总是不如人愿。\n> 但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来。\n>虽然这些东西在实际感受中给人带来的并不都是欢乐。\n\n坦率的说，我是没有‘勇气’来写自己对着这本书的感受的，因为在书中我热爱的每一个角色，都没有得到我预想的故事的结局。比如我是不能释怀田晓霞的离去的，也请原谅我是这么的狭隘，不能理解所谓的社会背景下就应该有怎样的结局，故事在作者厚重的笔下让我喘不过气，让我难受，让我忍不住为他们的苦难泪眼迷蒙。\n\n是的，我想要晓霞去赴古塔山杜梨树下与少平一点四十五分的约定！我不能接受田晓霞的死去，孙少平与田晓霞的爱情故事是这部现实主义小说中最为浪漫的一道彩虹，他们让我知道真正的爱情是超越门第，超越贫富，甚至超越生死的。虽然他们的社会身份有着巨大的差异，但在思想上却达到完美的融合。他们被彼此的气质所吸引，在海阔天空的思想交流中建立起深厚的友谊，而后又在更深的理解中将友情升华为爱情。这样的爱情稳固而坚贞，能够经受岁月的磨砺而焕然如新。\n\n也是的，生活中无处不有纠结与挣扎，而现实与精神的双重痛苦常常使人彻底堕落，只有在无比的痛苦中还能巍然站立，有力把握着生活马车的车辕的人才是真正的强者！孙少安和孙少平就是这样的强者，他们经历过巨大的艰难与痛苦，却把艰难痛苦都当作人生的财富，始终紧握生活的马鞭，奔向各自道路的未知远方。\n\n伟大的作品是用平实的语言去描写亘古不变的人情人性，虽然路遥的身躯早已回归到最亲爱的大地中去，而他却从未远离我们，因为他早已把灵魂注入到书中字里行间。他是孙少平，是小说中的每一处花开花落，草长莺飞，更是人物内心微妙地悸动和涌起地波澜。而这些融入他所有生命精华的著作也必将留芳于世，感动着现在以及以后的人们。\n\n后记：在2018年研究生考试结束之后读这本书对我来说是合适的，《平凡的世界》之所以能感动这么多人是因为展现出平凡人在艰难的生活中仍能保持高尚的精神和灵魂，永远用一种积极向上的态度去面对一切苦难，相比于生活赐予少平的苦难和他对待生活的态度也只会使我更有勇气去面对未来我将要经历的一切…\n\n2018/01/09 北京","slug":"read-pfdsj","published":1,"updated":"2019-01-13T09:51:29.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d330027l1fqg3rw45hj","content":"<h2 id=\"平凡的世界\"><a href=\"#平凡的世界\" class=\"headerlink\" title=\"平凡的世界\"></a>平凡的世界</h2><p><img src=\"/images/read/read_pfdsj.JPG\" alt=\"平凡的世界\"></p>\n<blockquote>\n<p>不要见怪，不要见外，田。<br>命运总是不如人愿。<br>但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来。<br>虽然这些东西在实际感受中给人带来的并不都是欢乐。</p>\n</blockquote>\n<p>坦率的说，我是没有‘勇气’来写自己对着这本书的感受的，因为在书中我热爱的每一个角色，都没有得到我预想的故事的结局。比如我是不能释怀田晓霞的离去的，也请原谅我是这么的狭隘，不能理解所谓的社会背景下就应该有怎样的结局，故事在作者厚重的笔下让我喘不过气，让我难受，让我忍不住为他们的苦难泪眼迷蒙。</p>\n<p>是的，我想要晓霞去赴古塔山杜梨树下与少平一点四十五分的约定！我不能接受田晓霞的死去，孙少平与田晓霞的爱情故事是这部现实主义小说中最为浪漫的一道彩虹，他们让我知道真正的爱情是超越门第，超越贫富，甚至超越生死的。虽然他们的社会身份有着巨大的差异，但在思想上却达到完美的融合。他们被彼此的气质所吸引，在海阔天空的思想交流中建立起深厚的友谊，而后又在更深的理解中将友情升华为爱情。这样的爱情稳固而坚贞，能够经受岁月的磨砺而焕然如新。</p>\n<p>也是的，生活中无处不有纠结与挣扎，而现实与精神的双重痛苦常常使人彻底堕落，只有在无比的痛苦中还能巍然站立，有力把握着生活马车的车辕的人才是真正的强者！孙少安和孙少平就是这样的强者，他们经历过巨大的艰难与痛苦，却把艰难痛苦都当作人生的财富，始终紧握生活的马鞭，奔向各自道路的未知远方。</p>\n<p>伟大的作品是用平实的语言去描写亘古不变的人情人性，虽然路遥的身躯早已回归到最亲爱的大地中去，而他却从未远离我们，因为他早已把灵魂注入到书中字里行间。他是孙少平，是小说中的每一处花开花落，草长莺飞，更是人物内心微妙地悸动和涌起地波澜。而这些融入他所有生命精华的著作也必将留芳于世，感动着现在以及以后的人们。</p>\n<p>后记：在2018年研究生考试结束之后读这本书对我来说是合适的，《平凡的世界》之所以能感动这么多人是因为展现出平凡人在艰难的生活中仍能保持高尚的精神和灵魂，永远用一种积极向上的态度去面对一切苦难，相比于生活赐予少平的苦难和他对待生活的态度也只会使我更有勇气去面对未来我将要经历的一切…</p>\n<p>2018/01/09 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"平凡的世界\"><a href=\"#平凡的世界\" class=\"headerlink\" title=\"平凡的世界\"></a>平凡的世界</h2><p><img src=\"/images/read/read_pfdsj.JPG\" alt=\"平凡的世界\"></p>\n<blockquote>\n<p>不要见怪，不要见外，田。<br>命运总是不如人愿。<br>但往往是在无数的痛苦中，在重重的矛盾和艰难中，才使人成熟起来，坚强起来。<br>虽然这些东西在实际感受中给人带来的并不都是欢乐。</p>\n</blockquote>\n<p>坦率的说，我是没有‘勇气’来写自己对着这本书的感受的，因为在书中我热爱的每一个角色，都没有得到我预想的故事的结局。比如我是不能释怀田晓霞的离去的，也请原谅我是这么的狭隘，不能理解所谓的社会背景下就应该有怎样的结局，故事在作者厚重的笔下让我喘不过气，让我难受，让我忍不住为他们的苦难泪眼迷蒙。</p>\n<p>是的，我想要晓霞去赴古塔山杜梨树下与少平一点四十五分的约定！我不能接受田晓霞的死去，孙少平与田晓霞的爱情故事是这部现实主义小说中最为浪漫的一道彩虹，他们让我知道真正的爱情是超越门第，超越贫富，甚至超越生死的。虽然他们的社会身份有着巨大的差异，但在思想上却达到完美的融合。他们被彼此的气质所吸引，在海阔天空的思想交流中建立起深厚的友谊，而后又在更深的理解中将友情升华为爱情。这样的爱情稳固而坚贞，能够经受岁月的磨砺而焕然如新。</p>\n<p>也是的，生活中无处不有纠结与挣扎，而现实与精神的双重痛苦常常使人彻底堕落，只有在无比的痛苦中还能巍然站立，有力把握着生活马车的车辕的人才是真正的强者！孙少安和孙少平就是这样的强者，他们经历过巨大的艰难与痛苦，却把艰难痛苦都当作人生的财富，始终紧握生活的马鞭，奔向各自道路的未知远方。</p>\n<p>伟大的作品是用平实的语言去描写亘古不变的人情人性，虽然路遥的身躯早已回归到最亲爱的大地中去，而他却从未远离我们，因为他早已把灵魂注入到书中字里行间。他是孙少平，是小说中的每一处花开花落，草长莺飞，更是人物内心微妙地悸动和涌起地波澜。而这些融入他所有生命精华的著作也必将留芳于世，感动着现在以及以后的人们。</p>\n<p>后记：在2018年研究生考试结束之后读这本书对我来说是合适的，《平凡的世界》之所以能感动这么多人是因为展现出平凡人在艰难的生活中仍能保持高尚的精神和灵魂，永远用一种积极向上的态度去面对一切苦难，相比于生活赐予少平的苦难和他对待生活的态度也只会使我更有勇气去面对未来我将要经历的一切…</p>\n<p>2018/01/09 北京</p>\n"},{"title":"看见","date":"2016-06-01T02:01:47.000Z","_content":"\n## 看见\n\n![看见](/images/read/read_kj.jpg)\n>水无所起止，只知流淌，但总得流淌。\n>山高月小，它要滴落，乱石穿空，它要拍岸，遇上高山峡谷，自成江河湖海。——柴静\n\n这本书是柴静十年成长的个人告白，中国社会变迁的备忘。讲述十年央视生涯。从对新闻一无所知的新人，尝遍失败、迷茫、摔打的滋味。从未停止反思和追问。\n\n柴静这个人让很多人佩服，我小时候就看她的节目，非典的时候对她印象很深刻，在书里读到她写非典的采访，脑袋里就不自觉的飘过2003年夏天守在姑姥家电视机前看新闻调查的画面。03年那个时候我们家还没有电视机，03那年夏天老爸和老妈都回老家忙农活了，我和我哥住在姑姥家。我不爱喝中药，讨厌那个味道，旧街药材公司的板蓝根冲剂开始限购，学校会每天早上量体温，填表。03年夏天我不小心打碎了家里唯一的体温计，被老妈回来摁在床上暴揍一顿。03年到16年，时光荏苒，13个年头已悄然而去...\n\n柴静在书里写到：对与错，好与坏，真与伪，善与恶...如何断定？太多的欲望夹杂着太多的无奈，又或是太多的无知与蒙昧？让人分不清道不明这社会的混沌，看见或感受，理解或矛盾，只是一种经历，经历过后了无痕迹，又回头再来！只愿做好自身，冷静不失冷暖，客观不失情感。一个好的记者，应该让大家知道真相，可以不评价不总结只讲述，知道了真相的人们自有评判，虽然有时真相会刺痛我们，但仍然感谢柴静，让我们如实看见。\n\n2016/06/01 北京","source":"_posts/read-kj.md","raw":"---\ntitle: 看见\ndate: 2016-06-01 10:01:47\ntags: [Readed]\ncategories: Readed\n---\n\n## 看见\n\n![看见](/images/read/read_kj.jpg)\n>水无所起止，只知流淌，但总得流淌。\n>山高月小，它要滴落，乱石穿空，它要拍岸，遇上高山峡谷，自成江河湖海。——柴静\n\n这本书是柴静十年成长的个人告白，中国社会变迁的备忘。讲述十年央视生涯。从对新闻一无所知的新人，尝遍失败、迷茫、摔打的滋味。从未停止反思和追问。\n\n柴静这个人让很多人佩服，我小时候就看她的节目，非典的时候对她印象很深刻，在书里读到她写非典的采访，脑袋里就不自觉的飘过2003年夏天守在姑姥家电视机前看新闻调查的画面。03年那个时候我们家还没有电视机，03那年夏天老爸和老妈都回老家忙农活了，我和我哥住在姑姥家。我不爱喝中药，讨厌那个味道，旧街药材公司的板蓝根冲剂开始限购，学校会每天早上量体温，填表。03年夏天我不小心打碎了家里唯一的体温计，被老妈回来摁在床上暴揍一顿。03年到16年，时光荏苒，13个年头已悄然而去...\n\n柴静在书里写到：对与错，好与坏，真与伪，善与恶...如何断定？太多的欲望夹杂着太多的无奈，又或是太多的无知与蒙昧？让人分不清道不明这社会的混沌，看见或感受，理解或矛盾，只是一种经历，经历过后了无痕迹，又回头再来！只愿做好自身，冷静不失冷暖，客观不失情感。一个好的记者，应该让大家知道真相，可以不评价不总结只讲述，知道了真相的人们自有评判，虽然有时真相会刺痛我们，但仍然感谢柴静，让我们如实看见。\n\n2016/06/01 北京","slug":"read-kj","published":1,"updated":"2019-01-13T09:51:54.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d34002al1fqlsg4ln4n","content":"<h2 id=\"看见\"><a href=\"#看见\" class=\"headerlink\" title=\"看见\"></a>看见</h2><p><img src=\"/images/read/read_kj.jpg\" alt=\"看见\"></p>\n<blockquote>\n<p>水无所起止，只知流淌，但总得流淌。<br>山高月小，它要滴落，乱石穿空，它要拍岸，遇上高山峡谷，自成江河湖海。——柴静</p>\n</blockquote>\n<p>这本书是柴静十年成长的个人告白，中国社会变迁的备忘。讲述十年央视生涯。从对新闻一无所知的新人，尝遍失败、迷茫、摔打的滋味。从未停止反思和追问。</p>\n<p>柴静这个人让很多人佩服，我小时候就看她的节目，非典的时候对她印象很深刻，在书里读到她写非典的采访，脑袋里就不自觉的飘过2003年夏天守在姑姥家电视机前看新闻调查的画面。03年那个时候我们家还没有电视机，03那年夏天老爸和老妈都回老家忙农活了，我和我哥住在姑姥家。我不爱喝中药，讨厌那个味道，旧街药材公司的板蓝根冲剂开始限购，学校会每天早上量体温，填表。03年夏天我不小心打碎了家里唯一的体温计，被老妈回来摁在床上暴揍一顿。03年到16年，时光荏苒，13个年头已悄然而去…</p>\n<p>柴静在书里写到：对与错，好与坏，真与伪，善与恶…如何断定？太多的欲望夹杂着太多的无奈，又或是太多的无知与蒙昧？让人分不清道不明这社会的混沌，看见或感受，理解或矛盾，只是一种经历，经历过后了无痕迹，又回头再来！只愿做好自身，冷静不失冷暖，客观不失情感。一个好的记者，应该让大家知道真相，可以不评价不总结只讲述，知道了真相的人们自有评判，虽然有时真相会刺痛我们，但仍然感谢柴静，让我们如实看见。</p>\n<p>2016/06/01 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"看见\"><a href=\"#看见\" class=\"headerlink\" title=\"看见\"></a>看见</h2><p><img src=\"/images/read/read_kj.jpg\" alt=\"看见\"></p>\n<blockquote>\n<p>水无所起止，只知流淌，但总得流淌。<br>山高月小，它要滴落，乱石穿空，它要拍岸，遇上高山峡谷，自成江河湖海。——柴静</p>\n</blockquote>\n<p>这本书是柴静十年成长的个人告白，中国社会变迁的备忘。讲述十年央视生涯。从对新闻一无所知的新人，尝遍失败、迷茫、摔打的滋味。从未停止反思和追问。</p>\n<p>柴静这个人让很多人佩服，我小时候就看她的节目，非典的时候对她印象很深刻，在书里读到她写非典的采访，脑袋里就不自觉的飘过2003年夏天守在姑姥家电视机前看新闻调查的画面。03年那个时候我们家还没有电视机，03那年夏天老爸和老妈都回老家忙农活了，我和我哥住在姑姥家。我不爱喝中药，讨厌那个味道，旧街药材公司的板蓝根冲剂开始限购，学校会每天早上量体温，填表。03年夏天我不小心打碎了家里唯一的体温计，被老妈回来摁在床上暴揍一顿。03年到16年，时光荏苒，13个年头已悄然而去…</p>\n<p>柴静在书里写到：对与错，好与坏，真与伪，善与恶…如何断定？太多的欲望夹杂着太多的无奈，又或是太多的无知与蒙昧？让人分不清道不明这社会的混沌，看见或感受，理解或矛盾，只是一种经历，经历过后了无痕迹，又回头再来！只愿做好自身，冷静不失冷暖，客观不失情感。一个好的记者，应该让大家知道真相，可以不评价不总结只讲述，知道了真相的人们自有评判，虽然有时真相会刺痛我们，但仍然感谢柴静，让我们如实看见。</p>\n<p>2016/06/01 北京</p>\n"},{"title":"早晨从中午醒来","date":"2018-01-15T02:01:47.000Z","_content":"\n## 早晨从中午醒来\n\n![早晨从中午醒来](/images/read/read_zcczwxl.JPG)\n\n作为一部随笔，抛开什么文学性，艺术性。路遥告诉我们他是以怎样得态度对待写作。一直坚信，有些文字是有重量的，而且会在时间的流里慢慢地积淀它的力量，然后或者让人感到温暖，或者让人觉得寒冷。\n\n《早晨从中午开始》是路遥的创作随笔，非常完整地记录了他创作《平凡的世界》的过程以及他的心路历程。当人们尝试着去寻找在过去时间里的自我时会产生很多维度的距离，而这些距离的产生无疑会更改着文字所要表达的意义。\n\n 记忆中的那些日子沉默而清晰，当最艰苦的劳动变得死一般苍白，于是便开始吸入秋天冷冽的气息，冬天在不久之后即将到来，用写下文字的笔捣毁那些珍贵的瞬间，然后将它们到处抛撒，最终将常常不得不从椅子中起来，移向其它的伤心事，落入其它的陷阱。那种透彻心扉的寒冷是必须独自面对并且切身经历的，而且这也正是所有温暖的真正根源。\n\n这种为文学而奋斗的人生，虽然短暂，但却独绝并无比地震撼人心。在这个依旧甚至从来都是平凡的世界里，能把创作当成生命的人需要怎样的勇气！\n\n>“在这里，我才清楚地认识到我将要进行一次命运的‘赌博’（也许这个词不恰当），而赌注则是自己的青春抑或生命。尽管不会让世俗的观念操纵我的意志，但如果说我在其中没有作出任何世俗的考虑，那就是谎言。无疑，这部作品将耗时多年，如果将来作品有某种程度的收获，这还多少对抛洒的青春热血有个慰藉。如果整个地失败，那将意味着青春乃至生命的失败。这是一个人一生中最好的一段年华，它的流失应该换取最丰硕的果实——可是怎么可能保证这一点呢！”\n\n最终路遥赢了，他用一部《平凡的世界》鼓舞了所有平凡的人生们，但在做完这个“一生中最重要的一件事”之后不久，他也把自己的生命永远地交付给了自己的作品融入字里行间而匆匆告别人世。\n\n或许道理真的很简单：“任何一个人，尤其是一个有某种抱负的人，在自己的青少年时期会有过许多理想、幻想、梦想，甚至是妄想。这些玫瑰色的光环大都会随着时间的流逝和环境的变迁而消散得无影无踪。但是，当一个人在某一方面一旦具备了某种实现雄心抱负的条件，早年间的梦想就会被认真地提升到现实中并考察其真正复活的可能性。”\n\n但是又有多少人能够做到呢？\n\n2018/01/15 北京","source":"_posts/read-zcczwxl.md","raw":"---\ntitle: 早晨从中午醒来\ndate: 2018-01-15 10:01:47\ntags: [Readed]\ncategories: Readed\n---\n\n## 早晨从中午醒来\n\n![早晨从中午醒来](/images/read/read_zcczwxl.JPG)\n\n作为一部随笔，抛开什么文学性，艺术性。路遥告诉我们他是以怎样得态度对待写作。一直坚信，有些文字是有重量的，而且会在时间的流里慢慢地积淀它的力量，然后或者让人感到温暖，或者让人觉得寒冷。\n\n《早晨从中午开始》是路遥的创作随笔，非常完整地记录了他创作《平凡的世界》的过程以及他的心路历程。当人们尝试着去寻找在过去时间里的自我时会产生很多维度的距离，而这些距离的产生无疑会更改着文字所要表达的意义。\n\n 记忆中的那些日子沉默而清晰，当最艰苦的劳动变得死一般苍白，于是便开始吸入秋天冷冽的气息，冬天在不久之后即将到来，用写下文字的笔捣毁那些珍贵的瞬间，然后将它们到处抛撒，最终将常常不得不从椅子中起来，移向其它的伤心事，落入其它的陷阱。那种透彻心扉的寒冷是必须独自面对并且切身经历的，而且这也正是所有温暖的真正根源。\n\n这种为文学而奋斗的人生，虽然短暂，但却独绝并无比地震撼人心。在这个依旧甚至从来都是平凡的世界里，能把创作当成生命的人需要怎样的勇气！\n\n>“在这里，我才清楚地认识到我将要进行一次命运的‘赌博’（也许这个词不恰当），而赌注则是自己的青春抑或生命。尽管不会让世俗的观念操纵我的意志，但如果说我在其中没有作出任何世俗的考虑，那就是谎言。无疑，这部作品将耗时多年，如果将来作品有某种程度的收获，这还多少对抛洒的青春热血有个慰藉。如果整个地失败，那将意味着青春乃至生命的失败。这是一个人一生中最好的一段年华，它的流失应该换取最丰硕的果实——可是怎么可能保证这一点呢！”\n\n最终路遥赢了，他用一部《平凡的世界》鼓舞了所有平凡的人生们，但在做完这个“一生中最重要的一件事”之后不久，他也把自己的生命永远地交付给了自己的作品融入字里行间而匆匆告别人世。\n\n或许道理真的很简单：“任何一个人，尤其是一个有某种抱负的人，在自己的青少年时期会有过许多理想、幻想、梦想，甚至是妄想。这些玫瑰色的光环大都会随着时间的流逝和环境的变迁而消散得无影无踪。但是，当一个人在某一方面一旦具备了某种实现雄心抱负的条件，早年间的梦想就会被认真地提升到现实中并考察其真正复活的可能性。”\n\n但是又有多少人能够做到呢？\n\n2018/01/15 北京","slug":"read-zcczwxl","published":1,"updated":"2019-01-13T09:51:56.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d35002el1fq75xw9hbs","content":"<h2 id=\"早晨从中午醒来\"><a href=\"#早晨从中午醒来\" class=\"headerlink\" title=\"早晨从中午醒来\"></a>早晨从中午醒来</h2><p><img src=\"/images/read/read_zcczwxl.JPG\" alt=\"早晨从中午醒来\"></p>\n<p>作为一部随笔，抛开什么文学性，艺术性。路遥告诉我们他是以怎样得态度对待写作。一直坚信，有些文字是有重量的，而且会在时间的流里慢慢地积淀它的力量，然后或者让人感到温暖，或者让人觉得寒冷。</p>\n<p>《早晨从中午开始》是路遥的创作随笔，非常完整地记录了他创作《平凡的世界》的过程以及他的心路历程。当人们尝试着去寻找在过去时间里的自我时会产生很多维度的距离，而这些距离的产生无疑会更改着文字所要表达的意义。</p>\n<p> 记忆中的那些日子沉默而清晰，当最艰苦的劳动变得死一般苍白，于是便开始吸入秋天冷冽的气息，冬天在不久之后即将到来，用写下文字的笔捣毁那些珍贵的瞬间，然后将它们到处抛撒，最终将常常不得不从椅子中起来，移向其它的伤心事，落入其它的陷阱。那种透彻心扉的寒冷是必须独自面对并且切身经历的，而且这也正是所有温暖的真正根源。</p>\n<p>这种为文学而奋斗的人生，虽然短暂，但却独绝并无比地震撼人心。在这个依旧甚至从来都是平凡的世界里，能把创作当成生命的人需要怎样的勇气！</p>\n<blockquote>\n<p>“在这里，我才清楚地认识到我将要进行一次命运的‘赌博’（也许这个词不恰当），而赌注则是自己的青春抑或生命。尽管不会让世俗的观念操纵我的意志，但如果说我在其中没有作出任何世俗的考虑，那就是谎言。无疑，这部作品将耗时多年，如果将来作品有某种程度的收获，这还多少对抛洒的青春热血有个慰藉。如果整个地失败，那将意味着青春乃至生命的失败。这是一个人一生中最好的一段年华，它的流失应该换取最丰硕的果实——可是怎么可能保证这一点呢！”</p>\n</blockquote>\n<p>最终路遥赢了，他用一部《平凡的世界》鼓舞了所有平凡的人生们，但在做完这个“一生中最重要的一件事”之后不久，他也把自己的生命永远地交付给了自己的作品融入字里行间而匆匆告别人世。</p>\n<p>或许道理真的很简单：“任何一个人，尤其是一个有某种抱负的人，在自己的青少年时期会有过许多理想、幻想、梦想，甚至是妄想。这些玫瑰色的光环大都会随着时间的流逝和环境的变迁而消散得无影无踪。但是，当一个人在某一方面一旦具备了某种实现雄心抱负的条件，早年间的梦想就会被认真地提升到现实中并考察其真正复活的可能性。”</p>\n<p>但是又有多少人能够做到呢？</p>\n<p>2018/01/15 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"早晨从中午醒来\"><a href=\"#早晨从中午醒来\" class=\"headerlink\" title=\"早晨从中午醒来\"></a>早晨从中午醒来</h2><p><img src=\"/images/read/read_zcczwxl.JPG\" alt=\"早晨从中午醒来\"></p>\n<p>作为一部随笔，抛开什么文学性，艺术性。路遥告诉我们他是以怎样得态度对待写作。一直坚信，有些文字是有重量的，而且会在时间的流里慢慢地积淀它的力量，然后或者让人感到温暖，或者让人觉得寒冷。</p>\n<p>《早晨从中午开始》是路遥的创作随笔，非常完整地记录了他创作《平凡的世界》的过程以及他的心路历程。当人们尝试着去寻找在过去时间里的自我时会产生很多维度的距离，而这些距离的产生无疑会更改着文字所要表达的意义。</p>\n<p> 记忆中的那些日子沉默而清晰，当最艰苦的劳动变得死一般苍白，于是便开始吸入秋天冷冽的气息，冬天在不久之后即将到来，用写下文字的笔捣毁那些珍贵的瞬间，然后将它们到处抛撒，最终将常常不得不从椅子中起来，移向其它的伤心事，落入其它的陷阱。那种透彻心扉的寒冷是必须独自面对并且切身经历的，而且这也正是所有温暖的真正根源。</p>\n<p>这种为文学而奋斗的人生，虽然短暂，但却独绝并无比地震撼人心。在这个依旧甚至从来都是平凡的世界里，能把创作当成生命的人需要怎样的勇气！</p>\n<blockquote>\n<p>“在这里，我才清楚地认识到我将要进行一次命运的‘赌博’（也许这个词不恰当），而赌注则是自己的青春抑或生命。尽管不会让世俗的观念操纵我的意志，但如果说我在其中没有作出任何世俗的考虑，那就是谎言。无疑，这部作品将耗时多年，如果将来作品有某种程度的收获，这还多少对抛洒的青春热血有个慰藉。如果整个地失败，那将意味着青春乃至生命的失败。这是一个人一生中最好的一段年华，它的流失应该换取最丰硕的果实——可是怎么可能保证这一点呢！”</p>\n</blockquote>\n<p>最终路遥赢了，他用一部《平凡的世界》鼓舞了所有平凡的人生们，但在做完这个“一生中最重要的一件事”之后不久，他也把自己的生命永远地交付给了自己的作品融入字里行间而匆匆告别人世。</p>\n<p>或许道理真的很简单：“任何一个人，尤其是一个有某种抱负的人，在自己的青少年时期会有过许多理想、幻想、梦想，甚至是妄想。这些玫瑰色的光环大都会随着时间的流逝和环境的变迁而消散得无影无踪。但是，当一个人在某一方面一旦具备了某种实现雄心抱负的条件，早年间的梦想就会被认真地提升到现实中并考察其真正复活的可能性。”</p>\n<p>但是又有多少人能够做到呢？</p>\n<p>2018/01/15 北京</p>\n"},{"title":"Xcode - 代码片段 Code Snippets","date":"2018-05-08T02:01:47.000Z","_content":"在iOS开发过程中，经常会用到一些相似的代码。我们可以将这些代码保存起来，在使用的时候直接从Code Snippets拖拽代码块到指定的位置，也可以设置一些快捷方式来调用Xcode代码片段。\n## 新增\n* 例如编写以下代码片段\n``` objc\n@property (nonatomic, strong) <#Type#> *<#value#>;\n```\n<##> 作用是占位，## 之间可以输入提示文字。\n* 使用快捷键：command+option+0\n* 将上述代码片段拖拽到下图所示区域\n\t![](/images/code_snippets.png)\n\t> **小技巧**：用鼠标选中代码块后把光标放在所选代码块上点击长按2-3秒(光标会由插入标变为小箭头状态)就可以拖拽了\n\n* 弹出下图\n\t![](/images/code_snippet_dialog.png)\n> Title：标题\n> Summary：描述\n> Platform：可以使用的平台 \n> Language：可以在哪些语言中使用\n> Completion Shortcut：快捷方式（例如：@xs）。 \n> Completion Scopes：作用范围\n\n## 修改\n对代码片段进行修改，选中代码片段，点击edit即可。\n## 删除\n对代码片段进行删除，选中代码片段，按delete键即可。\n## Git管理\n为了方便在更换电脑后可以更快速的使用自己的代码块，可以托管在Github上进行管理，这样在家里和公司两台Mac任何一端有了更新，另一端随时都可以pull一下使用了。\n### Xcode中代码片段默认的目录：\n``` bash\n~/Library/Developer/Xcode/UserData/CodeSnippets\n```\n### 同步代码片段\n上述目录设置成一个 Git 的版本库，将代码片段放到 Github 上。\n","source":"_posts/xcode-code-snippets.md","raw":"---\ntitle: Xcode - 代码片段 Code Snippets\ndate: 2018-05-08 10:01:47\ntags: [Xcode]\ncategories: Xcode\n---\n在iOS开发过程中，经常会用到一些相似的代码。我们可以将这些代码保存起来，在使用的时候直接从Code Snippets拖拽代码块到指定的位置，也可以设置一些快捷方式来调用Xcode代码片段。\n## 新增\n* 例如编写以下代码片段\n``` objc\n@property (nonatomic, strong) <#Type#> *<#value#>;\n```\n<##> 作用是占位，## 之间可以输入提示文字。\n* 使用快捷键：command+option+0\n* 将上述代码片段拖拽到下图所示区域\n\t![](/images/code_snippets.png)\n\t> **小技巧**：用鼠标选中代码块后把光标放在所选代码块上点击长按2-3秒(光标会由插入标变为小箭头状态)就可以拖拽了\n\n* 弹出下图\n\t![](/images/code_snippet_dialog.png)\n> Title：标题\n> Summary：描述\n> Platform：可以使用的平台 \n> Language：可以在哪些语言中使用\n> Completion Shortcut：快捷方式（例如：@xs）。 \n> Completion Scopes：作用范围\n\n## 修改\n对代码片段进行修改，选中代码片段，点击edit即可。\n## 删除\n对代码片段进行删除，选中代码片段，按delete键即可。\n## Git管理\n为了方便在更换电脑后可以更快速的使用自己的代码块，可以托管在Github上进行管理，这样在家里和公司两台Mac任何一端有了更新，另一端随时都可以pull一下使用了。\n### Xcode中代码片段默认的目录：\n``` bash\n~/Library/Developer/Xcode/UserData/CodeSnippets\n```\n### 同步代码片段\n上述目录设置成一个 Git 的版本库，将代码片段放到 Github 上。\n","slug":"xcode-code-snippets","published":1,"updated":"2019-01-13T09:02:20.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d36002il1fqzjzlma7j","content":"<p>在iOS开发过程中，经常会用到一些相似的代码。我们可以将这些代码保存起来，在使用的时候直接从Code Snippets拖拽代码块到指定的位置，也可以设置一些快捷方式来调用Xcode代码片段。</p>\n<h2 id=\"新增\"><a href=\"#新增\" class=\"headerlink\" title=\"新增\"></a>新增</h2><ul>\n<li>例如编写以下代码片段<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) &lt;<span class=\"meta\">#Type#&gt; *<span class=\"meta-string\">&lt;#value#&gt;</span>;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&lt;##&gt; 作用是占位，## 之间可以输入提示文字。</p>\n<ul>\n<li>使用快捷键：command+option+0</li>\n<li><p>将上述代码片段拖拽到下图所示区域<br>  <img src=\"/images/code_snippets.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>小技巧</strong>：用鼠标选中代码块后把光标放在所选代码块上点击长按2-3秒(光标会由插入标变为小箭头状态)就可以拖拽了</p>\n</blockquote>\n</li>\n<li><p>弹出下图<br>  <img src=\"/images/code_snippet_dialog.png\" alt=\"\"></p>\n<blockquote>\n<p>Title：标题<br>Summary：描述<br>Platform：可以使用的平台<br>Language：可以在哪些语言中使用<br>Completion Shortcut：快捷方式（例如：@xs）。<br>Completion Scopes：作用范围</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h2><p>对代码片段进行修改，选中代码片段，点击edit即可。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>对代码片段进行删除，选中代码片段，按delete键即可。</p>\n<h2 id=\"Git管理\"><a href=\"#Git管理\" class=\"headerlink\" title=\"Git管理\"></a>Git管理</h2><p>为了方便在更换电脑后可以更快速的使用自己的代码块，可以托管在Github上进行管理，这样在家里和公司两台Mac任何一端有了更新，另一端随时都可以pull一下使用了。</p>\n<h3 id=\"Xcode中代码片段默认的目录：\"><a href=\"#Xcode中代码片段默认的目录：\" class=\"headerlink\" title=\"Xcode中代码片段默认的目录：\"></a>Xcode中代码片段默认的目录：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Library/Developer/Xcode/UserData/CodeSnippets</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步代码片段\"><a href=\"#同步代码片段\" class=\"headerlink\" title=\"同步代码片段\"></a>同步代码片段</h3><p>上述目录设置成一个 Git 的版本库，将代码片段放到 Github 上。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在iOS开发过程中，经常会用到一些相似的代码。我们可以将这些代码保存起来，在使用的时候直接从Code Snippets拖拽代码块到指定的位置，也可以设置一些快捷方式来调用Xcode代码片段。</p>\n<h2 id=\"新增\"><a href=\"#新增\" class=\"headerlink\" title=\"新增\"></a>新增</h2><ul>\n<li>例如编写以下代码片段<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) &lt;<span class=\"meta\">#Type#&gt; *<span class=\"meta-string\">&lt;#value#&gt;</span>;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>&lt;##&gt; 作用是占位，## 之间可以输入提示文字。</p>\n<ul>\n<li>使用快捷键：command+option+0</li>\n<li><p>将上述代码片段拖拽到下图所示区域<br>  <img src=\"/images/code_snippets.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>小技巧</strong>：用鼠标选中代码块后把光标放在所选代码块上点击长按2-3秒(光标会由插入标变为小箭头状态)就可以拖拽了</p>\n</blockquote>\n</li>\n<li><p>弹出下图<br>  <img src=\"/images/code_snippet_dialog.png\" alt=\"\"></p>\n<blockquote>\n<p>Title：标题<br>Summary：描述<br>Platform：可以使用的平台<br>Language：可以在哪些语言中使用<br>Completion Shortcut：快捷方式（例如：@xs）。<br>Completion Scopes：作用范围</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h2><p>对代码片段进行修改，选中代码片段，点击edit即可。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>对代码片段进行删除，选中代码片段，按delete键即可。</p>\n<h2 id=\"Git管理\"><a href=\"#Git管理\" class=\"headerlink\" title=\"Git管理\"></a>Git管理</h2><p>为了方便在更换电脑后可以更快速的使用自己的代码块，可以托管在Github上进行管理，这样在家里和公司两台Mac任何一端有了更新，另一端随时都可以pull一下使用了。</p>\n<h3 id=\"Xcode中代码片段默认的目录：\"><a href=\"#Xcode中代码片段默认的目录：\" class=\"headerlink\" title=\"Xcode中代码片段默认的目录：\"></a>Xcode中代码片段默认的目录：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Library/Developer/Xcode/UserData/CodeSnippets</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步代码片段\"><a href=\"#同步代码片段\" class=\"headerlink\" title=\"同步代码片段\"></a>同步代码片段</h3><p>上述目录设置成一个 Git 的版本库，将代码片段放到 Github 上。</p>\n"},{"title":"Xcode - 打包证书创建流程","date":"2018-04-29T03:48:37.000Z","_content":"\n## 创建CSR证书\n### 点击spotlight输入keychain打开钥匙串\n![](/images/csr_keychain.png)  \n### 生成CSR文件\n![](/images/csr_create.png)  \n### **注意**：\n![](/images/csr_alert.png)\n\n## 创建Cer证书\n### [登录 apple developer](https://developer.apple.com/account/)\n\n### 使用CSR文件创建Development和Distribution的CER证书并下载\n![](/images/cer_create.png)\n\n### 双击下载好的cer证书，然后导出对应的p12文件（dev/dis）\n![](/images/cer_export_p12.png)\n\n## 创建Provisioning Profile\n这里要创建是三种profile（dev/dis/adhoc）\n![](/images/cer_profile_list.png)\n","source":"_posts/xcode-pack-cer-create-process.md","raw":"---\ntitle: Xcode - 打包证书创建流程\ndate: 2018-04-29 11:48:37\ntags: [Xcode]\ncategories: Xcode\n---\n\n## 创建CSR证书\n### 点击spotlight输入keychain打开钥匙串\n![](/images/csr_keychain.png)  \n### 生成CSR文件\n![](/images/csr_create.png)  \n### **注意**：\n![](/images/csr_alert.png)\n\n## 创建Cer证书\n### [登录 apple developer](https://developer.apple.com/account/)\n\n### 使用CSR文件创建Development和Distribution的CER证书并下载\n![](/images/cer_create.png)\n\n### 双击下载好的cer证书，然后导出对应的p12文件（dev/dis）\n![](/images/cer_export_p12.png)\n\n## 创建Provisioning Profile\n这里要创建是三种profile（dev/dis/adhoc）\n![](/images/cer_profile_list.png)\n","slug":"xcode-pack-cer-create-process","published":1,"updated":"2019-01-13T05:10:51.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d38002ll1fq2qei44x3","content":"<h2 id=\"创建CSR证书\"><a href=\"#创建CSR证书\" class=\"headerlink\" title=\"创建CSR证书\"></a>创建CSR证书</h2><h3 id=\"点击spotlight输入keychain打开钥匙串\"><a href=\"#点击spotlight输入keychain打开钥匙串\" class=\"headerlink\" title=\"点击spotlight输入keychain打开钥匙串\"></a>点击spotlight输入keychain打开钥匙串</h3><p><img src=\"/images/csr_keychain.png\" alt=\"\">  </p>\n<h3 id=\"生成CSR文件\"><a href=\"#生成CSR文件\" class=\"headerlink\" title=\"生成CSR文件\"></a>生成CSR文件</h3><p><img src=\"/images/csr_create.png\" alt=\"\">  </p>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a><strong>注意</strong>：</h3><p><img src=\"/images/csr_alert.png\" alt=\"\"></p>\n<h2 id=\"创建Cer证书\"><a href=\"#创建Cer证书\" class=\"headerlink\" title=\"创建Cer证书\"></a>创建Cer证书</h2><h3 id=\"登录-apple-developer\"><a href=\"#登录-apple-developer\" class=\"headerlink\" title=\"登录 apple developer\"></a><a href=\"https://developer.apple.com/account/\" target=\"_blank\" rel=\"noopener\">登录 apple developer</a></h3><h3 id=\"使用CSR文件创建Development和Distribution的CER证书并下载\"><a href=\"#使用CSR文件创建Development和Distribution的CER证书并下载\" class=\"headerlink\" title=\"使用CSR文件创建Development和Distribution的CER证书并下载\"></a>使用CSR文件创建Development和Distribution的CER证书并下载</h3><p><img src=\"/images/cer_create.png\" alt=\"\"></p>\n<h3 id=\"双击下载好的cer证书，然后导出对应的p12文件（dev-dis）\"><a href=\"#双击下载好的cer证书，然后导出对应的p12文件（dev-dis）\" class=\"headerlink\" title=\"双击下载好的cer证书，然后导出对应的p12文件（dev/dis）\"></a>双击下载好的cer证书，然后导出对应的p12文件（dev/dis）</h3><p><img src=\"/images/cer_export_p12.png\" alt=\"\"></p>\n<h2 id=\"创建Provisioning-Profile\"><a href=\"#创建Provisioning-Profile\" class=\"headerlink\" title=\"创建Provisioning Profile\"></a>创建Provisioning Profile</h2><p>这里要创建是三种profile（dev/dis/adhoc）<br><img src=\"/images/cer_profile_list.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建CSR证书\"><a href=\"#创建CSR证书\" class=\"headerlink\" title=\"创建CSR证书\"></a>创建CSR证书</h2><h3 id=\"点击spotlight输入keychain打开钥匙串\"><a href=\"#点击spotlight输入keychain打开钥匙串\" class=\"headerlink\" title=\"点击spotlight输入keychain打开钥匙串\"></a>点击spotlight输入keychain打开钥匙串</h3><p><img src=\"/images/csr_keychain.png\" alt=\"\">  </p>\n<h3 id=\"生成CSR文件\"><a href=\"#生成CSR文件\" class=\"headerlink\" title=\"生成CSR文件\"></a>生成CSR文件</h3><p><img src=\"/images/csr_create.png\" alt=\"\">  </p>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a><strong>注意</strong>：</h3><p><img src=\"/images/csr_alert.png\" alt=\"\"></p>\n<h2 id=\"创建Cer证书\"><a href=\"#创建Cer证书\" class=\"headerlink\" title=\"创建Cer证书\"></a>创建Cer证书</h2><h3 id=\"登录-apple-developer\"><a href=\"#登录-apple-developer\" class=\"headerlink\" title=\"登录 apple developer\"></a><a href=\"https://developer.apple.com/account/\" target=\"_blank\" rel=\"noopener\">登录 apple developer</a></h3><h3 id=\"使用CSR文件创建Development和Distribution的CER证书并下载\"><a href=\"#使用CSR文件创建Development和Distribution的CER证书并下载\" class=\"headerlink\" title=\"使用CSR文件创建Development和Distribution的CER证书并下载\"></a>使用CSR文件创建Development和Distribution的CER证书并下载</h3><p><img src=\"/images/cer_create.png\" alt=\"\"></p>\n<h3 id=\"双击下载好的cer证书，然后导出对应的p12文件（dev-dis）\"><a href=\"#双击下载好的cer证书，然后导出对应的p12文件（dev-dis）\" class=\"headerlink\" title=\"双击下载好的cer证书，然后导出对应的p12文件（dev/dis）\"></a>双击下载好的cer证书，然后导出对应的p12文件（dev/dis）</h3><p><img src=\"/images/cer_export_p12.png\" alt=\"\"></p>\n<h2 id=\"创建Provisioning-Profile\"><a href=\"#创建Provisioning-Profile\" class=\"headerlink\" title=\"创建Provisioning Profile\"></a>创建Provisioning Profile</h2><p>这里要创建是三种profile（dev/dis/adhoc）<br><img src=\"/images/cer_profile_list.png\" alt=\"\"></p>\n"},{"title":"Objc - Block","date":"2018-05-10T03:21:20.000Z","_content":"# 引言\nApple 在iOS4.0之后推出Block，它本身封装了一段代码并可以将这段代码当做变量，参数，属性，数据类型，函数（匿名），代码块（只有在被调用时才会执行）等等，使用方式灵活，功能十分强大。\n\n# Block的简单使用\n## 定义Block\n- 无参无返回值\n ``` objc\n  void(^block)() = ^(){\n   NSLog(@\"this is a no param and no return of block\");\n };\n block();\n ```\n- 有参无返回值\n ``` objc\n void(^block)(NSString * ) = ^(NSString * param){\n   NSLog(@\"this is a has param and no return of block\");\n };\n block(@\"param\");\n ```\n- 有参有返回值\n ``` objc\n NSString *(^block)(NSString * ) = ^(NSString * param){\n   NSLog(@\"this is a has param and return of block\");\n   return @\"\";\n };\n block(@\"param\");\n ```\n\n## 定义Block的快捷方式\n> Block 的定义可以借助键入 inlineBlock 速记.\n\n``` objc\n// inlineBlock\nreturnType (^blockName)(parameterTypes) = ^(parameters) {\n   statements\n};\n```\n## Block定义成属性\n``` objc\n@property (copy, nonatomic) void(^block)();\n```\n## Block作参数\n``` objc\n-(void)demo04{\n void(^block)() = ^{\n   NSLog(@\"block become param\");\n };\n [self callbackWith:block];\n}\n\n-(void)callbackWith:(void(^)())block{\n //调用外界传入的block\n block();\n}\n```\n## typedef 定义Block\n``` objc\n// 声明\ntypedef void(^MyBlock)();\n// 使用\nMyBlock block01 = ^{\n NSLog(@\"block01\");\n};\nblock01();\n```\n- 小结：方便之处在于可以常用类型的Block可以用typedef来定义\n# Block与外部变量\n## Block内部访问/引用 外部变量\n``` objc\n int num = 10;\n NSLog(@\"%p %d\",&num,num);\n void(^block)() = ^{\n   NSLog(@\"%p %d\",&num,num);\n };\n num = 20;\n NSLog(@\"%@ %p %d\",block,&num,num);\n block();\n```\n- `MRC`输出结果：\n``` console\n018-05-10 12:33:49.178446+0800 BlockDemo[1825:245809] 0x7ffee31dc9dc 10\n2018-05-10 12:33:49.178655+0800 BlockDemo[1825:245809] <__NSStackBlock__: 0x7ffee31dc9a8> 0x7ffee31dc9dc 20\n2018-05-10 12:33:49.178770+0800 BlockDemo[1825:245809] 0x7ffee31dc9c8 10\n```\n- `ARC`输出结果：\n``` console\n2018-05-10 12:36:47.248638+0800 BlockDemo[1887:256355] 0x7ffee517f9dc 10\n2018-05-10 12:36:47.248856+0800 BlockDemo[1887:256355] <__NSMallocBlock__: 0x604000259530> 0x7ffee517f9dc 20\n2018-05-10 12:36:47.249115+0800 BlockDemo[1887:256355] 0x604000259550 10\n```\n- 小结\n在block中访问外部的变量时，会自动拷贝到内存一份并开辟新的地址，这就是深拷贝\n\n## Block内部修改外部变量\n``` objc\n__block int num = 10;\n NSLog(@\"%p %d\",&num,num);\n void(^block)() = ^{\n   num = 30;\n   NSLog(@\"%p %d\",&num,num);\n };\n num = 20;\n NSLog(@\"%@ %p %d\",block,&num,num);\n block();\n```\n- `MRC`输出结果：\n``` console\n2018-05-10 12:41:56.490868+0800 BlockDemo[2018:272473] 0x7ffee14519d8 10\n2018-05-10 12:41:56.491055+0800 BlockDemo[2018:272473] <__NSStackBlock__: 0x7ffee1451980> 0x7ffee14519d8 20\n2018-05-10 12:41:56.491165+0800 BlockDemo[2018:272473] 0x7ffee14519d8 30\n```\n- `ARC`输出结果：\n``` console\n2018-05-10 12:43:13.402390+0800 BlockDemo[2047:277009] 0x7ffeea3149d8 10\n2018-05-10 12:43:13.402662+0800 BlockDemo[2047:277009] <__NSMallocBlock__: 0x60400024da70> 0x604000034cf8 20\n2018-05-10 12:43:13.402777+0800 BlockDemo[2047:277009] 0x604000034cf8 30\n```\n- 小结\nblock内修改的外部变量，需要用`__block`修饰.在此后若被block访问修改，变量的内存地址会重新指向拷贝后开辟的新的内存地址.\n\n## 验证一个想法\n> 在`ARC`/`MRC`中block内`引用`外部变量地址如何在堆栈中变化，通过将Block自身作为自身的参数传入\n\n\n``` objc\nint num = 10;\n   NSLog(@\"%p %d\",&num,num);\n   void(^block)(void(^)()) = ^(void(^block2)()){\n       NSLog(@\"%@ %p %d\",block2,&num,num);\n   };\n   num = 20;\n   NSLog(@\"%@ %p %d\",block,&num,num);\n   //本身作为参数传入并输出指针对象的堆栈\n   block(block);\n```\n\n  - 1.在`ARC`中block内引用外部变量地址如何在堆栈中变化，输出结果:\n\n``` console\n2018-05-10 12:51:29.359318+0800 BlockDemo[2216:302301] 0x7ffee29ab9dc 10\n2018-05-10 12:51:29.359563+0800 BlockDemo[2216:302301] <__NSMallocBlock__: 0x600000259230> 0x7ffee29ab9dc 20\n2018-05-10 12:51:29.359708+0800 BlockDemo[2216:302301] <__NSMallocBlock__: 0x600000259230> 0x600000259250 10\n```\n  - 2.在`MRC`中block内引用外部变量地址如何在堆栈中变化，输出结果:\n\n``` console\n2018-05-10 12:46:27.120908+0800 BlockDemo[2153:287894] 0x7ffee8a699dc 10\n2018-05-10 12:46:27.121106+0800 BlockDemo[2153:287894] <__NSStackBlock__: 0x7ffee8a699a8> 0x7ffee8a699dc 20\n2018-05-10 12:46:27.121239+0800 BlockDemo[2153:287894] <__NSStackBlock__: 0x7ffee8a699a8> 0x7ffee8a699c8 10\n```\n- 小结：\n`ARC`下，永远在堆区中。`MRC`下永远在栈区中\n\n# block内存管理（MRC/ARC）\n## 函数体\n### 当函数体不变时\n``` objc\nvoid(^myBlock)() = ^ {\n NSLog(@\"hello world\");\n};\nNSLog(@\"%@\", myBlock);\n```\n- 输出结果：\n``` console\n2018-05-09 22:59:07.637768+0800 BlockDemo[3288:930159] <__NSGlobalBlock__: 0x10afa20d8>\n```\n- 小结：\n不引用任何外部变量的 block 保存在全局区 NSGlobalBlock，如果Block没有引用外部变量,那么这个Block的函数体内部包装的代码都不会发生变化,而且执行效率高,保存在全局区;(类似不变的字符串存在常量区)\n### 当函数体可变时（即访问修改外部变量时）\n``` objc\nint i = 10;\nvoid(^myBlock)() = ^ {\n NSLog(@\"hello world %d\", i);\n};\nNSLog(@\"%@\", myBlock);\n```\n- 输出结果：\n``` console\n2018-05-09 23:03:01.082413+0800 BlockDemo[3349:946888] <__NSMallocBlock__: 0x600000440090>\n```\n- 小结：\n引用外部变量的 block 保存在 :\n`ARC` : 堆区 NSMallocBlock\n`MRC` : 栈区 NSStackBlock\n因此在定义 block 属性时应该使用 `copy` 关键字，将 block 从栈区复制到堆区\n\n## Block属性\n``` objc\n//定义 block 属性\n@property (nonatomic, copy) void (^demoBlock)();\n\n-(void)blockDemo {\n int i = 10;\n void(^myBlock)() = ^ {\n   NSLog(@\"hello world %d\", i);\n };\n\n NSLog(@\"%@\", myBlock);\n // 错误的写法，不会调用 setter 方法,MRC下,无法拷贝到堆区\n //`_demoBlock` = myBlock;\n // 正确的写法，调用 setter 方法，并且对 block 进行 copy\n self.demoBlock = myBlock;\n NSLog(@\"%@\", self.demoBlock);\n}\n```\n- `MRC`下输出结果：会执行`copy`操作，从栈区拷贝到堆区\n``` console\n2018-05-10 12:03:17.374375+0800 BlockDemo[1225:138257] <__NSStackBlock__: 0x7ffee68509a8>\n2018-05-10 12:03:17.374581+0800 BlockDemo[1225:138257] <__NSMallocBlock__: 0x60000025dca0>\n```\n- `ARC`下输出结果：不会执行`copy`操作,本身就在堆区\n``` console\n2018-05-10 12:04:42.891691+0800 BlockDemo[1308:145791] <__NSMallocBlock__: 0x6040002471d0>\n2018-05-10 12:04:42.891902+0800 BlockDemo[1308:145791] <__NSMallocBlock__: 0x6040002471d0>\n```\n> **注** : 为了避免程序员的麻烦,在 ARC 中,定义了引用外部变量的 block,系统默认都是在堆区的!\n\n## copy关键字的探讨\n### ARC （为什么可以用`copy / strong`）\n``` objc\n- (void)blockDemo\n{\n int num = 10;\n void (^task)() = ^ {\n   NSLog(@\"%d\",num);\n };\n // ARC : 堆区 ==> __NSMallocBlock__\n // ARC环境下,属性也是强引用,同时会copy\n // self.task = task;\n // ARC环境下,成员变量也是强引用,同时会copy\n `_task` = task;\n NSLog(@\"%@ -- %@\",task,`_task`);\n}\n```\n- 输出结果：\n``` console\n2018-05-09 23:14:43.139413+0800 BlockDemo[3468:994925] <__NSMallocBlock__: 0x60400024ea60> -- <__NSMallocBlock__: 0x60400024ea60>\n```\n- 小结：\n在`ARC`环境下,上述block本来就保存在堆区,给属性赋值的时候,调用`setter`方法时,只会给一个引用.故`ARC`下使用strong和copy的效果是一模一样的\n\n### MRC（为什么必须用`copy`）\n``` objc\n-(void)blockDemo\n{\n int num = 10;\n void (^task)() = ^ {\n   NSLog(@\"%d\",num);\n };\n // MRC : 栈区 ==> __NSStackBlock__\n // 这个赋值过程会copy,也会引用计数+1\n //    self.task = task;\n // 这个赋值过程不会copy,仅仅是引用计数+1,内存依然在栈区\n `_task` = task;\n NSLog(@\"%@ -- %@\",task,`_task`);\n}\n```\n- 输出结果：\n``` console\n2018-05-09 23:17:25.352415+0800 BlockDemo[3528:1006735] <__NSStackBlock__: 0x7ffee98cc9a8> -- <__NSStackBlock__: 0x7ffee98cc9a8>\n```\n- 小结：\n在`MRC`环境下,调用成员变量进行赋值,仅仅是引用计数加1;不会进行`copy`操作. 所以内存依然在栈区.\n\n### 面试时如何回答？\n当Block被引入到OC时 ，OC仍是MRC的管理内存模式 ，在MRC管理模式中，Block处于栈区，超出作用域就会被销毁 ，如果用一个属性来全局的记录这个Block，就必须满足两个条件：\n1.这个属性必须对Block强引用\n2.需要把Block拷贝到堆区\n要满足以上两个条件就需要使用`copy`修饰符\n\n# Block的循环引用\n## 满足什么条件会出现循环应用\n- block和外部变量`互相强引用`导致出现循环引用,内存不能正常释放\n- **坑**：不要在Block的内部使用成员变量(`_name`)，而要尽量使用属性，因为看不到`self`字段，会造成如果出现循环引用不容易发现的问题.\n> **注**：不是所有的 self. 都会出现循环引用 —— block 执行完毕就销毁，例如 UIView 的动画代码\n\n## 如何解决循环引用\n``` objc\n// 使用 __weak 修饰符,定义一个弱引用的对象\n__weak typeof(self) weakSelf = self;\n```\n","source":"_posts/oc-block.md","raw":"---\ntitle: Objc - Block\ndate: 2018-05-10 11:21:20\ntags: [iOS,Objc,Block]\ncategories: [iOS,Objc]\n---\n# 引言\nApple 在iOS4.0之后推出Block，它本身封装了一段代码并可以将这段代码当做变量，参数，属性，数据类型，函数（匿名），代码块（只有在被调用时才会执行）等等，使用方式灵活，功能十分强大。\n\n# Block的简单使用\n## 定义Block\n- 无参无返回值\n ``` objc\n  void(^block)() = ^(){\n   NSLog(@\"this is a no param and no return of block\");\n };\n block();\n ```\n- 有参无返回值\n ``` objc\n void(^block)(NSString * ) = ^(NSString * param){\n   NSLog(@\"this is a has param and no return of block\");\n };\n block(@\"param\");\n ```\n- 有参有返回值\n ``` objc\n NSString *(^block)(NSString * ) = ^(NSString * param){\n   NSLog(@\"this is a has param and return of block\");\n   return @\"\";\n };\n block(@\"param\");\n ```\n\n## 定义Block的快捷方式\n> Block 的定义可以借助键入 inlineBlock 速记.\n\n``` objc\n// inlineBlock\nreturnType (^blockName)(parameterTypes) = ^(parameters) {\n   statements\n};\n```\n## Block定义成属性\n``` objc\n@property (copy, nonatomic) void(^block)();\n```\n## Block作参数\n``` objc\n-(void)demo04{\n void(^block)() = ^{\n   NSLog(@\"block become param\");\n };\n [self callbackWith:block];\n}\n\n-(void)callbackWith:(void(^)())block{\n //调用外界传入的block\n block();\n}\n```\n## typedef 定义Block\n``` objc\n// 声明\ntypedef void(^MyBlock)();\n// 使用\nMyBlock block01 = ^{\n NSLog(@\"block01\");\n};\nblock01();\n```\n- 小结：方便之处在于可以常用类型的Block可以用typedef来定义\n# Block与外部变量\n## Block内部访问/引用 外部变量\n``` objc\n int num = 10;\n NSLog(@\"%p %d\",&num,num);\n void(^block)() = ^{\n   NSLog(@\"%p %d\",&num,num);\n };\n num = 20;\n NSLog(@\"%@ %p %d\",block,&num,num);\n block();\n```\n- `MRC`输出结果：\n``` console\n018-05-10 12:33:49.178446+0800 BlockDemo[1825:245809] 0x7ffee31dc9dc 10\n2018-05-10 12:33:49.178655+0800 BlockDemo[1825:245809] <__NSStackBlock__: 0x7ffee31dc9a8> 0x7ffee31dc9dc 20\n2018-05-10 12:33:49.178770+0800 BlockDemo[1825:245809] 0x7ffee31dc9c8 10\n```\n- `ARC`输出结果：\n``` console\n2018-05-10 12:36:47.248638+0800 BlockDemo[1887:256355] 0x7ffee517f9dc 10\n2018-05-10 12:36:47.248856+0800 BlockDemo[1887:256355] <__NSMallocBlock__: 0x604000259530> 0x7ffee517f9dc 20\n2018-05-10 12:36:47.249115+0800 BlockDemo[1887:256355] 0x604000259550 10\n```\n- 小结\n在block中访问外部的变量时，会自动拷贝到内存一份并开辟新的地址，这就是深拷贝\n\n## Block内部修改外部变量\n``` objc\n__block int num = 10;\n NSLog(@\"%p %d\",&num,num);\n void(^block)() = ^{\n   num = 30;\n   NSLog(@\"%p %d\",&num,num);\n };\n num = 20;\n NSLog(@\"%@ %p %d\",block,&num,num);\n block();\n```\n- `MRC`输出结果：\n``` console\n2018-05-10 12:41:56.490868+0800 BlockDemo[2018:272473] 0x7ffee14519d8 10\n2018-05-10 12:41:56.491055+0800 BlockDemo[2018:272473] <__NSStackBlock__: 0x7ffee1451980> 0x7ffee14519d8 20\n2018-05-10 12:41:56.491165+0800 BlockDemo[2018:272473] 0x7ffee14519d8 30\n```\n- `ARC`输出结果：\n``` console\n2018-05-10 12:43:13.402390+0800 BlockDemo[2047:277009] 0x7ffeea3149d8 10\n2018-05-10 12:43:13.402662+0800 BlockDemo[2047:277009] <__NSMallocBlock__: 0x60400024da70> 0x604000034cf8 20\n2018-05-10 12:43:13.402777+0800 BlockDemo[2047:277009] 0x604000034cf8 30\n```\n- 小结\nblock内修改的外部变量，需要用`__block`修饰.在此后若被block访问修改，变量的内存地址会重新指向拷贝后开辟的新的内存地址.\n\n## 验证一个想法\n> 在`ARC`/`MRC`中block内`引用`外部变量地址如何在堆栈中变化，通过将Block自身作为自身的参数传入\n\n\n``` objc\nint num = 10;\n   NSLog(@\"%p %d\",&num,num);\n   void(^block)(void(^)()) = ^(void(^block2)()){\n       NSLog(@\"%@ %p %d\",block2,&num,num);\n   };\n   num = 20;\n   NSLog(@\"%@ %p %d\",block,&num,num);\n   //本身作为参数传入并输出指针对象的堆栈\n   block(block);\n```\n\n  - 1.在`ARC`中block内引用外部变量地址如何在堆栈中变化，输出结果:\n\n``` console\n2018-05-10 12:51:29.359318+0800 BlockDemo[2216:302301] 0x7ffee29ab9dc 10\n2018-05-10 12:51:29.359563+0800 BlockDemo[2216:302301] <__NSMallocBlock__: 0x600000259230> 0x7ffee29ab9dc 20\n2018-05-10 12:51:29.359708+0800 BlockDemo[2216:302301] <__NSMallocBlock__: 0x600000259230> 0x600000259250 10\n```\n  - 2.在`MRC`中block内引用外部变量地址如何在堆栈中变化，输出结果:\n\n``` console\n2018-05-10 12:46:27.120908+0800 BlockDemo[2153:287894] 0x7ffee8a699dc 10\n2018-05-10 12:46:27.121106+0800 BlockDemo[2153:287894] <__NSStackBlock__: 0x7ffee8a699a8> 0x7ffee8a699dc 20\n2018-05-10 12:46:27.121239+0800 BlockDemo[2153:287894] <__NSStackBlock__: 0x7ffee8a699a8> 0x7ffee8a699c8 10\n```\n- 小结：\n`ARC`下，永远在堆区中。`MRC`下永远在栈区中\n\n# block内存管理（MRC/ARC）\n## 函数体\n### 当函数体不变时\n``` objc\nvoid(^myBlock)() = ^ {\n NSLog(@\"hello world\");\n};\nNSLog(@\"%@\", myBlock);\n```\n- 输出结果：\n``` console\n2018-05-09 22:59:07.637768+0800 BlockDemo[3288:930159] <__NSGlobalBlock__: 0x10afa20d8>\n```\n- 小结：\n不引用任何外部变量的 block 保存在全局区 NSGlobalBlock，如果Block没有引用外部变量,那么这个Block的函数体内部包装的代码都不会发生变化,而且执行效率高,保存在全局区;(类似不变的字符串存在常量区)\n### 当函数体可变时（即访问修改外部变量时）\n``` objc\nint i = 10;\nvoid(^myBlock)() = ^ {\n NSLog(@\"hello world %d\", i);\n};\nNSLog(@\"%@\", myBlock);\n```\n- 输出结果：\n``` console\n2018-05-09 23:03:01.082413+0800 BlockDemo[3349:946888] <__NSMallocBlock__: 0x600000440090>\n```\n- 小结：\n引用外部变量的 block 保存在 :\n`ARC` : 堆区 NSMallocBlock\n`MRC` : 栈区 NSStackBlock\n因此在定义 block 属性时应该使用 `copy` 关键字，将 block 从栈区复制到堆区\n\n## Block属性\n``` objc\n//定义 block 属性\n@property (nonatomic, copy) void (^demoBlock)();\n\n-(void)blockDemo {\n int i = 10;\n void(^myBlock)() = ^ {\n   NSLog(@\"hello world %d\", i);\n };\n\n NSLog(@\"%@\", myBlock);\n // 错误的写法，不会调用 setter 方法,MRC下,无法拷贝到堆区\n //`_demoBlock` = myBlock;\n // 正确的写法，调用 setter 方法，并且对 block 进行 copy\n self.demoBlock = myBlock;\n NSLog(@\"%@\", self.demoBlock);\n}\n```\n- `MRC`下输出结果：会执行`copy`操作，从栈区拷贝到堆区\n``` console\n2018-05-10 12:03:17.374375+0800 BlockDemo[1225:138257] <__NSStackBlock__: 0x7ffee68509a8>\n2018-05-10 12:03:17.374581+0800 BlockDemo[1225:138257] <__NSMallocBlock__: 0x60000025dca0>\n```\n- `ARC`下输出结果：不会执行`copy`操作,本身就在堆区\n``` console\n2018-05-10 12:04:42.891691+0800 BlockDemo[1308:145791] <__NSMallocBlock__: 0x6040002471d0>\n2018-05-10 12:04:42.891902+0800 BlockDemo[1308:145791] <__NSMallocBlock__: 0x6040002471d0>\n```\n> **注** : 为了避免程序员的麻烦,在 ARC 中,定义了引用外部变量的 block,系统默认都是在堆区的!\n\n## copy关键字的探讨\n### ARC （为什么可以用`copy / strong`）\n``` objc\n- (void)blockDemo\n{\n int num = 10;\n void (^task)() = ^ {\n   NSLog(@\"%d\",num);\n };\n // ARC : 堆区 ==> __NSMallocBlock__\n // ARC环境下,属性也是强引用,同时会copy\n // self.task = task;\n // ARC环境下,成员变量也是强引用,同时会copy\n `_task` = task;\n NSLog(@\"%@ -- %@\",task,`_task`);\n}\n```\n- 输出结果：\n``` console\n2018-05-09 23:14:43.139413+0800 BlockDemo[3468:994925] <__NSMallocBlock__: 0x60400024ea60> -- <__NSMallocBlock__: 0x60400024ea60>\n```\n- 小结：\n在`ARC`环境下,上述block本来就保存在堆区,给属性赋值的时候,调用`setter`方法时,只会给一个引用.故`ARC`下使用strong和copy的效果是一模一样的\n\n### MRC（为什么必须用`copy`）\n``` objc\n-(void)blockDemo\n{\n int num = 10;\n void (^task)() = ^ {\n   NSLog(@\"%d\",num);\n };\n // MRC : 栈区 ==> __NSStackBlock__\n // 这个赋值过程会copy,也会引用计数+1\n //    self.task = task;\n // 这个赋值过程不会copy,仅仅是引用计数+1,内存依然在栈区\n `_task` = task;\n NSLog(@\"%@ -- %@\",task,`_task`);\n}\n```\n- 输出结果：\n``` console\n2018-05-09 23:17:25.352415+0800 BlockDemo[3528:1006735] <__NSStackBlock__: 0x7ffee98cc9a8> -- <__NSStackBlock__: 0x7ffee98cc9a8>\n```\n- 小结：\n在`MRC`环境下,调用成员变量进行赋值,仅仅是引用计数加1;不会进行`copy`操作. 所以内存依然在栈区.\n\n### 面试时如何回答？\n当Block被引入到OC时 ，OC仍是MRC的管理内存模式 ，在MRC管理模式中，Block处于栈区，超出作用域就会被销毁 ，如果用一个属性来全局的记录这个Block，就必须满足两个条件：\n1.这个属性必须对Block强引用\n2.需要把Block拷贝到堆区\n要满足以上两个条件就需要使用`copy`修饰符\n\n# Block的循环引用\n## 满足什么条件会出现循环应用\n- block和外部变量`互相强引用`导致出现循环引用,内存不能正常释放\n- **坑**：不要在Block的内部使用成员变量(`_name`)，而要尽量使用属性，因为看不到`self`字段，会造成如果出现循环引用不容易发现的问题.\n> **注**：不是所有的 self. 都会出现循环引用 —— block 执行完毕就销毁，例如 UIView 的动画代码\n\n## 如何解决循环引用\n``` objc\n// 使用 __weak 修饰符,定义一个弱引用的对象\n__weak typeof(self) weakSelf = self;\n```\n","slug":"oc-block","published":1,"updated":"2019-01-13T05:10:36.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d39002ql1fqnxlc2e64","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>Apple 在iOS4.0之后推出Block，它本身封装了一段代码并可以将这段代码当做变量，参数，属性，数据类型，函数（匿名），代码块（只有在被调用时才会执行）等等，使用方式灵活，功能十分强大。</p>\n<h1 id=\"Block的简单使用\"><a href=\"#Block的简单使用\" class=\"headerlink\" title=\"Block的简单使用\"></a>Block的简单使用</h1><h2 id=\"定义Block\"><a href=\"#定义Block\" class=\"headerlink\" title=\"定义Block\"></a>定义Block</h2><ul>\n<li><p>无参无返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a no param and no return of block\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有参无返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block)(<span class=\"built_in\">NSString</span> * ) = ^(<span class=\"built_in\">NSString</span> * param)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a has param and no return of block\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(<span class=\"string\">@\"param\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有参有返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *(^block)(<span class=\"built_in\">NSString</span> * ) = ^(<span class=\"built_in\">NSString</span> * param)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a has param and return of block\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(<span class=\"string\">@\"param\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"定义Block的快捷方式\"><a href=\"#定义Block的快捷方式\" class=\"headerlink\" title=\"定义Block的快捷方式\"></a>定义Block的快捷方式</h2><blockquote>\n<p>Block 的定义可以借助键入 inlineBlock 速记.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inlineBlock</span></span><br><span class=\"line\">returnType (^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class=\"line\">   statements</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Block定义成属性\"><a href=\"#Block定义成属性\" class=\"headerlink\" title=\"Block定义成属性\"></a>Block定义成属性</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">void</span>(^block)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"Block作参数\"><a href=\"#Block作参数\" class=\"headerlink\" title=\"Block作参数\"></a>Block作参数</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)demo04&#123;</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block become param\"</span>);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> [<span class=\"keyword\">self</span> callbackWith:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)callbackWith:(<span class=\"keyword\">void</span>(^)())block&#123;</span><br><span class=\"line\"> <span class=\"comment\">//调用外界传入的block</span></span><br><span class=\"line\"> block();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"typedef-定义Block\"><a href=\"#typedef-定义Block\" class=\"headerlink\" title=\"typedef 定义Block\"></a>typedef 定义Block</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^MyBlock)();</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">MyBlock block01 = ^&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block01\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block01();</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>小结：方便之处在于可以常用类型的Block可以用typedef来定义</p>\n<h1 id=\"Block与外部变量\"><a href=\"#Block与外部变量\" class=\"headerlink\" title=\"Block与外部变量\"></a>Block与外部变量</h1><h2 id=\"Block内部访问-引用-外部变量\"><a href=\"#Block内部访问-引用-外部变量\" class=\"headerlink\" title=\"Block内部访问/引用 外部变量\"></a>Block内部访问/引用 外部变量</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">num = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>MRC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">018-05-10 12:33:49.178446+0800 BlockDemo[1825:245809] 0x7ffee31dc9dc 10</span><br><span class=\"line\">2018-05-10 12:33:49.178655+0800 BlockDemo[1825:245809] &lt;__NSStackBlock__: 0x7ffee31dc9a8&gt; 0x7ffee31dc9dc 20</span><br><span class=\"line\">2018-05-10 12:33:49.178770+0800 BlockDemo[1825:245809] 0x7ffee31dc9c8 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:36:47.248638+0800 BlockDemo[1887:256355] 0x7ffee517f9dc 10</span><br><span class=\"line\">2018-05-10 12:36:47.248856+0800 BlockDemo[1887:256355] &lt;__NSMallocBlock__: 0x604000259530&gt; 0x7ffee517f9dc 20</span><br><span class=\"line\">2018-05-10 12:36:47.249115+0800 BlockDemo[1887:256355] 0x604000259550 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结<br>在block中访问外部的变量时，会自动拷贝到内存一份并开辟新的地址，这就是深拷贝</p>\n</li>\n</ul>\n<h2 id=\"Block内部修改外部变量\"><a href=\"#Block内部修改外部变量\" class=\"headerlink\" title=\"Block内部修改外部变量\"></a>Block内部修改外部变量</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">   num = <span class=\"number\">30</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> num = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\"> block();</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>MRC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:41:56.490868+0800 BlockDemo[2018:272473] 0x7ffee14519d8 10</span><br><span class=\"line\">2018-05-10 12:41:56.491055+0800 BlockDemo[2018:272473] &lt;__NSStackBlock__: 0x7ffee1451980&gt; 0x7ffee14519d8 20</span><br><span class=\"line\">2018-05-10 12:41:56.491165+0800 BlockDemo[2018:272473] 0x7ffee14519d8 30</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:43:13.402390+0800 BlockDemo[2047:277009] 0x7ffeea3149d8 10</span><br><span class=\"line\">2018-05-10 12:43:13.402662+0800 BlockDemo[2047:277009] &lt;__NSMallocBlock__: 0x60400024da70&gt; 0x604000034cf8 20</span><br><span class=\"line\">2018-05-10 12:43:13.402777+0800 BlockDemo[2047:277009] 0x604000034cf8 30</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结<br>block内修改的外部变量，需要用<code>__block</code>修饰.在此后若被block访问修改，变量的内存地址会重新指向拷贝后开辟的新的内存地址.</p>\n</li>\n</ul>\n<h2 id=\"验证一个想法\"><a href=\"#验证一个想法\" class=\"headerlink\" title=\"验证一个想法\"></a>验证一个想法</h2><blockquote>\n<p>在<code>ARC</code>/<code>MRC</code>中block内<code>引用</code>外部变量地址如何在堆栈中变化，通过将Block自身作为自身的参数传入</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>(^)()) = ^(<span class=\"keyword\">void</span>(^block2)())&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block2,&amp;num,num);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   num = <span class=\"number\">20</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\">   <span class=\"comment\">//本身作为参数传入并输出指针对象的堆栈</span></span><br><span class=\"line\">   block(block);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.在<code>ARC</code>中block内引用外部变量地址如何在堆栈中变化，输出结果:</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:51:29.359318+0800 BlockDemo[2216:302301] 0x7ffee29ab9dc 10</span><br><span class=\"line\">2018-05-10 12:51:29.359563+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x7ffee29ab9dc 20</span><br><span class=\"line\">2018-05-10 12:51:29.359708+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x600000259250 10</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.在<code>MRC</code>中block内引用外部变量地址如何在堆栈中变化，输出结果:</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:46:27.120908+0800 BlockDemo[2153:287894] 0x7ffee8a699dc 10</span><br><span class=\"line\">2018-05-10 12:46:27.121106+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699dc 20</span><br><span class=\"line\">2018-05-10 12:46:27.121239+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699c8 10</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小结：<br><code>ARC</code>下，永远在堆区中。<code>MRC</code>下永远在栈区中</li>\n</ul>\n<h1 id=\"block内存管理（MRC-ARC）\"><a href=\"#block内存管理（MRC-ARC）\" class=\"headerlink\" title=\"block内存管理（MRC/ARC）\"></a>block内存管理（MRC/ARC）</h1><h2 id=\"函数体\"><a href=\"#函数体\" class=\"headerlink\" title=\"函数体\"></a>函数体</h2><h3 id=\"当函数体不变时\"><a href=\"#当函数体不变时\" class=\"headerlink\" title=\"当函数体不变时\"></a>当函数体不变时</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 22:59:07.637768+0800 BlockDemo[3288:930159] &lt;__NSGlobalBlock__: 0x10afa20d8&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>不引用任何外部变量的 block 保存在全局区 NSGlobalBlock，如果Block没有引用外部变量,那么这个Block的函数体内部包装的代码都不会发生变化,而且执行效率高,保存在全局区;(类似不变的字符串存在常量区)</p>\n<h3 id=\"当函数体可变时（即访问修改外部变量时）\"><a href=\"#当函数体可变时（即访问修改外部变量时）\" class=\"headerlink\" title=\"当函数体可变时（即访问修改外部变量时）\"></a>当函数体可变时（即访问修改外部变量时）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world %d\"</span>, i);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:03:01.082413+0800 BlockDemo[3349:946888] &lt;__NSMallocBlock__: 0x600000440090&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>引用外部变量的 block 保存在 :<br><code>ARC</code> : 堆区 NSMallocBlock<br><code>MRC</code> : 栈区 NSStackBlock<br>因此在定义 block 属性时应该使用 <code>copy</code> 关键字，将 block 从栈区复制到堆区</p>\n</li>\n</ul>\n<h2 id=\"Block属性\"><a href=\"#Block属性\" class=\"headerlink\" title=\"Block属性\"></a>Block属性</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义 block 属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span> (^demoBlock)();</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)blockDemo &#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world %d\"</span>, i);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br><span class=\"line\"> <span class=\"comment\">// 错误的写法，不会调用 setter 方法,MRC下,无法拷贝到堆区</span></span><br><span class=\"line\"> <span class=\"comment\">//`_demoBlock` = myBlock;</span></span><br><span class=\"line\"> <span class=\"comment\">// 正确的写法，调用 setter 方法，并且对 block 进行 copy</span></span><br><span class=\"line\"> <span class=\"keyword\">self</span>.demoBlock = myBlock;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>.demoBlock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>MRC</code>下输出结果：会执行<code>copy</code>操作，从栈区拷贝到堆区</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:03:17.374375+0800 BlockDemo[1225:138257] &lt;__NSStackBlock__: 0x7ffee68509a8&gt;</span><br><span class=\"line\">2018-05-10 12:03:17.374581+0800 BlockDemo[1225:138257] &lt;__NSMallocBlock__: 0x60000025dca0&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>下输出结果：不会执行<code>copy</code>操作,本身就在堆区</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:04:42.891691+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt;</span><br><span class=\"line\">2018-05-10 12:04:42.891902+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>注</strong> : 为了避免程序员的麻烦,在 ARC 中,定义了引用外部变量的 block,系统默认都是在堆区的!</p>\n</blockquote>\n<h2 id=\"copy关键字的探讨\"><a href=\"#copy关键字的探讨\" class=\"headerlink\" title=\"copy关键字的探讨\"></a>copy关键字的探讨</h2><h3 id=\"ARC-（为什么可以用copy-strong）\"><a href=\"#ARC-（为什么可以用copy-strong）\" class=\"headerlink\" title=\"ARC （为什么可以用copy / strong）\"></a>ARC （为什么可以用<code>copy / strong</code>）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)blockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (^task)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"comment\">// ARC : 堆区 ==&gt; __NSMallocBlock__</span></span><br><span class=\"line\"> <span class=\"comment\">// ARC环境下,属性也是强引用,同时会copy</span></span><br><span class=\"line\"> <span class=\"comment\">// self.task = task;</span></span><br><span class=\"line\"> <span class=\"comment\">// ARC环境下,成员变量也是强引用,同时会copy</span></span><br><span class=\"line\"> `_task` = task;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@\"</span>,task,`_task`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:14:43.139413+0800 BlockDemo[3468:994925] &lt;__NSMallocBlock__: 0x60400024ea60&gt; -- &lt;__NSMallocBlock__: 0x60400024ea60&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>在<code>ARC</code>环境下,上述block本来就保存在堆区,给属性赋值的时候,调用<code>setter</code>方法时,只会给一个引用.故<code>ARC</code>下使用strong和copy的效果是一模一样的</p>\n</li>\n</ul>\n<h3 id=\"MRC（为什么必须用copy）\"><a href=\"#MRC（为什么必须用copy）\" class=\"headerlink\" title=\"MRC（为什么必须用copy）\"></a>MRC（为什么必须用<code>copy</code>）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)blockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (^task)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"comment\">// MRC : 栈区 ==&gt; __NSStackBlock__</span></span><br><span class=\"line\"> <span class=\"comment\">// 这个赋值过程会copy,也会引用计数+1</span></span><br><span class=\"line\"> <span class=\"comment\">//    self.task = task;</span></span><br><span class=\"line\"> <span class=\"comment\">// 这个赋值过程不会copy,仅仅是引用计数+1,内存依然在栈区</span></span><br><span class=\"line\"> `_task` = task;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@\"</span>,task,`_task`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:17:25.352415+0800 BlockDemo[3528:1006735] &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt; -- &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>在<code>MRC</code>环境下,调用成员变量进行赋值,仅仅是引用计数加1;不会进行<code>copy</code>操作. 所以内存依然在栈区.</p>\n</li>\n</ul>\n<h3 id=\"面试时如何回答？\"><a href=\"#面试时如何回答？\" class=\"headerlink\" title=\"面试时如何回答？\"></a>面试时如何回答？</h3><p>当Block被引入到OC时 ，OC仍是MRC的管理内存模式 ，在MRC管理模式中，Block处于栈区，超出作用域就会被销毁 ，如果用一个属性来全局的记录这个Block，就必须满足两个条件：<br>1.这个属性必须对Block强引用<br>2.需要把Block拷贝到堆区<br>要满足以上两个条件就需要使用<code>copy</code>修饰符</p>\n<h1 id=\"Block的循环引用\"><a href=\"#Block的循环引用\" class=\"headerlink\" title=\"Block的循环引用\"></a>Block的循环引用</h1><h2 id=\"满足什么条件会出现循环应用\"><a href=\"#满足什么条件会出现循环应用\" class=\"headerlink\" title=\"满足什么条件会出现循环应用\"></a>满足什么条件会出现循环应用</h2><ul>\n<li>block和外部变量<code>互相强引用</code>导致出现循环引用,内存不能正常释放</li>\n<li><strong>坑</strong>：不要在Block的内部使用成员变量(<code>_name</code>)，而要尽量使用属性，因为看不到<code>self</code>字段，会造成如果出现循环引用不容易发现的问题.<blockquote>\n<p><strong>注</strong>：不是所有的 self. 都会出现循环引用 —— block 执行完毕就销毁，例如 UIView 的动画代码</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"如何解决循环引用\"><a href=\"#如何解决循环引用\" class=\"headerlink\" title=\"如何解决循环引用\"></a>如何解决循环引用</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 __weak 修饰符,定义一个弱引用的对象</span></span><br><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>Apple 在iOS4.0之后推出Block，它本身封装了一段代码并可以将这段代码当做变量，参数，属性，数据类型，函数（匿名），代码块（只有在被调用时才会执行）等等，使用方式灵活，功能十分强大。</p>\n<h1 id=\"Block的简单使用\"><a href=\"#Block的简单使用\" class=\"headerlink\" title=\"Block的简单使用\"></a>Block的简单使用</h1><h2 id=\"定义Block\"><a href=\"#定义Block\" class=\"headerlink\" title=\"定义Block\"></a>定义Block</h2><ul>\n<li><p>无参无返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^()&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a no param and no return of block\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有参无返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^block)(<span class=\"built_in\">NSString</span> * ) = ^(<span class=\"built_in\">NSString</span> * param)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a has param and no return of block\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(<span class=\"string\">@\"param\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有参有返回值</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *(^block)(<span class=\"built_in\">NSString</span> * ) = ^(<span class=\"built_in\">NSString</span> * param)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"this is a has param and return of block\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">@\"\"</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(<span class=\"string\">@\"param\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"定义Block的快捷方式\"><a href=\"#定义Block的快捷方式\" class=\"headerlink\" title=\"定义Block的快捷方式\"></a>定义Block的快捷方式</h2><blockquote>\n<p>Block 的定义可以借助键入 inlineBlock 速记.</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inlineBlock</span></span><br><span class=\"line\">returnType (^blockName)(parameterTypes) = ^(parameters) &#123;</span><br><span class=\"line\">   statements</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Block定义成属性\"><a href=\"#Block定义成属性\" class=\"headerlink\" title=\"Block定义成属性\"></a>Block定义成属性</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"keyword\">void</span>(^block)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"Block作参数\"><a href=\"#Block作参数\" class=\"headerlink\" title=\"Block作参数\"></a>Block作参数</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)demo04&#123;</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block become param\"</span>);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> [<span class=\"keyword\">self</span> callbackWith:block];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)callbackWith:(<span class=\"keyword\">void</span>(^)())block&#123;</span><br><span class=\"line\"> <span class=\"comment\">//调用外界传入的block</span></span><br><span class=\"line\"> block();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"typedef-定义Block\"><a href=\"#typedef-定义Block\" class=\"headerlink\" title=\"typedef 定义Block\"></a>typedef 定义Block</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^MyBlock)();</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">MyBlock block01 = ^&#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"block01\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block01();</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>小结：方便之处在于可以常用类型的Block可以用typedef来定义</p>\n<h1 id=\"Block与外部变量\"><a href=\"#Block与外部变量\" class=\"headerlink\" title=\"Block与外部变量\"></a>Block与外部变量</h1><h2 id=\"Block内部访问-引用-外部变量\"><a href=\"#Block内部访问-引用-外部变量\" class=\"headerlink\" title=\"Block内部访问/引用 外部变量\"></a>Block内部访问/引用 外部变量</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">  <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">num = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>MRC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">018-05-10 12:33:49.178446+0800 BlockDemo[1825:245809] 0x7ffee31dc9dc 10</span><br><span class=\"line\">2018-05-10 12:33:49.178655+0800 BlockDemo[1825:245809] &lt;__NSStackBlock__: 0x7ffee31dc9a8&gt; 0x7ffee31dc9dc 20</span><br><span class=\"line\">2018-05-10 12:33:49.178770+0800 BlockDemo[1825:245809] 0x7ffee31dc9c8 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:36:47.248638+0800 BlockDemo[1887:256355] 0x7ffee517f9dc 10</span><br><span class=\"line\">2018-05-10 12:36:47.248856+0800 BlockDemo[1887:256355] &lt;__NSMallocBlock__: 0x604000259530&gt; 0x7ffee517f9dc 20</span><br><span class=\"line\">2018-05-10 12:36:47.249115+0800 BlockDemo[1887:256355] 0x604000259550 10</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结<br>在block中访问外部的变量时，会自动拷贝到内存一份并开辟新的地址，这就是深拷贝</p>\n</li>\n</ul>\n<h2 id=\"Block内部修改外部变量\"><a href=\"#Block内部修改外部变量\" class=\"headerlink\" title=\"Block内部修改外部变量\"></a>Block内部修改外部变量</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^block)() = ^&#123;</span><br><span class=\"line\">   num = <span class=\"number\">30</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> num = <span class=\"number\">20</span>;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\"> block();</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>MRC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:41:56.490868+0800 BlockDemo[2018:272473] 0x7ffee14519d8 10</span><br><span class=\"line\">2018-05-10 12:41:56.491055+0800 BlockDemo[2018:272473] &lt;__NSStackBlock__: 0x7ffee1451980&gt; 0x7ffee14519d8 20</span><br><span class=\"line\">2018-05-10 12:41:56.491165+0800 BlockDemo[2018:272473] 0x7ffee14519d8 30</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:43:13.402390+0800 BlockDemo[2047:277009] 0x7ffeea3149d8 10</span><br><span class=\"line\">2018-05-10 12:43:13.402662+0800 BlockDemo[2047:277009] &lt;__NSMallocBlock__: 0x60400024da70&gt; 0x604000034cf8 20</span><br><span class=\"line\">2018-05-10 12:43:13.402777+0800 BlockDemo[2047:277009] 0x604000034cf8 30</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结<br>block内修改的外部变量，需要用<code>__block</code>修饰.在此后若被block访问修改，变量的内存地址会重新指向拷贝后开辟的新的内存地址.</p>\n</li>\n</ul>\n<h2 id=\"验证一个想法\"><a href=\"#验证一个想法\" class=\"headerlink\" title=\"验证一个想法\"></a>验证一个想法</h2><blockquote>\n<p>在<code>ARC</code>/<code>MRC</code>中block内<code>引用</code>外部变量地址如何在堆栈中变化，通过将Block自身作为自身的参数传入</p>\n</blockquote>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%p %d\"</span>,&amp;num,num);</span><br><span class=\"line\">   <span class=\"keyword\">void</span>(^block)(<span class=\"keyword\">void</span>(^)()) = ^(<span class=\"keyword\">void</span>(^block2)())&#123;</span><br><span class=\"line\">       <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block2,&amp;num,num);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">   num = <span class=\"number\">20</span>;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %p %d\"</span>,block,&amp;num,num);</span><br><span class=\"line\">   <span class=\"comment\">//本身作为参数传入并输出指针对象的堆栈</span></span><br><span class=\"line\">   block(block);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.在<code>ARC</code>中block内引用外部变量地址如何在堆栈中变化，输出结果:</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:51:29.359318+0800 BlockDemo[2216:302301] 0x7ffee29ab9dc 10</span><br><span class=\"line\">2018-05-10 12:51:29.359563+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x7ffee29ab9dc 20</span><br><span class=\"line\">2018-05-10 12:51:29.359708+0800 BlockDemo[2216:302301] &lt;__NSMallocBlock__: 0x600000259230&gt; 0x600000259250 10</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2.在<code>MRC</code>中block内引用外部变量地址如何在堆栈中变化，输出结果:</li>\n</ul>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:46:27.120908+0800 BlockDemo[2153:287894] 0x7ffee8a699dc 10</span><br><span class=\"line\">2018-05-10 12:46:27.121106+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699dc 20</span><br><span class=\"line\">2018-05-10 12:46:27.121239+0800 BlockDemo[2153:287894] &lt;__NSStackBlock__: 0x7ffee8a699a8&gt; 0x7ffee8a699c8 10</span><br></pre></td></tr></table></figure>\n<ul>\n<li>小结：<br><code>ARC</code>下，永远在堆区中。<code>MRC</code>下永远在栈区中</li>\n</ul>\n<h1 id=\"block内存管理（MRC-ARC）\"><a href=\"#block内存管理（MRC-ARC）\" class=\"headerlink\" title=\"block内存管理（MRC/ARC）\"></a>block内存管理（MRC/ARC）</h1><h2 id=\"函数体\"><a href=\"#函数体\" class=\"headerlink\" title=\"函数体\"></a>函数体</h2><h3 id=\"当函数体不变时\"><a href=\"#当函数体不变时\" class=\"headerlink\" title=\"当函数体不变时\"></a>当函数体不变时</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 22:59:07.637768+0800 BlockDemo[3288:930159] &lt;__NSGlobalBlock__: 0x10afa20d8&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>不引用任何外部变量的 block 保存在全局区 NSGlobalBlock，如果Block没有引用外部变量,那么这个Block的函数体内部包装的代码都不会发生变化,而且执行效率高,保存在全局区;(类似不变的字符串存在常量区)</p>\n<h3 id=\"当函数体可变时（即访问修改外部变量时）\"><a href=\"#当函数体可变时（即访问修改外部变量时）\" class=\"headerlink\" title=\"当函数体可变时（即访问修改外部变量时）\"></a>当函数体可变时（即访问修改外部变量时）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world %d\"</span>, i);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:03:01.082413+0800 BlockDemo[3349:946888] &lt;__NSMallocBlock__: 0x600000440090&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>引用外部变量的 block 保存在 :<br><code>ARC</code> : 堆区 NSMallocBlock<br><code>MRC</code> : 栈区 NSStackBlock<br>因此在定义 block 属性时应该使用 <code>copy</code> 关键字，将 block 从栈区复制到堆区</p>\n</li>\n</ul>\n<h2 id=\"Block属性\"><a href=\"#Block属性\" class=\"headerlink\" title=\"Block属性\"></a>Block属性</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义 block 属性</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"keyword\">void</span> (^demoBlock)();</span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)blockDemo &#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span>(^myBlock)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"hello world %d\"</span>, i);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, myBlock);</span><br><span class=\"line\"> <span class=\"comment\">// 错误的写法，不会调用 setter 方法,MRC下,无法拷贝到堆区</span></span><br><span class=\"line\"> <span class=\"comment\">//`_demoBlock` = myBlock;</span></span><br><span class=\"line\"> <span class=\"comment\">// 正确的写法，调用 setter 方法，并且对 block 进行 copy</span></span><br><span class=\"line\"> <span class=\"keyword\">self</span>.demoBlock = myBlock;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"keyword\">self</span>.demoBlock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>MRC</code>下输出结果：会执行<code>copy</code>操作，从栈区拷贝到堆区</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:03:17.374375+0800 BlockDemo[1225:138257] &lt;__NSStackBlock__: 0x7ffee68509a8&gt;</span><br><span class=\"line\">2018-05-10 12:03:17.374581+0800 BlockDemo[1225:138257] &lt;__NSMallocBlock__: 0x60000025dca0&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ARC</code>下输出结果：不会执行<code>copy</code>操作,本身就在堆区</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-10 12:04:42.891691+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt;</span><br><span class=\"line\">2018-05-10 12:04:42.891902+0800 BlockDemo[1308:145791] &lt;__NSMallocBlock__: 0x6040002471d0&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>注</strong> : 为了避免程序员的麻烦,在 ARC 中,定义了引用外部变量的 block,系统默认都是在堆区的!</p>\n</blockquote>\n<h2 id=\"copy关键字的探讨\"><a href=\"#copy关键字的探讨\" class=\"headerlink\" title=\"copy关键字的探讨\"></a>copy关键字的探讨</h2><h3 id=\"ARC-（为什么可以用copy-strong）\"><a href=\"#ARC-（为什么可以用copy-strong）\" class=\"headerlink\" title=\"ARC （为什么可以用copy / strong）\"></a>ARC （为什么可以用<code>copy / strong</code>）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)blockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (^task)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"comment\">// ARC : 堆区 ==&gt; __NSMallocBlock__</span></span><br><span class=\"line\"> <span class=\"comment\">// ARC环境下,属性也是强引用,同时会copy</span></span><br><span class=\"line\"> <span class=\"comment\">// self.task = task;</span></span><br><span class=\"line\"> <span class=\"comment\">// ARC环境下,成员变量也是强引用,同时会copy</span></span><br><span class=\"line\"> `_task` = task;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@\"</span>,task,`_task`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:14:43.139413+0800 BlockDemo[3468:994925] &lt;__NSMallocBlock__: 0x60400024ea60&gt; -- &lt;__NSMallocBlock__: 0x60400024ea60&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>在<code>ARC</code>环境下,上述block本来就保存在堆区,给属性赋值的时候,调用<code>setter</code>方法时,只会给一个引用.故<code>ARC</code>下使用strong和copy的效果是一模一样的</p>\n</li>\n</ul>\n<h3 id=\"MRC（为什么必须用copy）\"><a href=\"#MRC（为什么必须用copy）\" class=\"headerlink\" title=\"MRC（为什么必须用copy）\"></a>MRC（为什么必须用<code>copy</code>）</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"keyword\">void</span>)blockDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">int</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\"> <span class=\"keyword\">void</span> (^task)() = ^ &#123;</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,num);</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"comment\">// MRC : 栈区 ==&gt; __NSStackBlock__</span></span><br><span class=\"line\"> <span class=\"comment\">// 这个赋值过程会copy,也会引用计数+1</span></span><br><span class=\"line\"> <span class=\"comment\">//    self.task = task;</span></span><br><span class=\"line\"> <span class=\"comment\">// 这个赋值过程不会copy,仅仅是引用计数+1,内存依然在栈区</span></span><br><span class=\"line\"> `_task` = task;</span><br><span class=\"line\"> <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ -- %@\"</span>,task,`_task`);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>输出结果：</p>\n<figure class=\"highlight console\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-05-09 23:17:25.352415+0800 BlockDemo[3528:1006735] &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt; -- &lt;__NSStackBlock__: 0x7ffee98cc9a8&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>小结：<br>在<code>MRC</code>环境下,调用成员变量进行赋值,仅仅是引用计数加1;不会进行<code>copy</code>操作. 所以内存依然在栈区.</p>\n</li>\n</ul>\n<h3 id=\"面试时如何回答？\"><a href=\"#面试时如何回答？\" class=\"headerlink\" title=\"面试时如何回答？\"></a>面试时如何回答？</h3><p>当Block被引入到OC时 ，OC仍是MRC的管理内存模式 ，在MRC管理模式中，Block处于栈区，超出作用域就会被销毁 ，如果用一个属性来全局的记录这个Block，就必须满足两个条件：<br>1.这个属性必须对Block强引用<br>2.需要把Block拷贝到堆区<br>要满足以上两个条件就需要使用<code>copy</code>修饰符</p>\n<h1 id=\"Block的循环引用\"><a href=\"#Block的循环引用\" class=\"headerlink\" title=\"Block的循环引用\"></a>Block的循环引用</h1><h2 id=\"满足什么条件会出现循环应用\"><a href=\"#满足什么条件会出现循环应用\" class=\"headerlink\" title=\"满足什么条件会出现循环应用\"></a>满足什么条件会出现循环应用</h2><ul>\n<li>block和外部变量<code>互相强引用</code>导致出现循环引用,内存不能正常释放</li>\n<li><strong>坑</strong>：不要在Block的内部使用成员变量(<code>_name</code>)，而要尽量使用属性，因为看不到<code>self</code>字段，会造成如果出现循环引用不容易发现的问题.<blockquote>\n<p><strong>注</strong>：不是所有的 self. 都会出现循环引用 —— block 执行完毕就销毁，例如 UIView 的动画代码</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"如何解决循环引用\"><a href=\"#如何解决循环引用\" class=\"headerlink\" title=\"如何解决循环引用\"></a>如何解决循环引用</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 __weak 修饰符,定义一个弱引用的对象</span></span><br><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br></pre></td></tr></table></figure>\n"},{"title":"Objc - 对象之类对象和元类对象","date":"2018-06-09T00:12:45.000Z","_content":"# Objc 中的类（Class）\n众所周知，在 Objc 中所有的对象都由类实例化而来，**殊不知类本身也是一种对象**。\n在 Objc 中几乎所有的类都是 NSObject 的子类，NSObject类定义如下(忽略方法声明)：\n``` Objc\n@interface NSObject <NSObject> {\n    Class  isa  OBJC_ISA_AVAILABILITY;\n}\n@end\n```\n这个`isa`是什么呢？在 `objc.h` 中我们发现它仅仅是一个 typedef 的结构体(struct)定义，如下:\n```Objc\ntypedef struct objc_class *Class;\n```\n同样的`objc_class`又是什么呢？在 Objc2.0 中 `objc_class`定义如下：\n``` Objc\nstruct objc_class {\n    Class  isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class  super_class  OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n这里又出现了一个`isa`指针，这个 `isa`和上一个有什么区别和联系？\n\n答：其实在 Objc 中任何类的定义都是一个对象。在编译的时候，编译器会给每一个类生成且只生成一个「描述其定义的对象」，也就是苹果公司所说的类对象（class object）；因为 Objc 和是一门动态语言，程序中所有的实例对象（instance object）是在运行时库生成的，而这个类对象（class object）就是运行时库用来创建实例对象（instance object）的依据。\n\n再回到之前的问题，为什么实例对象（instance object）的`isa`指针指向的类对象（class object）里面还有一个`isa`指针？而这个类对象（class object）的 `isa` 指向的仍然是一个`objc_class`，它就是元类对象（metaclass object）；那么实例对象（instance object）、类对象（class object）、元类对象（metaclass object）之间的关系是怎样的呢？如下图：\n![类关系图](/images/objc_class_relationship.png)\n\n## 类对象（class object）\n### 类对象的实质\n类对象是由编译器创建的；**即在编译时所谓的类，就是指类对象**。\n>官方文档中这样描述：The class object is the compiled version of the class.\n\n任何直接或间接继承了 NSObject 的类，它的实例对象(instance object)中都有一个`isa`指针，指向它的类对象(class object)。**这个类对象(class object)中存储了关于这个实例对象(instance object)所属的类定义的一切：包括变量、方法、遵守的协议等**。因此类对象(class object)能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例对象(instance object)，但是类对象不能访问任何实力对象的内容。\n当调用一个类方法(class method)时，例如：`[NSObject alloc]`，事实上是发送了一个消息给它的类对象。\n\n### 类对象和实例对象的区别\n尽管类对象保留了一个类实例的原型，但它并不是实例本身；它没有自己的实例变量，也不能执行那些类的实例方法\n\n### 类对象与类名\n在代码中，类对象由类名表示。\n\n举个例子：定义类 Person 继承 NSObject\n``` Objc\nint versionNumber = [Person version];\n```\n在上面的例子中，Person 类从 NSObject 继承 `version`方法来返回类的版本号；只有在消息表达式中作为接受者时，类名才代表类对象。\n\n另外，类对象和其他对象一样也是`id`类型，例如：\n``` objc\nid clazz = [anyObject class];\nid pClazz = [Person class];\n```\n总之，类对象是一个功能完整的对象，所以也能被动态识别(dynamically typed)接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量)，只是在运行时产生实例的代理。\n\n## 元类对象（metaclass object）\n### 元类对象的实质\n实际上，**类对象是元类对象的一个实例**，元类对象描述了一个类对象，就像类对象描述了普通的实例对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应；当一个类发送消息时候，`objc_msgSend`会通过类对象的`isa`指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替实例对象描述了实例化方法。\n\n很显然，**元类也是对象，也应该是其他类的实例**，实际上元类是根元类(root class's metaclass)的实例，而根元类是其自身的实例，即根元类的 `isa` 指针指向自身。\n\n类的`super_class`指向其父类，而元类的 `super_class` 则指向父类的元类；元类的 `super_class` 链与类的`super_class`链平行，所以类方法的继承与实例方法的继承也是平行的。而根元类(root class's metaclass)的 `super_class`指向根类(root class)，这样整个指针链就链起来了。\n\n综上所述: 类对象(class object)保存的是关于实例对象的信息(ivar，实例方法等)，而元类对象(metaclass object)存储的是关于类的信息（类的版本，名字，类方法等）\n要注意的是，类对象和元类对象的定义都是`objc_class`结构。其不同仅仅是在用途上，比如其中的方法列表在类对象(class object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中保存的则是类方法(class method)\n\n## 类对象和元类对象的相关方法\n### object_getClass\n`object_getClass`跟随实例的`isa`指针，返回此实例所属的类，对于实例对象(instance object)返回的是类(class)，而对于类(class)则返回的是元类(metacalss)\n\n### class\n`class`方法对于实例对象(instance object)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身，即`[@“instance” class]`则返回的是`__NSCFConstantString`；而`[NSString class]`则返回的是 `NSString`\n\n### class_isMetaClass\n`class_isMetaClass`判断某类是否是元类\n\n### objc_allocateClassPair\n使用`objc_allocateClassPair`可在运行时创建新的类对与元类对，使用`class_addMethod`和`class_addIvar`可向类中增加方法和实例变量，最后使用`objc_registerClassPair`注册后，就可以使用此类了。\n\n# 参考资料\n- https://blog.csdn.net/wzzvictory/article/details/8592492\n","source":"_posts/oc-class-relationships.md","raw":"---\ntitle: Objc - 对象之类对象和元类对象\ntags: [iOS,Objc]\ncategories: [iOS,Objc]\ndate: 2018-06-09 08:12:45\n---\n# Objc 中的类（Class）\n众所周知，在 Objc 中所有的对象都由类实例化而来，**殊不知类本身也是一种对象**。\n在 Objc 中几乎所有的类都是 NSObject 的子类，NSObject类定义如下(忽略方法声明)：\n``` Objc\n@interface NSObject <NSObject> {\n    Class  isa  OBJC_ISA_AVAILABILITY;\n}\n@end\n```\n这个`isa`是什么呢？在 `objc.h` 中我们发现它仅仅是一个 typedef 的结构体(struct)定义，如下:\n```Objc\ntypedef struct objc_class *Class;\n```\n同样的`objc_class`又是什么呢？在 Objc2.0 中 `objc_class`定义如下：\n``` Objc\nstruct objc_class {\n    Class  isa  OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n    Class  super_class  OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n```\n这里又出现了一个`isa`指针，这个 `isa`和上一个有什么区别和联系？\n\n答：其实在 Objc 中任何类的定义都是一个对象。在编译的时候，编译器会给每一个类生成且只生成一个「描述其定义的对象」，也就是苹果公司所说的类对象（class object）；因为 Objc 和是一门动态语言，程序中所有的实例对象（instance object）是在运行时库生成的，而这个类对象（class object）就是运行时库用来创建实例对象（instance object）的依据。\n\n再回到之前的问题，为什么实例对象（instance object）的`isa`指针指向的类对象（class object）里面还有一个`isa`指针？而这个类对象（class object）的 `isa` 指向的仍然是一个`objc_class`，它就是元类对象（metaclass object）；那么实例对象（instance object）、类对象（class object）、元类对象（metaclass object）之间的关系是怎样的呢？如下图：\n![类关系图](/images/objc_class_relationship.png)\n\n## 类对象（class object）\n### 类对象的实质\n类对象是由编译器创建的；**即在编译时所谓的类，就是指类对象**。\n>官方文档中这样描述：The class object is the compiled version of the class.\n\n任何直接或间接继承了 NSObject 的类，它的实例对象(instance object)中都有一个`isa`指针，指向它的类对象(class object)。**这个类对象(class object)中存储了关于这个实例对象(instance object)所属的类定义的一切：包括变量、方法、遵守的协议等**。因此类对象(class object)能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例对象(instance object)，但是类对象不能访问任何实力对象的内容。\n当调用一个类方法(class method)时，例如：`[NSObject alloc]`，事实上是发送了一个消息给它的类对象。\n\n### 类对象和实例对象的区别\n尽管类对象保留了一个类实例的原型，但它并不是实例本身；它没有自己的实例变量，也不能执行那些类的实例方法\n\n### 类对象与类名\n在代码中，类对象由类名表示。\n\n举个例子：定义类 Person 继承 NSObject\n``` Objc\nint versionNumber = [Person version];\n```\n在上面的例子中，Person 类从 NSObject 继承 `version`方法来返回类的版本号；只有在消息表达式中作为接受者时，类名才代表类对象。\n\n另外，类对象和其他对象一样也是`id`类型，例如：\n``` objc\nid clazz = [anyObject class];\nid pClazz = [Person class];\n```\n总之，类对象是一个功能完整的对象，所以也能被动态识别(dynamically typed)接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量)，只是在运行时产生实例的代理。\n\n## 元类对象（metaclass object）\n### 元类对象的实质\n实际上，**类对象是元类对象的一个实例**，元类对象描述了一个类对象，就像类对象描述了普通的实例对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应；当一个类发送消息时候，`objc_msgSend`会通过类对象的`isa`指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替实例对象描述了实例化方法。\n\n很显然，**元类也是对象，也应该是其他类的实例**，实际上元类是根元类(root class's metaclass)的实例，而根元类是其自身的实例，即根元类的 `isa` 指针指向自身。\n\n类的`super_class`指向其父类，而元类的 `super_class` 则指向父类的元类；元类的 `super_class` 链与类的`super_class`链平行，所以类方法的继承与实例方法的继承也是平行的。而根元类(root class's metaclass)的 `super_class`指向根类(root class)，这样整个指针链就链起来了。\n\n综上所述: 类对象(class object)保存的是关于实例对象的信息(ivar，实例方法等)，而元类对象(metaclass object)存储的是关于类的信息（类的版本，名字，类方法等）\n要注意的是，类对象和元类对象的定义都是`objc_class`结构。其不同仅仅是在用途上，比如其中的方法列表在类对象(class object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中保存的则是类方法(class method)\n\n## 类对象和元类对象的相关方法\n### object_getClass\n`object_getClass`跟随实例的`isa`指针，返回此实例所属的类，对于实例对象(instance object)返回的是类(class)，而对于类(class)则返回的是元类(metacalss)\n\n### class\n`class`方法对于实例对象(instance object)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身，即`[@“instance” class]`则返回的是`__NSCFConstantString`；而`[NSString class]`则返回的是 `NSString`\n\n### class_isMetaClass\n`class_isMetaClass`判断某类是否是元类\n\n### objc_allocateClassPair\n使用`objc_allocateClassPair`可在运行时创建新的类对与元类对，使用`class_addMethod`和`class_addIvar`可向类中增加方法和实例变量，最后使用`objc_registerClassPair`注册后，就可以使用此类了。\n\n# 参考资料\n- https://blog.csdn.net/wzzvictory/article/details/8592492\n","slug":"oc-class-relationships","published":1,"updated":"2019-01-13T05:10:40.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d3a002sl1fq9b1uo16w","content":"<h1 id=\"Objc-中的类（Class）\"><a href=\"#Objc-中的类（Class）\" class=\"headerlink\" title=\"Objc 中的类（Class）\"></a>Objc 中的类（Class）</h1><p>众所周知，在 Objc 中所有的对象都由类实例化而来，<strong>殊不知类本身也是一种对象</strong>。<br>在 Objc 中几乎所有的类都是 NSObject 的子类，NSObject类定义如下(忽略方法声明)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSObject</span>&gt; </span>&#123;</span><br><span class=\"line\">    Class  isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>这个<code>isa</code>是什么呢？在 <code>objc.h</code> 中我们发现它仅仅是一个 typedef 的结构体(struct)定义，如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>\n<p>同样的<code>objc_class</code>又是什么呢？在 Objc2.0 中 <code>objc_class</code>定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class  isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></span><br><span class=\"line\">    Class  super_class  OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>这里又出现了一个<code>isa</code>指针，这个 <code>isa</code>和上一个有什么区别和联系？</p>\n<p>答：其实在 Objc 中任何类的定义都是一个对象。在编译的时候，编译器会给每一个类生成且只生成一个「描述其定义的对象」，也就是苹果公司所说的类对象（class object）；因为 Objc 和是一门动态语言，程序中所有的实例对象（instance object）是在运行时库生成的，而这个类对象（class object）就是运行时库用来创建实例对象（instance object）的依据。</p>\n<p>再回到之前的问题，为什么实例对象（instance object）的<code>isa</code>指针指向的类对象（class object）里面还有一个<code>isa</code>指针？而这个类对象（class object）的 <code>isa</code> 指向的仍然是一个<code>objc_class</code>，它就是元类对象（metaclass object）；那么实例对象（instance object）、类对象（class object）、元类对象（metaclass object）之间的关系是怎样的呢？如下图：<br><img src=\"/images/objc_class_relationship.png\" alt=\"类关系图\"></p>\n<h2 id=\"类对象（class-object）\"><a href=\"#类对象（class-object）\" class=\"headerlink\" title=\"类对象（class object）\"></a>类对象（class object）</h2><h3 id=\"类对象的实质\"><a href=\"#类对象的实质\" class=\"headerlink\" title=\"类对象的实质\"></a>类对象的实质</h3><p>类对象是由编译器创建的；<strong>即在编译时所谓的类，就是指类对象</strong>。</p>\n<blockquote>\n<p>官方文档中这样描述：The class object is the compiled version of the class.</p>\n</blockquote>\n<p>任何直接或间接继承了 NSObject 的类，它的实例对象(instance object)中都有一个<code>isa</code>指针，指向它的类对象(class object)。<strong>这个类对象(class object)中存储了关于这个实例对象(instance object)所属的类定义的一切：包括变量、方法、遵守的协议等</strong>。因此类对象(class object)能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例对象(instance object)，但是类对象不能访问任何实力对象的内容。<br>当调用一个类方法(class method)时，例如：<code>[NSObject alloc]</code>，事实上是发送了一个消息给它的类对象。</p>\n<h3 id=\"类对象和实例对象的区别\"><a href=\"#类对象和实例对象的区别\" class=\"headerlink\" title=\"类对象和实例对象的区别\"></a>类对象和实例对象的区别</h3><p>尽管类对象保留了一个类实例的原型，但它并不是实例本身；它没有自己的实例变量，也不能执行那些类的实例方法</p>\n<h3 id=\"类对象与类名\"><a href=\"#类对象与类名\" class=\"headerlink\" title=\"类对象与类名\"></a>类对象与类名</h3><p>在代码中，类对象由类名表示。</p>\n<p>举个例子：定义类 Person 继承 NSObject<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> versionNumber = [Person version];</span><br></pre></td></tr></table></figure></p>\n<p>在上面的例子中，Person 类从 NSObject 继承 <code>version</code>方法来返回类的版本号；只有在消息表达式中作为接受者时，类名才代表类对象。</p>\n<p>另外，类对象和其他对象一样也是<code>id</code>类型，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> clazz = [anyObject <span class=\"keyword\">class</span>];</span><br><span class=\"line\"><span class=\"keyword\">id</span> pClazz = [Person <span class=\"keyword\">class</span>];</span><br></pre></td></tr></table></figure></p>\n<p>总之，类对象是一个功能完整的对象，所以也能被动态识别(dynamically typed)接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量)，只是在运行时产生实例的代理。</p>\n<h2 id=\"元类对象（metaclass-object）\"><a href=\"#元类对象（metaclass-object）\" class=\"headerlink\" title=\"元类对象（metaclass object）\"></a>元类对象（metaclass object）</h2><h3 id=\"元类对象的实质\"><a href=\"#元类对象的实质\" class=\"headerlink\" title=\"元类对象的实质\"></a>元类对象的实质</h3><p>实际上，<strong>类对象是元类对象的一个实例</strong>，元类对象描述了一个类对象，就像类对象描述了普通的实例对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应；当一个类发送消息时候，<code>objc_msgSend</code>会通过类对象的<code>isa</code>指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替实例对象描述了实例化方法。</p>\n<p>很显然，<strong>元类也是对象，也应该是其他类的实例</strong>，实际上元类是根元类(root class’s metaclass)的实例，而根元类是其自身的实例，即根元类的 <code>isa</code> 指针指向自身。</p>\n<p>类的<code>super_class</code>指向其父类，而元类的 <code>super_class</code> 则指向父类的元类；元类的 <code>super_class</code> 链与类的<code>super_class</code>链平行，所以类方法的继承与实例方法的继承也是平行的。而根元类(root class’s metaclass)的 <code>super_class</code>指向根类(root class)，这样整个指针链就链起来了。</p>\n<p>综上所述: 类对象(class object)保存的是关于实例对象的信息(ivar，实例方法等)，而元类对象(metaclass object)存储的是关于类的信息（类的版本，名字，类方法等）<br>要注意的是，类对象和元类对象的定义都是<code>objc_class</code>结构。其不同仅仅是在用途上，比如其中的方法列表在类对象(class object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中保存的则是类方法(class method)</p>\n<h2 id=\"类对象和元类对象的相关方法\"><a href=\"#类对象和元类对象的相关方法\" class=\"headerlink\" title=\"类对象和元类对象的相关方法\"></a>类对象和元类对象的相关方法</h2><h3 id=\"object-getClass\"><a href=\"#object-getClass\" class=\"headerlink\" title=\"object_getClass\"></a>object_getClass</h3><p><code>object_getClass</code>跟随实例的<code>isa</code>指针，返回此实例所属的类，对于实例对象(instance object)返回的是类(class)，而对于类(class)则返回的是元类(metacalss)</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p><code>class</code>方法对于实例对象(instance object)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身，即<code>[@“instance” class]</code>则返回的是<code>__NSCFConstantString</code>；而<code>[NSString class]</code>则返回的是 <code>NSString</code></p>\n<h3 id=\"class-isMetaClass\"><a href=\"#class-isMetaClass\" class=\"headerlink\" title=\"class_isMetaClass\"></a>class_isMetaClass</h3><p><code>class_isMetaClass</code>判断某类是否是元类</p>\n<h3 id=\"objc-allocateClassPair\"><a href=\"#objc-allocateClassPair\" class=\"headerlink\" title=\"objc_allocateClassPair\"></a>objc_allocateClassPair</h3><p>使用<code>objc_allocateClassPair</code>可在运行时创建新的类对与元类对，使用<code>class_addMethod</code>和<code>class_addIvar</code>可向类中增加方法和实例变量，最后使用<code>objc_registerClassPair</code>注册后，就可以使用此类了。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://blog.csdn.net/wzzvictory/article/details/8592492\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wzzvictory/article/details/8592492</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objc-中的类（Class）\"><a href=\"#Objc-中的类（Class）\" class=\"headerlink\" title=\"Objc 中的类（Class）\"></a>Objc 中的类（Class）</h1><p>众所周知，在 Objc 中所有的对象都由类实例化而来，<strong>殊不知类本身也是一种对象</strong>。<br>在 Objc 中几乎所有的类都是 NSObject 的子类，NSObject类定义如下(忽略方法声明)：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSObject</span>&gt; </span>&#123;</span><br><span class=\"line\">    Class  isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></p>\n<p>这个<code>isa</code>是什么呢？在 <code>objc.h</code> 中我们发现它仅仅是一个 typedef 的结构体(struct)定义，如下:<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>\n<p>同样的<code>objc_class</code>又是什么呢？在 Objc2.0 中 <code>objc_class</code>定义如下：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class  isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"><span class=\"meta\">#if !__OBJC2__</span></span><br><span class=\"line\">    Class  super_class  OBJC2_UNAVAILABLE;</span><br><span class=\"line\"><span class=\"meta\">#endif</span></span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>\n<p>这里又出现了一个<code>isa</code>指针，这个 <code>isa</code>和上一个有什么区别和联系？</p>\n<p>答：其实在 Objc 中任何类的定义都是一个对象。在编译的时候，编译器会给每一个类生成且只生成一个「描述其定义的对象」，也就是苹果公司所说的类对象（class object）；因为 Objc 和是一门动态语言，程序中所有的实例对象（instance object）是在运行时库生成的，而这个类对象（class object）就是运行时库用来创建实例对象（instance object）的依据。</p>\n<p>再回到之前的问题，为什么实例对象（instance object）的<code>isa</code>指针指向的类对象（class object）里面还有一个<code>isa</code>指针？而这个类对象（class object）的 <code>isa</code> 指向的仍然是一个<code>objc_class</code>，它就是元类对象（metaclass object）；那么实例对象（instance object）、类对象（class object）、元类对象（metaclass object）之间的关系是怎样的呢？如下图：<br><img src=\"/images/objc_class_relationship.png\" alt=\"类关系图\"></p>\n<h2 id=\"类对象（class-object）\"><a href=\"#类对象（class-object）\" class=\"headerlink\" title=\"类对象（class object）\"></a>类对象（class object）</h2><h3 id=\"类对象的实质\"><a href=\"#类对象的实质\" class=\"headerlink\" title=\"类对象的实质\"></a>类对象的实质</h3><p>类对象是由编译器创建的；<strong>即在编译时所谓的类，就是指类对象</strong>。</p>\n<blockquote>\n<p>官方文档中这样描述：The class object is the compiled version of the class.</p>\n</blockquote>\n<p>任何直接或间接继承了 NSObject 的类，它的实例对象(instance object)中都有一个<code>isa</code>指针，指向它的类对象(class object)。<strong>这个类对象(class object)中存储了关于这个实例对象(instance object)所属的类定义的一切：包括变量、方法、遵守的协议等</strong>。因此类对象(class object)能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例对象(instance object)，但是类对象不能访问任何实力对象的内容。<br>当调用一个类方法(class method)时，例如：<code>[NSObject alloc]</code>，事实上是发送了一个消息给它的类对象。</p>\n<h3 id=\"类对象和实例对象的区别\"><a href=\"#类对象和实例对象的区别\" class=\"headerlink\" title=\"类对象和实例对象的区别\"></a>类对象和实例对象的区别</h3><p>尽管类对象保留了一个类实例的原型，但它并不是实例本身；它没有自己的实例变量，也不能执行那些类的实例方法</p>\n<h3 id=\"类对象与类名\"><a href=\"#类对象与类名\" class=\"headerlink\" title=\"类对象与类名\"></a>类对象与类名</h3><p>在代码中，类对象由类名表示。</p>\n<p>举个例子：定义类 Person 继承 NSObject<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> versionNumber = [Person version];</span><br></pre></td></tr></table></figure></p>\n<p>在上面的例子中，Person 类从 NSObject 继承 <code>version</code>方法来返回类的版本号；只有在消息表达式中作为接受者时，类名才代表类对象。</p>\n<p>另外，类对象和其他对象一样也是<code>id</code>类型，例如：<br><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> clazz = [anyObject <span class=\"keyword\">class</span>];</span><br><span class=\"line\"><span class=\"keyword\">id</span> pClazz = [Person <span class=\"keyword\">class</span>];</span><br></pre></td></tr></table></figure></p>\n<p>总之，类对象是一个功能完整的对象，所以也能被动态识别(dynamically typed)接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量)，只是在运行时产生实例的代理。</p>\n<h2 id=\"元类对象（metaclass-object）\"><a href=\"#元类对象（metaclass-object）\" class=\"headerlink\" title=\"元类对象（metaclass object）\"></a>元类对象（metaclass object）</h2><h3 id=\"元类对象的实质\"><a href=\"#元类对象的实质\" class=\"headerlink\" title=\"元类对象的实质\"></a>元类对象的实质</h3><p>实际上，<strong>类对象是元类对象的一个实例</strong>，元类对象描述了一个类对象，就像类对象描述了普通的实例对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应；当一个类发送消息时候，<code>objc_msgSend</code>会通过类对象的<code>isa</code>指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替实例对象描述了实例化方法。</p>\n<p>很显然，<strong>元类也是对象，也应该是其他类的实例</strong>，实际上元类是根元类(root class’s metaclass)的实例，而根元类是其自身的实例，即根元类的 <code>isa</code> 指针指向自身。</p>\n<p>类的<code>super_class</code>指向其父类，而元类的 <code>super_class</code> 则指向父类的元类；元类的 <code>super_class</code> 链与类的<code>super_class</code>链平行，所以类方法的继承与实例方法的继承也是平行的。而根元类(root class’s metaclass)的 <code>super_class</code>指向根类(root class)，这样整个指针链就链起来了。</p>\n<p>综上所述: 类对象(class object)保存的是关于实例对象的信息(ivar，实例方法等)，而元类对象(metaclass object)存储的是关于类的信息（类的版本，名字，类方法等）<br>要注意的是，类对象和元类对象的定义都是<code>objc_class</code>结构。其不同仅仅是在用途上，比如其中的方法列表在类对象(class object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中保存的则是类方法(class method)</p>\n<h2 id=\"类对象和元类对象的相关方法\"><a href=\"#类对象和元类对象的相关方法\" class=\"headerlink\" title=\"类对象和元类对象的相关方法\"></a>类对象和元类对象的相关方法</h2><h3 id=\"object-getClass\"><a href=\"#object-getClass\" class=\"headerlink\" title=\"object_getClass\"></a>object_getClass</h3><p><code>object_getClass</code>跟随实例的<code>isa</code>指针，返回此实例所属的类，对于实例对象(instance object)返回的是类(class)，而对于类(class)则返回的是元类(metacalss)</p>\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p><code>class</code>方法对于实例对象(instance object)会返回类(class)，但对于类(class)则不会返回元类(metaclass)，而只会返回类本身，即<code>[@“instance” class]</code>则返回的是<code>__NSCFConstantString</code>；而<code>[NSString class]</code>则返回的是 <code>NSString</code></p>\n<h3 id=\"class-isMetaClass\"><a href=\"#class-isMetaClass\" class=\"headerlink\" title=\"class_isMetaClass\"></a>class_isMetaClass</h3><p><code>class_isMetaClass</code>判断某类是否是元类</p>\n<h3 id=\"objc-allocateClassPair\"><a href=\"#objc-allocateClassPair\" class=\"headerlink\" title=\"objc_allocateClassPair\"></a>objc_allocateClassPair</h3><p>使用<code>objc_allocateClassPair</code>可在运行时创建新的类对与元类对，使用<code>class_addMethod</code>和<code>class_addIvar</code>可向类中增加方法和实例变量，最后使用<code>objc_registerClassPair</code>注册后，就可以使用此类了。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://blog.csdn.net/wzzvictory/article/details/8592492\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wzzvictory/article/details/8592492</a></li>\n</ul>\n"},{"title":"川藏南线(318)之旅","date":"2016-06-10T02:01:47.000Z","_content":"\n\n## 写于川藏出发前\n\n![](/images/318/1255460395.jpg)\n\n> 有些事现在不做，永远都不会去做了。\n\n> 318国道，东起上海人民广场，西至中国与尼泊尔边界樟木口岸友谊桥，全长5476公里，是中国最长的国道。“那些伟大的景观不在318的两旁，就在道路南北不出200公里的范围内：钱塘江、西湖、太湖、黄山、庐山、鄱阳湖、洞庭湖、九华山、神农架、恩施、张家界、峨眉山……”而进入四川，318又被称为川藏公路，“贡嘎山、海螺沟、折多山、雅拉雪山、南迦巴瓦、加拉白垒，海拔8000米以上的马卡鲁峰、卓奥友峰、珠穆朗玛峰、希夏邦马峰……还有无数的雪山和冰川在这条大道的两旁。318国道从纵横中国大地的公路网中脱颖而出，成为了一条绵延万里的景观长廊。”2006年，318国道被《中国国家地理》评为“中国景观大道”（据百度百科和维基百科）\n\n我这次的目标，就是走318国道最为壮丽的一段，成都-拉萨，川藏线。\n为了这次旅行，从4月开始跑5km储备体能，于5月31日正式离职，收拾行囊。\n我一直相信，真正的美景始终在路上，旅行的奇妙体验在于不可预知，在于每天早晨会在不同的地方醒来。\n\n我热爱旅行，迷恋在路上的感觉，在之前的生命里，我一直以体验不同的生活为最大乐趣。\n\n塞内加曾说：何必为部分的生活而哭泣，君不见，全部的人生都让人潸然泪下。\n今天，就要踏上旅途，也许失败，也许艰难，也许幸福。\n但，无论怎样，我都已准备好去享受这一切，双手合十，愿一路平安。\n\n2016/06/06 成都\n\n## 成都小记\n\n这次的成都之行是一次难忘的经历，第一次住青旅的新鲜感，陌生人之间互相娴熟的聊天毫无晦涩感，喜欢这种体验。青旅的老板阿铭是我眼中的完美男人，微胖，短须，菜做的色香味，娴熟的琴技加上浑厚的嗓音，悠远的歌声中，让人容易想起旧事，他给旅舍起了个名字，比邻，天涯若比邻的寓意，邻家大哥的感觉，幽默十足。杀人游戏，露天烧烤，这里真的让我恍惚，像家的感觉。以后有机会，希望这个小栈还在，希望再次回到成都能再来这里看看。\n￼![](/images/318/507311534.png)\n三巷一号帮我调车的大哥，我没有机会问他的名字，也没选择他家的旅舍，我非常感谢他，萍水相逢，好人！\n￼![](/images/318/805238010.png)\n终于组到了队伍，七个人，因为担心一下子记不住那么多名字，我们按照年龄做了排序，我排老六，老大是甘肃人，带了队旗，写着brave heart 勇敢的心。\n老二是惠州人，长于深圳，广东仔，86年生。\n老三老四，来自南京，同89年生人，初步接触，老三低调，沉默寡言，曾当过武警，老四爱吹牛，爱说南京那些事儿，话痨，南吹，不算贬义词吧！\n老五是地地道道的四川广安人，四川话说得非常好听，92年的。\n我暂时对老七一无所知，他是最后一个加入我们队伍的，排老七是因为比还我小五个月，哈哈哈，没错终于有比我小的了，94年人。\n￼![](/images/318/2768809826.png)\n希望我们这支队伍能一起冲到最后，不抛弃，不放弃。一路平安。\n出发之前的凌晨，举着手机敲下这些憋足的文字。\n\n2016/06/10 成都\n\n## Day 01\n\n成都-雅安 /小雨转阴 /150km \n￼![](/images/318/IMG_0020.JPG)\n出发伴随着小雨，上午60公里的缓上坡，这段路基本没有什么风景，下午雨停了，90公里的起伏路，累到爆，虽然我心里非常清楚这仅仅是开始，但川藏线真名不虚传，感谢前人留下的路书和攻略，让我们自由前行。\n离开成都时，阿井说，川藏线上每一天都是挑战  \n。\n我的同伴有一个四川广安的小伙，他说真佩服那些能骑到拉萨的人，忍受这种折磨，真不是简单人，我一辈子都不会忘记这一天！我说我们也想成为像他们一样不简单的人，所以我们选择了折磨和痛苦来到了他们曾经走过的路，然后他说对，要做不平凡的事！\n老二说了一句非常经典的适合描述川藏线的话，让我非常感慨: 当你在穿山越岭的另一边，我在孤独的路上没有尽头。\n第一天强行军150公里，老二在骑到名山就给我们打电话派车去接他了，他身体不好可以理解，我也在心底默默的跟自己说，一定不搭车，一定不推车，万事开头难，不抛弃不放弃，加油！\n\n2016/06/10 雅安\n\n## Day 02\n\n雅安-新沟 /晴 / 90km \n![](/images/318/IMG_0046.JPG)\n经过昨晚的休息后，精神好了很多，PP也逐渐适应长时间的摩擦，早上7点起床收拾吃饭，队友要补充装备，上午在*雅安*成墨迹到9点才出发，太阳火辣辣的烤着就上路了，上午状态不错，中午11点多到达*天全*吃午饭，休整一小时后继续前行。\n\n下午有60公里的路程，谁也没想到一路的爬坡，离新沟还有10公里时体力几乎已经透支，路上遇到从名山单骑到新沟，最后3公里与我同行，一句鼓励我，激励我，很感谢他。我只是累到说一句话的力气都没有，安静，只有车轮滚滚向前，蹬踏，全世界都仿佛安静了……\n\n今天是正式从101国道切到318国道，时常会有人们从身旁划过，给你竖起大拇指，说加油！我也会回应大拇指，我理解这应该算是318的文化吧，路上遇到就会互相鼓励，互相帮助！\n\n走318让我对坚持有了重新的感悟，也对生命多了更深一层的认识，虽然我踏上这条传说中的路刚刚两天，我也知道有更多的故事个人等着我去遇见。\n\n![](/images/318/IMG_0039.JPG)\n￼ 2016/06/11 新沟\n\n## Day 03\n\n新沟-泸定 /晴 /57km\n￼![](/images/318/IMG_0058.JPG)\n因为今天的路程不是太多，相对第二天和第一天比较轻松一点，所以我们9点才离开新沟前往泸定，今天要爬的是川藏线第一座叫得上名字的山，先是20公里盘山公路环绕而上，让人欲仙欲死，不过我还是坚持了两不原则，不推车，不搭车，我比大部队晚出发十分钟，加上不擅长爬坡，所以也是最后到达二郎山隧道口，老二和老大在隧道口等着我，让我心里感动了一下下。\n￼![](/images/318/IMG_0078.JPG)\n穿过4公里的隧道，老大说饿了，我们就决定吃饭后再赶往泸定，饭后是30多公里的长坡，很爽，但是很危险，我一直让速度保持在30码以下，人年纪渐长就不敢那么冲动了，我是全队下坡最慢的，下午3点到达红色名城泸定，休整半天，洗脏衣服，出发三天来基本都是湿衣服，汗水不停的流淌，我估计按这样下去骑到拉萨，瘦个20斤不成问题。\n![](/images/318/IMG_0097.JPG)\n下午短暂的休息和洗漱之后，和队友一起去了小学课本中的泸定桥，据说下午6点之后才不收费，大渡河的滔滔江水，让人站在桥上会眩晕，仿佛看到历史伴随着这江水滚滚而去。\n￼ \n2016/06/12 泸定\n\n## Day 04\n\n泸定-康定 /多云 / 52km /海拔 2395m\n\n从北京到成都的那天晚上喉咙疼，第二天就咳嗽加浑身无力，到新沟时已经有所好转，到昨晚还是咳嗽到2点，早上六点就起床收拾出发了，20公里的起伏路，接着就是没完没了的爬坡，下午4点爬到康定红灯笼客栈，连给这座美丽的城市拍照的力气都没有了。\n\n老大今天也搭车了，半路被扎胎，正好给了他搭车的理由，哈哈，我是真的这么理解的，他确实爬不动了，大多数时候都是在推车，队伍中老三和老四打算骑到折多塘的，但老四下午六点才到康定，也是半路被扎胎，不过他还是坚持骑到了康定，给他点赞，他还是那么爱吹牛。\n\n我有些担心，晚上咳嗽很严重，早上起床也感觉有些轻微的感冒，明天海拔就超过3000了，真的不想离开队伍自己休息好养好再走，大家一起从成都出发，如果一起骑到拉萨该是多好的事情！\n\n希望高反不会太严重，耽误大家的时间，希望感冒咳嗽快点好，高原感冒有生命危险啊，今天早些吃药上床休息了，希望一切赶紧好起来。\n![](/images/318/IMG_0157.JPG)\n骑318到现在一直没有精力拍照，总是在赶路赶路……心好累，辜负了那么多美景！\n\n2016/06/13 康定红灯笼客栈\n\n## Day 05\n\n康定 - 折多塘村 /晴 /17km /海拔3300m\n\n康定是座美丽的小城，跑马山我小的时候就知道，据说康定的人都会唱情歌，一问之下竟然是真的。\n\n联系了大学同学，给她发了康定的位置和跑马山的照片，告诉她我经过她的家乡，特此问候，虽然她远在上海...故乡的位置和照片应该会让人感到亲切吧。\n\n图为清晨的青山环绕的康定新城，蓝天白云和远处的雪山，好想就在这住下去...\n￼![](/images/318/IMG_0170.JPG)\n昨晚咳嗽有所好转，休息的也不错，还是早上6点起床，客栈老板是藏族，早餐第一次喝酥油茶，味道还可以，微咸。\n￼![](/images/318/IMG_0184.JPG)\n\n从康定爬到折多塘村，17公里，海拔从2300上升到3300，大家决定就地休整半天，一为了适应高反，大家调整下，再也为了在折多山泡一下传说中的温泉，也是我第一次泡温泉。\n￼![](/images/318/IMG_0197.JPG)\n认识这是什么吗，我真的第一次见，叫日晕。\n￼![](/images/318/IMG_0200.JPG)\n七兄弟在藏民家的合影，房间分为汉室和藏室两种，藏室里面还放着一口棺材，把老三吓的不轻，我也胆小只好和老七一起睡了汉室。\n\n2017/06/14 折多塘村\n\n## Day 06\n\n折多塘 - 折多山 - 新都桥 /小雨，雪，阴 /58km /海拔3600\n\n晚上下了一夜的雨，很早就休息了，早上六点醒来，窗外的雨声还是没有停，老七拉开窗帘看了下，大雨。在群里询问了老大的意见，说继续休整，就继续睡去……\n\n![](/images/318/DraggedImage-81.png)\n\n再醒来就是九点了，看到老四发朋友圈独自上路了，后大家商议决定，老大，二，三，五搭车翻越折多山到新都桥等我和老七，吃过早饭，我和老七就出发了。\n十点出发，22公里，海拔上升到4298，“折多”在藏语中是弯曲的意思，写成汉语又是“折多”二字。被称为康巴第一关，折多山以西就是青藏高原的东部，真正的藏区。\n![](/images/318/DraggedImage-82.png)\n\n伴随着小雨，积雪的青山，我们以平均5码的龟速向着垭口爬行，出发一个小时后，老大他们的车就超越我们扬长而去……\n\n![](/images/318/DraggedImage-83.png)\n\n青山白云间穿行，路遇77岁的老大爷同样骑川藏线，一起合影，佩服的肝肠寸断，我想22岁的年纪再没有任何理由可以阻挡我去做完这件事了吧，就是这样！\n\n![](/images/318/DraggedImage-84.png)\n\n你看那飘扬的经幡，就说明垭口就要到了，折多山被我们征服了，虽然伴随着轻微的高反，心里这时是自豪的！\n只要在路上永远都是故事，到达垭口的时候在碑前拍照，竟然遇到了同县同镇的老乡，他们是组团出游包车从成都出发，我在让队友拍照时，身旁的阿姨用普通话问我，你们是骑车的吗，你们队伍中有没有山西人呀，我说有啊，我就是山西人，接着我问她你山西的吗？山西那里的，她又说我长治的，我就用长治话跟他说我也长治的，然后她说你真的是长治的天呐，对啊，我用壶关话说我是壶关滴，然后她就更震惊的表情看着我我用壶关话说她也是壶关的，哈哈哈哈，世界原来这么小，还遇到了同镇的，于是我又切换到了标准的树掌话，哈哈，都被详细追问到了你爹在那个单位工作看看是不是认识，阿姨和大叔们问我要往哪里去，我说到拉萨，他们说你一定要注意安全啊，嘿嘿，阿姨小跑去车上取下一大包家乡的琪炒，说这个治水土不服，饿了也管饱，你带上，有谁没车上有我去给你拿，实在是推不开，都说近乡情更怯，但我真觉得离乡千万里，乡音更让情更怯，合照，依依分别，大叔还在原处感叹着乡音呐！乡音呐！\n背井离乡多年，漂泊于外面的世界，会让人变得冷漠，是他们的热情感染了我，重拾原来家乡的人可以这么亲切...\n![](/images/318/DraggedImage-85.png)\n康巴第一关，以后的路就是藏区了，出行时的七个人仍然不离不弃，新都桥被称为摄影家家的天堂，到处都是美景，微单依然躺在驮包里，我却没有一点想法去拍点什么……\n![](/images/318/DraggedImage-86.png)\n入住了新都桥桐花里客栈，老板说话让人听起来非常愉快，山东汉子，青岛人，我还给他简单的来了几句青岛话，告诉他我曾经在潍坊上大学，有很多青岛的同学朋友，老板旅行过全国所有的地方，最后留在了这里，开一间小客栈，我们没有过多的交流，但从老大口里听的出这是个有故事的男人。\n![](/images/318/DraggedImage-87.png)\n晚饭的时候看到老大发的朋友圈，是这样的:\n![](/images/318/DraggedImage-88.png)  \n78年的七尺汉子，当着我的面，真的流泪了，我看到他红了眼眶，就把头转了过去，我不喜欢这样，虽然都是性情中人，老大说当他坐着车从我和老七身边划过时，就哭了，真的后悔了。老五接着说，他那时把眼睛望向了窗外，让泪水在里面转几圈，记住放弃的味道……然后骑下去。\n我理解他们，所有人都放弃的时候我会感觉到孤独，但选择了走318我就一定不能让自己后悔，不尝试，不尽力就放弃的后悔。\n\n## Day 07  \n\n新都桥 - 高尔寺山 - 雅江 - 相克宗村 /晴 /92km /海拔3600\n\n今天从七兄弟变成了六个，老三走了，回了南京，我们也不好追问具体详细，昨晚小喝了一杯送别酒，希望老三一路顺风，晚上到达相克宗时听说他已回到了成都。\n8点钟出发爬坡20多公里到高尔寺隧道，老二在半路高反比较严重，我们在隧道口等了一个多小时，隧道将近6公里长，因为正在修建，其中四公里没有灯，所以必须结伴前行。\n![](/images/318/DraggedImage-72.png)\n爬山途中遇到昨天在折多山的77岁老大爷的同伴，也是70岁高龄，身体非常硬朗，重庆人，两人结伴骑过五次长途，曾环过山东半岛，其他的我给忘记了，我问他川藏线是不是他骑过最难最有挑战的，他毫不犹豫的告诉我，是的，在高原攀山越岭，太有挑战了。\n![](/images/318/DraggedImage-73.png)\n半年之前骑行的骑友就没有这种享受了，他们要翻越4659m的高尔寺山，如果折多山被称为康巴第一关，那么高尔寺就是第二关，以前让骑行队伍分开的最多的一座山，挑战和痛苦可想而知……\n从隧道通过后就是40公里的大长坡到雅江，一路的美景，让人心碎的美景，北京从没有过的蓝天白云，就像许少歌里唱的一样：只有青山藏在白云间，蝴蝶自由穿行在清涧。当然没看到蝴蝶，领悟精神，领悟精神！\n\n![](/images/318/DraggedImage-74.png)\n一路的长下坡伴随着大回环，我又是队伍中下坡速度控制的最慢的，下午两点钟我们到达了雅江，休息吃午饭，补充水。\n![](/images/318/DraggedImage-75.png)\n今天的目的地是相克宗村，还有20多公里的陡坡要爬，海拔会重新上升1000多米，所以这一天真正的挑战才刚刚开始，短暂的休息过后，3点钟继续顶着烈日，迎着横风出发了……\n![](/images/318/DraggedImage-76.png)\n景色依然美不胜收啊……\n![](/images/318/DraggedImage-77.png)\n路上第一次出现了拉萨的标志，1608公里，我们还有很高很高的山要翻越，很长很长的坡要爬……\n![](/images/318/DraggedImage-78.png)\n也第一次遇到了川藏公路的长长军车队伍，老七算了一下大概150多辆，我就在想为什么现在交通手段这么成熟，不派几量飞机直接运送，却要让这些汽车兵，成群结对辛辛苦苦的走这川藏线，一个小插曲吧……\n![](/images/318/DraggedImage-79.png)\nG318的路牌，留一张。\n![](/images/318/DraggedImage-80.png)\n从此之后，里程碑就步入3开头了，再留一张。碑上写满了骑友想说的话，碑上写不下了就在旁边的栅栏上写……\n这个时候，相克宗也终于到了，今天的行程体力几乎拉爆了，明天迎接我们的将是川藏线以来最难的，最有挑战的一天……爬4600米的剪子弯山，再翻越卡子拉山，会在4200米的高海拔迎接几十公里的起伏路，并伴随野狗的触摸，自己到处的岗风，侧风，横风，想起来腿就软了，早点休息，早点出发吧，晚安。\n\n## Day 08  \n\n  \n相克宗村 - 剪子弯山 - 卡子拉山 - 红龙乡/雨，晴/79km/海拔4170m  \n\n被客栈老板称为最难最有挑战的一天，在清晨六点的闹钟中开始了，老大和老二估计是被老板吓到了，果断选择了搭车，14公里的爬坡到剪子弯隧道，途径天路十八弯。\n![](/images/318/DraggedImage-67.png)\n14公里的爬坡对于刚刚出发的体力来说，易如反掌，2个小时就爬到剪子弯隧道口\n![](/images/318/DraggedImage-68.png)  \n隧道长2.2公里，黑漆漆没有灯，必须结队通过，过了隧道就到剪子弯山的垭口，之后就是在4200以上的高原骑行几十公里的起伏路，云彩好像就在头顶贴着头皮一起飞。  \n![](/images/318/DraggedImage-69.png)\n十公里后，骤云突变，漂泊大雨呼啸而来，整整三十公里的奔袭，加上一句逆风和起伏路，手脚几乎僵硬，一路都是无人区，没有补给的地方，待冲到卡子拉山脚下的日里村时，遇到了藏族的一位大叔，招呼我去他家里喝茶，我就径直跟他爬上藏式的小楼，正好是午饭的时间，喝酥油茶，吃藏餐，烤火炉，不得不感叹这淳朴的民风。休息并等队友会合，一个小时后雨几乎停了，还是不见三位队友的影子，我便开始独自翻越卡子拉山。  \n![](/images/318/DraggedImage-70.png)  \n高原的骑行超级爽，第一次连续翻两座山，318醉人的景色，再也没有高反的症状，一路杀到红龙乡，超越了一路的骑友。  \n![](/images/318/DraggedImage-71.png)  \n码表破600公里了，1/4的旅程已过，越过这最艰难的一天，继续一路向西。\n那歌词怎么说的来，对，就这个feel倍儿爽……\n\n## Day 09\n  \n  \n红龙乡 - 理塘/晴/37km/海拔3960  \n![](/images/318/DraggedImage-64.png)  \n因为曾喜欢仓央嘉措的诗句，所以到了理塘就一定会想起他，理塘，一个高原小城，海拔四千多米，这座“选在高空的城市”自古以来就是茶马互市上的重镇，而理塘在藏语是“平坦如铜镜的草坝”的意思，县内还有广袤无垠的毛垭大草原。因此理塘也有“世界高城”的称号。\n所以说起理塘，就不得让人想起仓央嘉措的那首情诗：洁白的仙鹤啊，请把双翅借给我，不飞遥远的地方，只到理塘就回。\n这首诗，把仓央嘉措和理塘紧紧联系在了一起。也因此，有很多人会认为，理塘，是仓央嘉措的故乡。其实不然，仓央嘉措一生从未到过理塘，而这个地方确实他心灵深处最伤感的地名。因为理塘，是仓央嘉措爱人卓玛的故乡。  \n![](/images/318/DraggedImage-65.png)  \n放眼理塘，这座小城并不大，一条主街道走的再慢也不过个把时辰的光景。因为修路，街道略脏，但是你可以看到，天空很蓝，大朵大朵的白云凝固在这深蓝的天空中。树不多，但草原、山丘、河流，披着阳光，显得很干净很原生态。和梦中的境界一样。而这座城市中，轻而易举就能发现仓央嘉措的影子。路边有几家紧挨着的旅馆，名字大多借用了仓央嘉措的绝笔诗，大凡是仙鹤宾馆、白鹤旅馆等等。\n从红龙乡到理塘的旅程很短很短，所以就慢下来，静静地看着这里的天，缓缓的感受这里的风景。  \n![](/images/318/DraggedImage-66.png)  \n有很多想写理塘的话，可是当我真的到了这里，却不知从何写起……再找不到句子，就让情感流淌，理塘的天色有些黯淡了，独自坐在湖边，湖水泛着金光，从草原腹地浅浅的顺流而下……\n\n## Day 10 \n  \n理塘 - 禾尼乡/阵雨/58km/海拔4130  \n\n上午没有出发，看完了这个夏天最后一场比赛。  \n金州勇士输掉了完美赛季里的最重要的一场比赛，输掉了奥布莱恩杯，输掉了总冠军！  \n祝贺克利夫兰，2016最后的赢家，最好的球队不一定能走到最后，竞技体育，最合适的结局！  \n![](/images/318/DraggedImage-60.png)  \n球赛结束后，阵雨的陪伴下，出发前往禾尼乡。  \n队伍只剩下我和老五老七，其他已经赶到巴塘休整等我们汇合。  \n![](/images/318/DraggedImage-61.png)  \n三个人，三辆单车，继续在画中徜徉，笔直的318直插天际，美到让人喊出来，在喊声里告诉所有人这里的美！  \n![](/images/318/DraggedImage-62.png)  \n小溪，蓝天，白云，草原。开车太快，走路太慢，骑单车，刚刚好……\n![](/images/318/DraggedImage-63.png)\n\n## Day 11\n  \n  \n禾尼乡 - 巴塘/阵雨/120km/海拔2590m  \n  \n![](/images/318/DraggedImage-58.png)\n  \n当你骑着车子，伸出手臂，把手掌轻摊开来，和对面走来的藏民问好，击掌。相信我你会爱上这种感觉！\n从理塘到巴塘都是宽阔的草原，翱翔的雄鹰，低飞的燕雀，还有那远处的化作斑斑点点的牦牛。\n出发第11天，终于扎胎了，在刚刚出发的一小时后，就这么扎了！今天的路程是爬30公里的坡翻越海拔4685米的海子山，经90公里的长坡到巴塘。海拔下降将近两千米，并没有体验到传说中的醉氧。\n第一次经历生死川藏，下午2点还倚在所波大叔家门框道平安的骑友，4点钟就倒在了往海子山的路上，生命真的这么脆弱，一瞬间，天人永相隔……  \n兄弟愿你一路走好，若有来生再圆川藏梦！\n高原的天气多变，往往一天要淋好几场雨，往往都是出好几身臭汗……\n![](/images/318/DraggedImage-59.png)\n出发11天了，终于要出四川了，明天就过金沙江大桥入西藏界了\n\n## Day 12  \n\n  \n巴塘 - 金沙江大桥 - 温泉山庄/晴/47km/海拔2840  \n  \n![](/images/318/DraggedImage-57.png)\n  \n出四川了，终于出四川了！穿过金沙江大桥就是西藏界，桥中间横分川藏两界。\n上午十点出发去邮局买明信片，盖邮戳。说到明信片和邮戳，在理塘之前都没有想到，有点遗憾，以后到拉萨的途中，每到一座城都买吧！\n下午两点到达温泉山庄，老大已经在等候，老四独自一人翻越宗巴拉山到芒康去了，队伍如今只剩下五人，新的温泉山庄已经基本修建完毕，但还没有开始营业，以后的骑友可以体验享受了！\n\n## Day 13  \n\n  \n温泉山庄 - 宗巴拉山 - 芒康/晴/60km/海拔3920m  \n  \n![](/images/318/DraggedImage-55.png)\n  \n痛苦的一天，转弯之后一个接一个的爬坡，还是没有尽头的路，50公里的爬坡，其中将近10公里的烂路，海拔从2800上升到4150，今天，真够累！  \n![](/images/318/DraggedImage-56.png)  \n下午担心少数民族地区邮局五点下班，一路狂奔到邮局买明信片盖邮戳，芒康这个鬼地方全城都在修路。\n\n## Day 14\n  \n芒康 - 拉乌山 - 如美/晴/50km/海拔2670  \n\n出城过检查站的时候，才想起昨天在邮局盖邮戳取钱时把银行卡落在了ATM机被吞了，这次旅行只带了一张卡，叫了老七一起匆匆赶到邮局时，邮局工作人员都回家午休了，下午两点半才上班，需要等一个半小时，那就等吧，在门口待了十多分钟后走过来两个姑娘是邮局的工作人员，说三点半才上班，我就着急了，老五和老大已经先爬坡往如美去了，如果等到三点半天黑前还能不能赶到如美，给两位美女说明事情和为难后，美女给相关工作人员确认了银行卡确实在机器里，然后加了微信，说拿到卡片后帮我寄回北京，感动的我快哭了，这张卡对我有特殊的意义，使用多年，实在不舍得注销。  \n![](/images/318/DraggedImage-50.png)\n事情处理完毕，立即和老七追赶他们的脚步，芒康进城出城都要翻山，进城是宗巴拉山，出城是拉乌山，望着眼前没完的盘山路，就听见老七在我的后面叹息。  \n![](/images/318/DraggedImage-51.png)  \n公路的旁边就是悬崖，交警单位把报废的汽车时摆在路旁，时刻提醒着过往的路人，安全第一！老七说你拍这有啥意思，我说要拍，提醒自己，小心加小心，生命只有一次。\n![](/images/318/DraggedImage-52.png)  \n在拉乌山垭口遇到了三个骑滇藏线过来的骑友，这座山是他们目前爬过最高的海拔，聊到他们看到了梅里十三峰，真幸运，祝他们幸运。\n![](/images/318/DraggedImage-53.png)  \n从拉乌山垭口到如美是35公里的下坡，海拔从4370下降到2670，一路风景如画，路过3456的里程碑，留个纪念，上面同样涂满了来自五湖四海骑友想说的话。  \n![](/images/318/DraggedImage-54.png)\n如美小镇跨越澜沧江，到达时还不到五点，老大和老五又搭车了，从撞烂的汽车的地方就搭了，他们坐车到达一刻钟我和老七就到了，我本打算时间尚早再爬十公里山路到教授山庄为明日翻越觉巴山做准备，但是老大说腿软，那就住下吧！  \n顺便洗臭袜子，全汗味的衣服……\n\n## Day 15  \n\n  \n如美 - 觉巴山 - 容许兵站/晴/54km/海拔4020m\n![](/images/318/DraggedImage-45.png)  \n你是否站在过1300米的高处眺望过大地？是什么感觉？觉巴山被当地人称为绝望山，其实海拔并不是很高3911，但是足够征服一个人对山的所有理解。  \n![](/images/318/DraggedImage-46.png)  \n出如美到觉巴山垭口26公里的陡坡，海拔从2670上升到3911，九点出发，两点到垭口，5升水，半块压缩饼干，累到说不出话来，只能张开嗓子，干呕两声……  \n![](/images/318/DraggedImage-47.png)  \n当站在山顶回望来时的路，我是真的佩服自己，佩服这条线。老大在出发后十公里处终于坚持不住选择了搭车。  \n![](/images/318/DraggedImage-48.png)  \n早上出门时，后车轮刹车有点松，调了一下，待到山顶下坡时，发生了问题，后刹刹不住，幸好下坡直有十多公里，前刹还好，下到登巴村时老五和老大又搭车走了，还好有老七陪伴，我已经几乎竭力，还有13公里的爬坡到容许兵站，为明天东达山做准备。  \n![](/images/318/DraggedImage-49.png)  \n晚上休息的客栈老板车技超高，高中毕业后就一直玩户外，拿的奖状贴满了客栈餐厅的墙壁，菜做的一级水准，帮我调了刹车和变速，学了好几招调车的方法，等回北京我打算找家车店，周末休息时，去免费帮人调车多学点技能啊哈哈。\n\n## Day 16  \n\n  \n容许兵站 - 东达山 - 左贡/晴/62km/海拔3810m\n![](/images/318/DraggedImage-42.png)  \n东达山，川藏线两座5000米大山之一，难度在于高海拔，坡度平缓，26公里海拔上升1000米，  \n翻过东达山就表示行程已经过半，接下来到达拉萨只剩下四座大山。  \n![](/images/318/DraggedImage-43.png)  \n过东达到左贡，如果没有高反就是很轻松的行程，老七在半路高反严重，休息吃药后才继续出发，我最早到达垭口，在垭口等队友将近两个小时。行程太慢，15号出发的队伍都已经追上我们，买了10号拉萨到西宁的机票，川藏之行结束顺路去七月的青海湖，约了一圈好友，大家都没时间，那就我自己吧……  \n![](/images/318/DraggedImage-44.png)\n我只是从未如此想去一个地方。\n\n## Day 17\n  \n左贡 - 邦达/晴，雨/107km 海拔4130m  \n  \n![](/images/318/DraggedImage-41.png)\n西藏的天气是什么样的呢，一言不合就下雨，刚穿上雨衣雨就停，脱完了雨再下，折磨，折磨！\n今天没有山，100多公里的起伏路，川藏线骑习惯了，平路就当是下坡，一般的上坡就当是平路。\n累，就写这点吧…\n\n\n## Day 18  \n\n  \n邦达 - 业拉山 - 怒江72拐 - 八宿/晴/95km/海拔3250\n![](/images/318/DraggedImage-34.png)  \n再出发，三人行，老大又搭车！  \n![](/images/318/DraggedImage-35.png)  \n垭口回望来时的路，邦达小镇依稀可见。  \n![](/images/318/DraggedImage-36.png)  \n业拉山，海拔4658，已经变的没什么挑战。  \n![](/images/318/DraggedImage-37.png)  \n怒江天路72拐，巍峨壮观，身临其境，心惊胆寒！在这里摔车的朋友，一个接一个。老七也摔了，不过问题不大，我肯定不会，我下坡最慢了。  \n![](/images/318/DraggedImage-38.png)  \n再看一眼怒江，汹涌着，嘶吼着。天生脾气就不好！  \n![](/images/318/DraggedImage-39.png)  \n下了天路72拐，就是30公里的上坡到休息地，前14公里荒无人烟，早上没做准备带干粮，坚持到半路遇见一个能在水浒中才有的凉亭，一碗泡面下肚，立马就过岗，哈哈。  \n![](/images/318/DraggedImage-40.png)  \n14公里后，三人坐下每人来了一瓶啤酒，喝完我就腿软了，然后席地而睡休息了一个小时。\n半路遇到一个开车的大哥非要送我一瓶红牛，我拍拍胸脯告诉他我可以，出发至今带了一罐红牛一直没喝，放在驮包里，我只想靠坚持和毅力去翻越每一座山，每一段旅程。\n\n## Day 19  \n\n  \n八宿 - 安久拉山 - 然乌/晴/90km/海拔3850  \n![](/images/318/DraggedImage-29.png)  \n昨晚晚饭时听到几个来自山西晋城的大哥说今天的路程，68公里上坡到安久拉山垭口，22公里起伏路到然乌，他们说过了今天就好了，五星难度，以后的路只是时间问题。  \n![](/images/318/DraggedImage-30.png)  \n真正踏上今天的旅程，我们怀着忐忑的心，但是却是休闲骑，直到被一个个晚出发的队伍超越，下午遇到三个纯徒得驴友，互相鼓励，他们已记不起早上是从哪里出发。  \n![](/images/318/DraggedImage-31.png)  \n下午六点，我和老七终于爬到安久拉山垭口  \n![](/images/318/DraggedImage-32.png)  \n这时老大电话响起，已经定好然乌湖旁边的湖景房。  \n![](/images/318/DraggedImage-33.png)  \n傍晚的然乌湖，湖风煦煦，雪山倒映在湖中，我独自坐在湖边感受着这份难得的安静。\n\n## Day 20  \n\n  \n然乌 - 波密/雨/132km/海拔2700  \n![](/images/318/DraggedImage-24.png)  \n伴随着小雨，告别美丽的然乌湖，短暂的休整让我们再次出发！今天的行程是132公里的缓下坡和起伏路，海拔将从3850下降到2700，也将步入物产丰富林芝地区。  \n![](/images/318/DraggedImage-25.png)  \n进入林芝，以后的景色也都会变得郁郁葱葱～  \n![](/images/318/DraggedImage-26.png)  \n不起眼的4000里程碑，又被路过的骑友涂满了各种想说的话，这回没有了栅栏，拉萨越来越近，心情变得急促，我说拉萨不是目的，享受的是在路上……  \n![](/images/318/DraggedImage-27.png)  \n路遇生灵，我在4000公路碑拍照时就一直跟着我，前爪受伤严重，特别可怜！喂了一袋压缩饼干，它让我想起陪伴童年时光的那条小黑。希望它一切都好～  \n![](/images/318/DraggedImage-28.png)  \n今天的行程是132公里的冒雨穿越，什么防雨措施都成了摆设，十个小时的雨，浑身通透……\n波密是座美丽的小城，被称为藏王故里，冰川之乡，干净的街道，整齐的建筑，该是沿途看到最繁华最有特色的地方了，一天的雨中穿梭后，大家的衣服浸湿，队伍计划在此休整一天后再向通麦出发。\n\n\n## 七月，你好\n![](/images/318/DraggedImage-23.png)\n岁月如歌，弹唱着盛夏的炎热，六月走过，七月流火，送走了半年苍凉。\n七月，你好。你是一个半年的开始，你是一个半年的结束。我在时光里穿梭，忘却了日历的轮廓，那密密麻麻的数字，原来是错落排列的日出和日落。\n2015年6月，2000公里的呼伦贝尔穿越。  \n2016年6月，2000公里的川藏南线挑战。  \n......\n用车轮丈量大地，体会生命的意义，享受在路上的感觉。追寻倒映在水中的蓝天白云，攀在山顶望见绵延不绝的高山。平日的浮躁与忙碌，总是冲淡我们对美好事物的追求。\n我们都曾有梦想居住的地方。在依旧有炊烟的村庄，山水亮丽得如同梦里的笑容，每条小路清秀得像一句诗歌。白天浩瀚的蔚蓝、海边架起的小木屋、在阳光跳跃的草原，躺下，自己就是一片湖。\n千篇一律的生活中，需要一趟说走就走的旅行。“有些事现在不做，也许一辈子都不会做了”。一句简简单单的话，不知击中过多少颗青春不羁的心。只是任何时候，除了向往自由，战胜现实，我们必须知道的是：直面自己、找到通往内心的路。\n这一季，走过风花雪月，路过倾国倾城。下一季，故地重游，看尽云卷云舒，花开花落。\n\n## Day 21  \n\n波密 - 通麦 - 拉月村/阴/116km/海拔2320m  \n  \n![](/images/318/DraggedImage-17.png)  \n波密，就在波密，剩下的哥四个终于统一了发型，本来是约定拉萨一起剃光，提前执行了，我跟老大说，我18岁的时候打死都不会搞这个发型。而现在，从良了，只觉得舒服就好，反正怎么着也都没有女朋友……  \n![](/images/318/DraggedImage-18.png)  \n计划之外，在波密休整了两天，原计划休息一天，第二天出发通麦，晚上就下起了雨，早上醒来时仍然没有停的意思，询问大家都说下雨不出发就又果断睡去了。  \n![](/images/318/DraggedImage-19.png)  \n查看了未来几天的天气后，于是昨天晚上下定决心，今天下雹子也要走，因为已经提前买了十号拉萨飞西宁的机票，都是眼泪，我是下雨也打算出发的，但奈何队友都不走，一个人雨天路上太危险。\n今天计划的目的地是通麦，我曾在新浪的\\<胖哥试车\\>节目的西部穿越之旅里见识过传说中的通麦天险，从波密出发到通麦90公里的起伏路，海拔下降700米，40公里在修路，远超山西未实现村村通工程前的石头泥巴路，路上的骑友举着相机说，这才是318的味道，我路过，回一句，那就好好享受……\n想说的是队伍只剩下了我和老七，老大和老五在早上醒来后再次选择了搭车到八一，从波密到八一300多公里的路，也就意味着我和老七三天才能到。或许那个时候他们早就又坐车到拉萨了吧……  \n![](/images/318/DraggedImage-20.png)  \n刚刚建成的通麦大桥，看胖哥节目的时候还没有他，那时应该正在修建，胖哥在节目里说，等大桥通车，以后过通麦的朋友就幸福了，果然，我幸福了，但也意味着再见不到通麦天险和单边放行的通麦铁板桥。  \n![](/images/318/DraggedImage-21.png)  \n到通麦是刚刚下午四点，天色尚早，体力尚充沛，补充水后，我和老七商量下决定往前赶路到排龙乡后面的拉月村，这样如果努力一点的话，可以把三天的行程合并成两天，明天直接杀到八一。  \n![](/images/318/DraggedImage-22.png)  \n走在我前面的老七的背影，很感谢他，在所有人都放弃的时候，他没有放弃，陪着我从成都到现在，从未搭过车，做到了用车轮丈量大地的承诺，也因为有他，318对我来说，不显得那么孤单。\n\n## Day 22  \n  \n\n拉月村 - 鲁朗 - 八一/雨/114km/海拔3000\n![](/images/318/DraggedImage-14.png)  \n70公里的爬坡，海拔上升两千多米，第一次挑战在下午体力即将耗尽的时候翻山。太酸爽！这便是三天的路两天赶完的代价。  \n![](/images/318/DraggedImage-15.png)  \n在这条线的倒数第二座山，色季拉山的垭口，我给老大打电话，他正在往拉萨的车上，还剩30公里，真的只剩下了我和老七相依为命！\n出发时的七个人只剩下两个了，这个时候不用说什么坚持之类的云云，我和老七都知道，我们一定会骑完，百分之一的人能真正骑完川藏南线，我们即将做到。  \n![](/images/318/DraggedImage-16.png)  \n淋了一天的雨，晚上九点半才到林芝市（原八一镇），318目前为止最大的城市，我说这是大城市！浑身只剩两块银元，和老七满大街的找取款机，取钱吃过饭到住的地方已近11点。我什么都不想说，沿途的风景再美，也抵不住我想尽快到拉萨的心。\n\n## Day 23\n\n八一 - 工布江达/雨/132km/海拔3420\n![](/images/318/DraggedImage-10.png)\n不知道我和老七是对自己的体力逐渐有了自信还是，反正总是最晚出发，每天都是我催他起床。一觉睡到自然醒，吃饭，洗车，墨迹墨迹就中午。\n![](/images/318/DraggedImage-11.png)\n一路沿着尼洋河走，景色优美让人心情分外愉悦，下午三点在百巴镇吃午饭。路过k4321留念\n![](/images/318/DraggedImage-12.png)\n下午八点到达工布江达，路况较好，所以130公里难度对现在的身体已经够不成太大的挑战，只是中途被浇了好几场雨，鞋子湿了个通透，很酸爽。林芝地区的天气太善变……\n![](/images/318/DraggedImage-13.png)\n\n## Day 24\n\n工布江达 - 松多/晴/95km/海拔4200m\n![](/images/318/DraggedImage-6.png)  \n出发19公里处是中流砥柱景点，但是因为有人不幸掉水溺死，被蓝色的铁皮围了起来，我们只好爬到旁边的小山去拍一张没有字的一面。  \n![](/images/318/DraggedImage-7.png)  \n路书上说，这将是轻松的一天，本计划6 - 8个小时的行程没找到光下午就走了六个小时，全程在修路，漫天的沙子，什么都看不见，等到松多几乎不用吃饭了，沙子加土混合的菜几乎吃饱，嗓子想干呕，又吐不出来。  \n![](/images/318/DraggedImage-8.png)  \nk4444界碑已经没有了，在漫天的黄沙中拍了4445界碑，这一路上到处是豆豆的名字，也不知道豆豆是谁  \n![](/images/318/DraggedImage-9.png)  \n下午40公里这样的烂路，整整骑了11个小时，接下来到拉萨只剩下180公里，有很多队伍计划一天骑到，我想我还是两天吧，这烂路将持续到拉萨，一天180公里不敢想象。分两天走吧，不作就不会死！\n慢慢会开始对沿途的风景疲劳，会开始想东想西，从上学时的同学老师到工作后的同事朋友，一个一个想她们的模样，和一些过往，318让我又一次恍惚，分不清昨天今天明天，生活变的只有日出和日落，赶不完的路……\n\n## Day 25  \n\n松多 - 拉萨/晴/180km/海拔3650m  \n![](/images/318/DraggedImage.png)  \n大多数人在这一天是要赶到拉萨的，我和老七商量之下，决定把路分成两天走，所以该怎么睡就怎么睡，下楼吃饭时，所有的骑友都走了，只剩下我俩的车子停在哪里……\n从松多出发，28公里的爬坡翻越米拉山，5013米，318的最后一座山，也是最高的山，海拔上升700，难度不大。\n正在修建的米拉山隧道，以后来318的骑友可以少爬很多坡了，不知是悲伤还是欢喜  \n![](/images/318/DraggedImage-1.png)  \n12点爬到垭口，四个多小时  \n![](/images/318/DraggedImage-2.png)  \n在山顶和老七吃了两块小面包补充体力，一路的缓下坡冲到墨竹工卡刚刚下午五点  \n![](/images/318/DraggedImage-3.png)  \n墨竹工卡就是我们今天的计划休息地。但天色尚早，很多在我们后面的骑友都往拉萨走了，我也难掩兴奋之情，想一鼓作气冲到拉萨！那索性就继续出发……  \n![](/images/318/DraggedImage-4.png)  \nK4567的里程碑，合影留念，过了这就是平坦的柏油路直面拉萨。  \n![](/images/318/DraggedImage-5.png)  \n我在最后冲刺的九十公里，身体状态达到了最佳，四个小时就冲到了布达拉，一举超过很多前面的骑友，在冲刺的时候整个脑海在回响这一路爬的每一座山，口中念着每一天的行程。\n进城过拉萨桥的时候，不由地流泪了，是被自己感动，22天风雨兼程318，不推车，不搭车，不抛弃，不放弃。我做到了！","source":"_posts/journey_318.md","raw":"---\ntitle: 川藏南线(318)之旅\ndate: 2016-06-10 10:01:47\ntags: [Jurney]\ncategories: Jurney\n---\n\n\n## 写于川藏出发前\n\n![](/images/318/1255460395.jpg)\n\n> 有些事现在不做，永远都不会去做了。\n\n> 318国道，东起上海人民广场，西至中国与尼泊尔边界樟木口岸友谊桥，全长5476公里，是中国最长的国道。“那些伟大的景观不在318的两旁，就在道路南北不出200公里的范围内：钱塘江、西湖、太湖、黄山、庐山、鄱阳湖、洞庭湖、九华山、神农架、恩施、张家界、峨眉山……”而进入四川，318又被称为川藏公路，“贡嘎山、海螺沟、折多山、雅拉雪山、南迦巴瓦、加拉白垒，海拔8000米以上的马卡鲁峰、卓奥友峰、珠穆朗玛峰、希夏邦马峰……还有无数的雪山和冰川在这条大道的两旁。318国道从纵横中国大地的公路网中脱颖而出，成为了一条绵延万里的景观长廊。”2006年，318国道被《中国国家地理》评为“中国景观大道”（据百度百科和维基百科）\n\n我这次的目标，就是走318国道最为壮丽的一段，成都-拉萨，川藏线。\n为了这次旅行，从4月开始跑5km储备体能，于5月31日正式离职，收拾行囊。\n我一直相信，真正的美景始终在路上，旅行的奇妙体验在于不可预知，在于每天早晨会在不同的地方醒来。\n\n我热爱旅行，迷恋在路上的感觉，在之前的生命里，我一直以体验不同的生活为最大乐趣。\n\n塞内加曾说：何必为部分的生活而哭泣，君不见，全部的人生都让人潸然泪下。\n今天，就要踏上旅途，也许失败，也许艰难，也许幸福。\n但，无论怎样，我都已准备好去享受这一切，双手合十，愿一路平安。\n\n2016/06/06 成都\n\n## 成都小记\n\n这次的成都之行是一次难忘的经历，第一次住青旅的新鲜感，陌生人之间互相娴熟的聊天毫无晦涩感，喜欢这种体验。青旅的老板阿铭是我眼中的完美男人，微胖，短须，菜做的色香味，娴熟的琴技加上浑厚的嗓音，悠远的歌声中，让人容易想起旧事，他给旅舍起了个名字，比邻，天涯若比邻的寓意，邻家大哥的感觉，幽默十足。杀人游戏，露天烧烤，这里真的让我恍惚，像家的感觉。以后有机会，希望这个小栈还在，希望再次回到成都能再来这里看看。\n￼![](/images/318/507311534.png)\n三巷一号帮我调车的大哥，我没有机会问他的名字，也没选择他家的旅舍，我非常感谢他，萍水相逢，好人！\n￼![](/images/318/805238010.png)\n终于组到了队伍，七个人，因为担心一下子记不住那么多名字，我们按照年龄做了排序，我排老六，老大是甘肃人，带了队旗，写着brave heart 勇敢的心。\n老二是惠州人，长于深圳，广东仔，86年生。\n老三老四，来自南京，同89年生人，初步接触，老三低调，沉默寡言，曾当过武警，老四爱吹牛，爱说南京那些事儿，话痨，南吹，不算贬义词吧！\n老五是地地道道的四川广安人，四川话说得非常好听，92年的。\n我暂时对老七一无所知，他是最后一个加入我们队伍的，排老七是因为比还我小五个月，哈哈哈，没错终于有比我小的了，94年人。\n￼![](/images/318/2768809826.png)\n希望我们这支队伍能一起冲到最后，不抛弃，不放弃。一路平安。\n出发之前的凌晨，举着手机敲下这些憋足的文字。\n\n2016/06/10 成都\n\n## Day 01\n\n成都-雅安 /小雨转阴 /150km \n￼![](/images/318/IMG_0020.JPG)\n出发伴随着小雨，上午60公里的缓上坡，这段路基本没有什么风景，下午雨停了，90公里的起伏路，累到爆，虽然我心里非常清楚这仅仅是开始，但川藏线真名不虚传，感谢前人留下的路书和攻略，让我们自由前行。\n离开成都时，阿井说，川藏线上每一天都是挑战  \n。\n我的同伴有一个四川广安的小伙，他说真佩服那些能骑到拉萨的人，忍受这种折磨，真不是简单人，我一辈子都不会忘记这一天！我说我们也想成为像他们一样不简单的人，所以我们选择了折磨和痛苦来到了他们曾经走过的路，然后他说对，要做不平凡的事！\n老二说了一句非常经典的适合描述川藏线的话，让我非常感慨: 当你在穿山越岭的另一边，我在孤独的路上没有尽头。\n第一天强行军150公里，老二在骑到名山就给我们打电话派车去接他了，他身体不好可以理解，我也在心底默默的跟自己说，一定不搭车，一定不推车，万事开头难，不抛弃不放弃，加油！\n\n2016/06/10 雅安\n\n## Day 02\n\n雅安-新沟 /晴 / 90km \n![](/images/318/IMG_0046.JPG)\n经过昨晚的休息后，精神好了很多，PP也逐渐适应长时间的摩擦，早上7点起床收拾吃饭，队友要补充装备，上午在*雅安*成墨迹到9点才出发，太阳火辣辣的烤着就上路了，上午状态不错，中午11点多到达*天全*吃午饭，休整一小时后继续前行。\n\n下午有60公里的路程，谁也没想到一路的爬坡，离新沟还有10公里时体力几乎已经透支，路上遇到从名山单骑到新沟，最后3公里与我同行，一句鼓励我，激励我，很感谢他。我只是累到说一句话的力气都没有，安静，只有车轮滚滚向前，蹬踏，全世界都仿佛安静了……\n\n今天是正式从101国道切到318国道，时常会有人们从身旁划过，给你竖起大拇指，说加油！我也会回应大拇指，我理解这应该算是318的文化吧，路上遇到就会互相鼓励，互相帮助！\n\n走318让我对坚持有了重新的感悟，也对生命多了更深一层的认识，虽然我踏上这条传说中的路刚刚两天，我也知道有更多的故事个人等着我去遇见。\n\n![](/images/318/IMG_0039.JPG)\n￼ 2016/06/11 新沟\n\n## Day 03\n\n新沟-泸定 /晴 /57km\n￼![](/images/318/IMG_0058.JPG)\n因为今天的路程不是太多，相对第二天和第一天比较轻松一点，所以我们9点才离开新沟前往泸定，今天要爬的是川藏线第一座叫得上名字的山，先是20公里盘山公路环绕而上，让人欲仙欲死，不过我还是坚持了两不原则，不推车，不搭车，我比大部队晚出发十分钟，加上不擅长爬坡，所以也是最后到达二郎山隧道口，老二和老大在隧道口等着我，让我心里感动了一下下。\n￼![](/images/318/IMG_0078.JPG)\n穿过4公里的隧道，老大说饿了，我们就决定吃饭后再赶往泸定，饭后是30多公里的长坡，很爽，但是很危险，我一直让速度保持在30码以下，人年纪渐长就不敢那么冲动了，我是全队下坡最慢的，下午3点到达红色名城泸定，休整半天，洗脏衣服，出发三天来基本都是湿衣服，汗水不停的流淌，我估计按这样下去骑到拉萨，瘦个20斤不成问题。\n![](/images/318/IMG_0097.JPG)\n下午短暂的休息和洗漱之后，和队友一起去了小学课本中的泸定桥，据说下午6点之后才不收费，大渡河的滔滔江水，让人站在桥上会眩晕，仿佛看到历史伴随着这江水滚滚而去。\n￼ \n2016/06/12 泸定\n\n## Day 04\n\n泸定-康定 /多云 / 52km /海拔 2395m\n\n从北京到成都的那天晚上喉咙疼，第二天就咳嗽加浑身无力，到新沟时已经有所好转，到昨晚还是咳嗽到2点，早上六点就起床收拾出发了，20公里的起伏路，接着就是没完没了的爬坡，下午4点爬到康定红灯笼客栈，连给这座美丽的城市拍照的力气都没有了。\n\n老大今天也搭车了，半路被扎胎，正好给了他搭车的理由，哈哈，我是真的这么理解的，他确实爬不动了，大多数时候都是在推车，队伍中老三和老四打算骑到折多塘的，但老四下午六点才到康定，也是半路被扎胎，不过他还是坚持骑到了康定，给他点赞，他还是那么爱吹牛。\n\n我有些担心，晚上咳嗽很严重，早上起床也感觉有些轻微的感冒，明天海拔就超过3000了，真的不想离开队伍自己休息好养好再走，大家一起从成都出发，如果一起骑到拉萨该是多好的事情！\n\n希望高反不会太严重，耽误大家的时间，希望感冒咳嗽快点好，高原感冒有生命危险啊，今天早些吃药上床休息了，希望一切赶紧好起来。\n![](/images/318/IMG_0157.JPG)\n骑318到现在一直没有精力拍照，总是在赶路赶路……心好累，辜负了那么多美景！\n\n2016/06/13 康定红灯笼客栈\n\n## Day 05\n\n康定 - 折多塘村 /晴 /17km /海拔3300m\n\n康定是座美丽的小城，跑马山我小的时候就知道，据说康定的人都会唱情歌，一问之下竟然是真的。\n\n联系了大学同学，给她发了康定的位置和跑马山的照片，告诉她我经过她的家乡，特此问候，虽然她远在上海...故乡的位置和照片应该会让人感到亲切吧。\n\n图为清晨的青山环绕的康定新城，蓝天白云和远处的雪山，好想就在这住下去...\n￼![](/images/318/IMG_0170.JPG)\n昨晚咳嗽有所好转，休息的也不错，还是早上6点起床，客栈老板是藏族，早餐第一次喝酥油茶，味道还可以，微咸。\n￼![](/images/318/IMG_0184.JPG)\n\n从康定爬到折多塘村，17公里，海拔从2300上升到3300，大家决定就地休整半天，一为了适应高反，大家调整下，再也为了在折多山泡一下传说中的温泉，也是我第一次泡温泉。\n￼![](/images/318/IMG_0197.JPG)\n认识这是什么吗，我真的第一次见，叫日晕。\n￼![](/images/318/IMG_0200.JPG)\n七兄弟在藏民家的合影，房间分为汉室和藏室两种，藏室里面还放着一口棺材，把老三吓的不轻，我也胆小只好和老七一起睡了汉室。\n\n2017/06/14 折多塘村\n\n## Day 06\n\n折多塘 - 折多山 - 新都桥 /小雨，雪，阴 /58km /海拔3600\n\n晚上下了一夜的雨，很早就休息了，早上六点醒来，窗外的雨声还是没有停，老七拉开窗帘看了下，大雨。在群里询问了老大的意见，说继续休整，就继续睡去……\n\n![](/images/318/DraggedImage-81.png)\n\n再醒来就是九点了，看到老四发朋友圈独自上路了，后大家商议决定，老大，二，三，五搭车翻越折多山到新都桥等我和老七，吃过早饭，我和老七就出发了。\n十点出发，22公里，海拔上升到4298，“折多”在藏语中是弯曲的意思，写成汉语又是“折多”二字。被称为康巴第一关，折多山以西就是青藏高原的东部，真正的藏区。\n![](/images/318/DraggedImage-82.png)\n\n伴随着小雨，积雪的青山，我们以平均5码的龟速向着垭口爬行，出发一个小时后，老大他们的车就超越我们扬长而去……\n\n![](/images/318/DraggedImage-83.png)\n\n青山白云间穿行，路遇77岁的老大爷同样骑川藏线，一起合影，佩服的肝肠寸断，我想22岁的年纪再没有任何理由可以阻挡我去做完这件事了吧，就是这样！\n\n![](/images/318/DraggedImage-84.png)\n\n你看那飘扬的经幡，就说明垭口就要到了，折多山被我们征服了，虽然伴随着轻微的高反，心里这时是自豪的！\n只要在路上永远都是故事，到达垭口的时候在碑前拍照，竟然遇到了同县同镇的老乡，他们是组团出游包车从成都出发，我在让队友拍照时，身旁的阿姨用普通话问我，你们是骑车的吗，你们队伍中有没有山西人呀，我说有啊，我就是山西人，接着我问她你山西的吗？山西那里的，她又说我长治的，我就用长治话跟他说我也长治的，然后她说你真的是长治的天呐，对啊，我用壶关话说我是壶关滴，然后她就更震惊的表情看着我我用壶关话说她也是壶关的，哈哈哈哈，世界原来这么小，还遇到了同镇的，于是我又切换到了标准的树掌话，哈哈，都被详细追问到了你爹在那个单位工作看看是不是认识，阿姨和大叔们问我要往哪里去，我说到拉萨，他们说你一定要注意安全啊，嘿嘿，阿姨小跑去车上取下一大包家乡的琪炒，说这个治水土不服，饿了也管饱，你带上，有谁没车上有我去给你拿，实在是推不开，都说近乡情更怯，但我真觉得离乡千万里，乡音更让情更怯，合照，依依分别，大叔还在原处感叹着乡音呐！乡音呐！\n背井离乡多年，漂泊于外面的世界，会让人变得冷漠，是他们的热情感染了我，重拾原来家乡的人可以这么亲切...\n![](/images/318/DraggedImage-85.png)\n康巴第一关，以后的路就是藏区了，出行时的七个人仍然不离不弃，新都桥被称为摄影家家的天堂，到处都是美景，微单依然躺在驮包里，我却没有一点想法去拍点什么……\n![](/images/318/DraggedImage-86.png)\n入住了新都桥桐花里客栈，老板说话让人听起来非常愉快，山东汉子，青岛人，我还给他简单的来了几句青岛话，告诉他我曾经在潍坊上大学，有很多青岛的同学朋友，老板旅行过全国所有的地方，最后留在了这里，开一间小客栈，我们没有过多的交流，但从老大口里听的出这是个有故事的男人。\n![](/images/318/DraggedImage-87.png)\n晚饭的时候看到老大发的朋友圈，是这样的:\n![](/images/318/DraggedImage-88.png)  \n78年的七尺汉子，当着我的面，真的流泪了，我看到他红了眼眶，就把头转了过去，我不喜欢这样，虽然都是性情中人，老大说当他坐着车从我和老七身边划过时，就哭了，真的后悔了。老五接着说，他那时把眼睛望向了窗外，让泪水在里面转几圈，记住放弃的味道……然后骑下去。\n我理解他们，所有人都放弃的时候我会感觉到孤独，但选择了走318我就一定不能让自己后悔，不尝试，不尽力就放弃的后悔。\n\n## Day 07  \n\n新都桥 - 高尔寺山 - 雅江 - 相克宗村 /晴 /92km /海拔3600\n\n今天从七兄弟变成了六个，老三走了，回了南京，我们也不好追问具体详细，昨晚小喝了一杯送别酒，希望老三一路顺风，晚上到达相克宗时听说他已回到了成都。\n8点钟出发爬坡20多公里到高尔寺隧道，老二在半路高反比较严重，我们在隧道口等了一个多小时，隧道将近6公里长，因为正在修建，其中四公里没有灯，所以必须结伴前行。\n![](/images/318/DraggedImage-72.png)\n爬山途中遇到昨天在折多山的77岁老大爷的同伴，也是70岁高龄，身体非常硬朗，重庆人，两人结伴骑过五次长途，曾环过山东半岛，其他的我给忘记了，我问他川藏线是不是他骑过最难最有挑战的，他毫不犹豫的告诉我，是的，在高原攀山越岭，太有挑战了。\n![](/images/318/DraggedImage-73.png)\n半年之前骑行的骑友就没有这种享受了，他们要翻越4659m的高尔寺山，如果折多山被称为康巴第一关，那么高尔寺就是第二关，以前让骑行队伍分开的最多的一座山，挑战和痛苦可想而知……\n从隧道通过后就是40公里的大长坡到雅江，一路的美景，让人心碎的美景，北京从没有过的蓝天白云，就像许少歌里唱的一样：只有青山藏在白云间，蝴蝶自由穿行在清涧。当然没看到蝴蝶，领悟精神，领悟精神！\n\n![](/images/318/DraggedImage-74.png)\n一路的长下坡伴随着大回环，我又是队伍中下坡速度控制的最慢的，下午两点钟我们到达了雅江，休息吃午饭，补充水。\n![](/images/318/DraggedImage-75.png)\n今天的目的地是相克宗村，还有20多公里的陡坡要爬，海拔会重新上升1000多米，所以这一天真正的挑战才刚刚开始，短暂的休息过后，3点钟继续顶着烈日，迎着横风出发了……\n![](/images/318/DraggedImage-76.png)\n景色依然美不胜收啊……\n![](/images/318/DraggedImage-77.png)\n路上第一次出现了拉萨的标志，1608公里，我们还有很高很高的山要翻越，很长很长的坡要爬……\n![](/images/318/DraggedImage-78.png)\n也第一次遇到了川藏公路的长长军车队伍，老七算了一下大概150多辆，我就在想为什么现在交通手段这么成熟，不派几量飞机直接运送，却要让这些汽车兵，成群结对辛辛苦苦的走这川藏线，一个小插曲吧……\n![](/images/318/DraggedImage-79.png)\nG318的路牌，留一张。\n![](/images/318/DraggedImage-80.png)\n从此之后，里程碑就步入3开头了，再留一张。碑上写满了骑友想说的话，碑上写不下了就在旁边的栅栏上写……\n这个时候，相克宗也终于到了，今天的行程体力几乎拉爆了，明天迎接我们的将是川藏线以来最难的，最有挑战的一天……爬4600米的剪子弯山，再翻越卡子拉山，会在4200米的高海拔迎接几十公里的起伏路，并伴随野狗的触摸，自己到处的岗风，侧风，横风，想起来腿就软了，早点休息，早点出发吧，晚安。\n\n## Day 08  \n\n  \n相克宗村 - 剪子弯山 - 卡子拉山 - 红龙乡/雨，晴/79km/海拔4170m  \n\n被客栈老板称为最难最有挑战的一天，在清晨六点的闹钟中开始了，老大和老二估计是被老板吓到了，果断选择了搭车，14公里的爬坡到剪子弯隧道，途径天路十八弯。\n![](/images/318/DraggedImage-67.png)\n14公里的爬坡对于刚刚出发的体力来说，易如反掌，2个小时就爬到剪子弯隧道口\n![](/images/318/DraggedImage-68.png)  \n隧道长2.2公里，黑漆漆没有灯，必须结队通过，过了隧道就到剪子弯山的垭口，之后就是在4200以上的高原骑行几十公里的起伏路，云彩好像就在头顶贴着头皮一起飞。  \n![](/images/318/DraggedImage-69.png)\n十公里后，骤云突变，漂泊大雨呼啸而来，整整三十公里的奔袭，加上一句逆风和起伏路，手脚几乎僵硬，一路都是无人区，没有补给的地方，待冲到卡子拉山脚下的日里村时，遇到了藏族的一位大叔，招呼我去他家里喝茶，我就径直跟他爬上藏式的小楼，正好是午饭的时间，喝酥油茶，吃藏餐，烤火炉，不得不感叹这淳朴的民风。休息并等队友会合，一个小时后雨几乎停了，还是不见三位队友的影子，我便开始独自翻越卡子拉山。  \n![](/images/318/DraggedImage-70.png)  \n高原的骑行超级爽，第一次连续翻两座山，318醉人的景色，再也没有高反的症状，一路杀到红龙乡，超越了一路的骑友。  \n![](/images/318/DraggedImage-71.png)  \n码表破600公里了，1/4的旅程已过，越过这最艰难的一天，继续一路向西。\n那歌词怎么说的来，对，就这个feel倍儿爽……\n\n## Day 09\n  \n  \n红龙乡 - 理塘/晴/37km/海拔3960  \n![](/images/318/DraggedImage-64.png)  \n因为曾喜欢仓央嘉措的诗句，所以到了理塘就一定会想起他，理塘，一个高原小城，海拔四千多米，这座“选在高空的城市”自古以来就是茶马互市上的重镇，而理塘在藏语是“平坦如铜镜的草坝”的意思，县内还有广袤无垠的毛垭大草原。因此理塘也有“世界高城”的称号。\n所以说起理塘，就不得让人想起仓央嘉措的那首情诗：洁白的仙鹤啊，请把双翅借给我，不飞遥远的地方，只到理塘就回。\n这首诗，把仓央嘉措和理塘紧紧联系在了一起。也因此，有很多人会认为，理塘，是仓央嘉措的故乡。其实不然，仓央嘉措一生从未到过理塘，而这个地方确实他心灵深处最伤感的地名。因为理塘，是仓央嘉措爱人卓玛的故乡。  \n![](/images/318/DraggedImage-65.png)  \n放眼理塘，这座小城并不大，一条主街道走的再慢也不过个把时辰的光景。因为修路，街道略脏，但是你可以看到，天空很蓝，大朵大朵的白云凝固在这深蓝的天空中。树不多，但草原、山丘、河流，披着阳光，显得很干净很原生态。和梦中的境界一样。而这座城市中，轻而易举就能发现仓央嘉措的影子。路边有几家紧挨着的旅馆，名字大多借用了仓央嘉措的绝笔诗，大凡是仙鹤宾馆、白鹤旅馆等等。\n从红龙乡到理塘的旅程很短很短，所以就慢下来，静静地看着这里的天，缓缓的感受这里的风景。  \n![](/images/318/DraggedImage-66.png)  \n有很多想写理塘的话，可是当我真的到了这里，却不知从何写起……再找不到句子，就让情感流淌，理塘的天色有些黯淡了，独自坐在湖边，湖水泛着金光，从草原腹地浅浅的顺流而下……\n\n## Day 10 \n  \n理塘 - 禾尼乡/阵雨/58km/海拔4130  \n\n上午没有出发，看完了这个夏天最后一场比赛。  \n金州勇士输掉了完美赛季里的最重要的一场比赛，输掉了奥布莱恩杯，输掉了总冠军！  \n祝贺克利夫兰，2016最后的赢家，最好的球队不一定能走到最后，竞技体育，最合适的结局！  \n![](/images/318/DraggedImage-60.png)  \n球赛结束后，阵雨的陪伴下，出发前往禾尼乡。  \n队伍只剩下我和老五老七，其他已经赶到巴塘休整等我们汇合。  \n![](/images/318/DraggedImage-61.png)  \n三个人，三辆单车，继续在画中徜徉，笔直的318直插天际，美到让人喊出来，在喊声里告诉所有人这里的美！  \n![](/images/318/DraggedImage-62.png)  \n小溪，蓝天，白云，草原。开车太快，走路太慢，骑单车，刚刚好……\n![](/images/318/DraggedImage-63.png)\n\n## Day 11\n  \n  \n禾尼乡 - 巴塘/阵雨/120km/海拔2590m  \n  \n![](/images/318/DraggedImage-58.png)\n  \n当你骑着车子，伸出手臂，把手掌轻摊开来，和对面走来的藏民问好，击掌。相信我你会爱上这种感觉！\n从理塘到巴塘都是宽阔的草原，翱翔的雄鹰，低飞的燕雀，还有那远处的化作斑斑点点的牦牛。\n出发第11天，终于扎胎了，在刚刚出发的一小时后，就这么扎了！今天的路程是爬30公里的坡翻越海拔4685米的海子山，经90公里的长坡到巴塘。海拔下降将近两千米，并没有体验到传说中的醉氧。\n第一次经历生死川藏，下午2点还倚在所波大叔家门框道平安的骑友，4点钟就倒在了往海子山的路上，生命真的这么脆弱，一瞬间，天人永相隔……  \n兄弟愿你一路走好，若有来生再圆川藏梦！\n高原的天气多变，往往一天要淋好几场雨，往往都是出好几身臭汗……\n![](/images/318/DraggedImage-59.png)\n出发11天了，终于要出四川了，明天就过金沙江大桥入西藏界了\n\n## Day 12  \n\n  \n巴塘 - 金沙江大桥 - 温泉山庄/晴/47km/海拔2840  \n  \n![](/images/318/DraggedImage-57.png)\n  \n出四川了，终于出四川了！穿过金沙江大桥就是西藏界，桥中间横分川藏两界。\n上午十点出发去邮局买明信片，盖邮戳。说到明信片和邮戳，在理塘之前都没有想到，有点遗憾，以后到拉萨的途中，每到一座城都买吧！\n下午两点到达温泉山庄，老大已经在等候，老四独自一人翻越宗巴拉山到芒康去了，队伍如今只剩下五人，新的温泉山庄已经基本修建完毕，但还没有开始营业，以后的骑友可以体验享受了！\n\n## Day 13  \n\n  \n温泉山庄 - 宗巴拉山 - 芒康/晴/60km/海拔3920m  \n  \n![](/images/318/DraggedImage-55.png)\n  \n痛苦的一天，转弯之后一个接一个的爬坡，还是没有尽头的路，50公里的爬坡，其中将近10公里的烂路，海拔从2800上升到4150，今天，真够累！  \n![](/images/318/DraggedImage-56.png)  \n下午担心少数民族地区邮局五点下班，一路狂奔到邮局买明信片盖邮戳，芒康这个鬼地方全城都在修路。\n\n## Day 14\n  \n芒康 - 拉乌山 - 如美/晴/50km/海拔2670  \n\n出城过检查站的时候，才想起昨天在邮局盖邮戳取钱时把银行卡落在了ATM机被吞了，这次旅行只带了一张卡，叫了老七一起匆匆赶到邮局时，邮局工作人员都回家午休了，下午两点半才上班，需要等一个半小时，那就等吧，在门口待了十多分钟后走过来两个姑娘是邮局的工作人员，说三点半才上班，我就着急了，老五和老大已经先爬坡往如美去了，如果等到三点半天黑前还能不能赶到如美，给两位美女说明事情和为难后，美女给相关工作人员确认了银行卡确实在机器里，然后加了微信，说拿到卡片后帮我寄回北京，感动的我快哭了，这张卡对我有特殊的意义，使用多年，实在不舍得注销。  \n![](/images/318/DraggedImage-50.png)\n事情处理完毕，立即和老七追赶他们的脚步，芒康进城出城都要翻山，进城是宗巴拉山，出城是拉乌山，望着眼前没完的盘山路，就听见老七在我的后面叹息。  \n![](/images/318/DraggedImage-51.png)  \n公路的旁边就是悬崖，交警单位把报废的汽车时摆在路旁，时刻提醒着过往的路人，安全第一！老七说你拍这有啥意思，我说要拍，提醒自己，小心加小心，生命只有一次。\n![](/images/318/DraggedImage-52.png)  \n在拉乌山垭口遇到了三个骑滇藏线过来的骑友，这座山是他们目前爬过最高的海拔，聊到他们看到了梅里十三峰，真幸运，祝他们幸运。\n![](/images/318/DraggedImage-53.png)  \n从拉乌山垭口到如美是35公里的下坡，海拔从4370下降到2670，一路风景如画，路过3456的里程碑，留个纪念，上面同样涂满了来自五湖四海骑友想说的话。  \n![](/images/318/DraggedImage-54.png)\n如美小镇跨越澜沧江，到达时还不到五点，老大和老五又搭车了，从撞烂的汽车的地方就搭了，他们坐车到达一刻钟我和老七就到了，我本打算时间尚早再爬十公里山路到教授山庄为明日翻越觉巴山做准备，但是老大说腿软，那就住下吧！  \n顺便洗臭袜子，全汗味的衣服……\n\n## Day 15  \n\n  \n如美 - 觉巴山 - 容许兵站/晴/54km/海拔4020m\n![](/images/318/DraggedImage-45.png)  \n你是否站在过1300米的高处眺望过大地？是什么感觉？觉巴山被当地人称为绝望山，其实海拔并不是很高3911，但是足够征服一个人对山的所有理解。  \n![](/images/318/DraggedImage-46.png)  \n出如美到觉巴山垭口26公里的陡坡，海拔从2670上升到3911，九点出发，两点到垭口，5升水，半块压缩饼干，累到说不出话来，只能张开嗓子，干呕两声……  \n![](/images/318/DraggedImage-47.png)  \n当站在山顶回望来时的路，我是真的佩服自己，佩服这条线。老大在出发后十公里处终于坚持不住选择了搭车。  \n![](/images/318/DraggedImage-48.png)  \n早上出门时，后车轮刹车有点松，调了一下，待到山顶下坡时，发生了问题，后刹刹不住，幸好下坡直有十多公里，前刹还好，下到登巴村时老五和老大又搭车走了，还好有老七陪伴，我已经几乎竭力，还有13公里的爬坡到容许兵站，为明天东达山做准备。  \n![](/images/318/DraggedImage-49.png)  \n晚上休息的客栈老板车技超高，高中毕业后就一直玩户外，拿的奖状贴满了客栈餐厅的墙壁，菜做的一级水准，帮我调了刹车和变速，学了好几招调车的方法，等回北京我打算找家车店，周末休息时，去免费帮人调车多学点技能啊哈哈。\n\n## Day 16  \n\n  \n容许兵站 - 东达山 - 左贡/晴/62km/海拔3810m\n![](/images/318/DraggedImage-42.png)  \n东达山，川藏线两座5000米大山之一，难度在于高海拔，坡度平缓，26公里海拔上升1000米，  \n翻过东达山就表示行程已经过半，接下来到达拉萨只剩下四座大山。  \n![](/images/318/DraggedImage-43.png)  \n过东达到左贡，如果没有高反就是很轻松的行程，老七在半路高反严重，休息吃药后才继续出发，我最早到达垭口，在垭口等队友将近两个小时。行程太慢，15号出发的队伍都已经追上我们，买了10号拉萨到西宁的机票，川藏之行结束顺路去七月的青海湖，约了一圈好友，大家都没时间，那就我自己吧……  \n![](/images/318/DraggedImage-44.png)\n我只是从未如此想去一个地方。\n\n## Day 17\n  \n左贡 - 邦达/晴，雨/107km 海拔4130m  \n  \n![](/images/318/DraggedImage-41.png)\n西藏的天气是什么样的呢，一言不合就下雨，刚穿上雨衣雨就停，脱完了雨再下，折磨，折磨！\n今天没有山，100多公里的起伏路，川藏线骑习惯了，平路就当是下坡，一般的上坡就当是平路。\n累，就写这点吧…\n\n\n## Day 18  \n\n  \n邦达 - 业拉山 - 怒江72拐 - 八宿/晴/95km/海拔3250\n![](/images/318/DraggedImage-34.png)  \n再出发，三人行，老大又搭车！  \n![](/images/318/DraggedImage-35.png)  \n垭口回望来时的路，邦达小镇依稀可见。  \n![](/images/318/DraggedImage-36.png)  \n业拉山，海拔4658，已经变的没什么挑战。  \n![](/images/318/DraggedImage-37.png)  \n怒江天路72拐，巍峨壮观，身临其境，心惊胆寒！在这里摔车的朋友，一个接一个。老七也摔了，不过问题不大，我肯定不会，我下坡最慢了。  \n![](/images/318/DraggedImage-38.png)  \n再看一眼怒江，汹涌着，嘶吼着。天生脾气就不好！  \n![](/images/318/DraggedImage-39.png)  \n下了天路72拐，就是30公里的上坡到休息地，前14公里荒无人烟，早上没做准备带干粮，坚持到半路遇见一个能在水浒中才有的凉亭，一碗泡面下肚，立马就过岗，哈哈。  \n![](/images/318/DraggedImage-40.png)  \n14公里后，三人坐下每人来了一瓶啤酒，喝完我就腿软了，然后席地而睡休息了一个小时。\n半路遇到一个开车的大哥非要送我一瓶红牛，我拍拍胸脯告诉他我可以，出发至今带了一罐红牛一直没喝，放在驮包里，我只想靠坚持和毅力去翻越每一座山，每一段旅程。\n\n## Day 19  \n\n  \n八宿 - 安久拉山 - 然乌/晴/90km/海拔3850  \n![](/images/318/DraggedImage-29.png)  \n昨晚晚饭时听到几个来自山西晋城的大哥说今天的路程，68公里上坡到安久拉山垭口，22公里起伏路到然乌，他们说过了今天就好了，五星难度，以后的路只是时间问题。  \n![](/images/318/DraggedImage-30.png)  \n真正踏上今天的旅程，我们怀着忐忑的心，但是却是休闲骑，直到被一个个晚出发的队伍超越，下午遇到三个纯徒得驴友，互相鼓励，他们已记不起早上是从哪里出发。  \n![](/images/318/DraggedImage-31.png)  \n下午六点，我和老七终于爬到安久拉山垭口  \n![](/images/318/DraggedImage-32.png)  \n这时老大电话响起，已经定好然乌湖旁边的湖景房。  \n![](/images/318/DraggedImage-33.png)  \n傍晚的然乌湖，湖风煦煦，雪山倒映在湖中，我独自坐在湖边感受着这份难得的安静。\n\n## Day 20  \n\n  \n然乌 - 波密/雨/132km/海拔2700  \n![](/images/318/DraggedImage-24.png)  \n伴随着小雨，告别美丽的然乌湖，短暂的休整让我们再次出发！今天的行程是132公里的缓下坡和起伏路，海拔将从3850下降到2700，也将步入物产丰富林芝地区。  \n![](/images/318/DraggedImage-25.png)  \n进入林芝，以后的景色也都会变得郁郁葱葱～  \n![](/images/318/DraggedImage-26.png)  \n不起眼的4000里程碑，又被路过的骑友涂满了各种想说的话，这回没有了栅栏，拉萨越来越近，心情变得急促，我说拉萨不是目的，享受的是在路上……  \n![](/images/318/DraggedImage-27.png)  \n路遇生灵，我在4000公路碑拍照时就一直跟着我，前爪受伤严重，特别可怜！喂了一袋压缩饼干，它让我想起陪伴童年时光的那条小黑。希望它一切都好～  \n![](/images/318/DraggedImage-28.png)  \n今天的行程是132公里的冒雨穿越，什么防雨措施都成了摆设，十个小时的雨，浑身通透……\n波密是座美丽的小城，被称为藏王故里，冰川之乡，干净的街道，整齐的建筑，该是沿途看到最繁华最有特色的地方了，一天的雨中穿梭后，大家的衣服浸湿，队伍计划在此休整一天后再向通麦出发。\n\n\n## 七月，你好\n![](/images/318/DraggedImage-23.png)\n岁月如歌，弹唱着盛夏的炎热，六月走过，七月流火，送走了半年苍凉。\n七月，你好。你是一个半年的开始，你是一个半年的结束。我在时光里穿梭，忘却了日历的轮廓，那密密麻麻的数字，原来是错落排列的日出和日落。\n2015年6月，2000公里的呼伦贝尔穿越。  \n2016年6月，2000公里的川藏南线挑战。  \n......\n用车轮丈量大地，体会生命的意义，享受在路上的感觉。追寻倒映在水中的蓝天白云，攀在山顶望见绵延不绝的高山。平日的浮躁与忙碌，总是冲淡我们对美好事物的追求。\n我们都曾有梦想居住的地方。在依旧有炊烟的村庄，山水亮丽得如同梦里的笑容，每条小路清秀得像一句诗歌。白天浩瀚的蔚蓝、海边架起的小木屋、在阳光跳跃的草原，躺下，自己就是一片湖。\n千篇一律的生活中，需要一趟说走就走的旅行。“有些事现在不做，也许一辈子都不会做了”。一句简简单单的话，不知击中过多少颗青春不羁的心。只是任何时候，除了向往自由，战胜现实，我们必须知道的是：直面自己、找到通往内心的路。\n这一季，走过风花雪月，路过倾国倾城。下一季，故地重游，看尽云卷云舒，花开花落。\n\n## Day 21  \n\n波密 - 通麦 - 拉月村/阴/116km/海拔2320m  \n  \n![](/images/318/DraggedImage-17.png)  \n波密，就在波密，剩下的哥四个终于统一了发型，本来是约定拉萨一起剃光，提前执行了，我跟老大说，我18岁的时候打死都不会搞这个发型。而现在，从良了，只觉得舒服就好，反正怎么着也都没有女朋友……  \n![](/images/318/DraggedImage-18.png)  \n计划之外，在波密休整了两天，原计划休息一天，第二天出发通麦，晚上就下起了雨，早上醒来时仍然没有停的意思，询问大家都说下雨不出发就又果断睡去了。  \n![](/images/318/DraggedImage-19.png)  \n查看了未来几天的天气后，于是昨天晚上下定决心，今天下雹子也要走，因为已经提前买了十号拉萨飞西宁的机票，都是眼泪，我是下雨也打算出发的，但奈何队友都不走，一个人雨天路上太危险。\n今天计划的目的地是通麦，我曾在新浪的\\<胖哥试车\\>节目的西部穿越之旅里见识过传说中的通麦天险，从波密出发到通麦90公里的起伏路，海拔下降700米，40公里在修路，远超山西未实现村村通工程前的石头泥巴路，路上的骑友举着相机说，这才是318的味道，我路过，回一句，那就好好享受……\n想说的是队伍只剩下了我和老七，老大和老五在早上醒来后再次选择了搭车到八一，从波密到八一300多公里的路，也就意味着我和老七三天才能到。或许那个时候他们早就又坐车到拉萨了吧……  \n![](/images/318/DraggedImage-20.png)  \n刚刚建成的通麦大桥，看胖哥节目的时候还没有他，那时应该正在修建，胖哥在节目里说，等大桥通车，以后过通麦的朋友就幸福了，果然，我幸福了，但也意味着再见不到通麦天险和单边放行的通麦铁板桥。  \n![](/images/318/DraggedImage-21.png)  \n到通麦是刚刚下午四点，天色尚早，体力尚充沛，补充水后，我和老七商量下决定往前赶路到排龙乡后面的拉月村，这样如果努力一点的话，可以把三天的行程合并成两天，明天直接杀到八一。  \n![](/images/318/DraggedImage-22.png)  \n走在我前面的老七的背影，很感谢他，在所有人都放弃的时候，他没有放弃，陪着我从成都到现在，从未搭过车，做到了用车轮丈量大地的承诺，也因为有他，318对我来说，不显得那么孤单。\n\n## Day 22  \n  \n\n拉月村 - 鲁朗 - 八一/雨/114km/海拔3000\n![](/images/318/DraggedImage-14.png)  \n70公里的爬坡，海拔上升两千多米，第一次挑战在下午体力即将耗尽的时候翻山。太酸爽！这便是三天的路两天赶完的代价。  \n![](/images/318/DraggedImage-15.png)  \n在这条线的倒数第二座山，色季拉山的垭口，我给老大打电话，他正在往拉萨的车上，还剩30公里，真的只剩下了我和老七相依为命！\n出发时的七个人只剩下两个了，这个时候不用说什么坚持之类的云云，我和老七都知道，我们一定会骑完，百分之一的人能真正骑完川藏南线，我们即将做到。  \n![](/images/318/DraggedImage-16.png)  \n淋了一天的雨，晚上九点半才到林芝市（原八一镇），318目前为止最大的城市，我说这是大城市！浑身只剩两块银元，和老七满大街的找取款机，取钱吃过饭到住的地方已近11点。我什么都不想说，沿途的风景再美，也抵不住我想尽快到拉萨的心。\n\n## Day 23\n\n八一 - 工布江达/雨/132km/海拔3420\n![](/images/318/DraggedImage-10.png)\n不知道我和老七是对自己的体力逐渐有了自信还是，反正总是最晚出发，每天都是我催他起床。一觉睡到自然醒，吃饭，洗车，墨迹墨迹就中午。\n![](/images/318/DraggedImage-11.png)\n一路沿着尼洋河走，景色优美让人心情分外愉悦，下午三点在百巴镇吃午饭。路过k4321留念\n![](/images/318/DraggedImage-12.png)\n下午八点到达工布江达，路况较好，所以130公里难度对现在的身体已经够不成太大的挑战，只是中途被浇了好几场雨，鞋子湿了个通透，很酸爽。林芝地区的天气太善变……\n![](/images/318/DraggedImage-13.png)\n\n## Day 24\n\n工布江达 - 松多/晴/95km/海拔4200m\n![](/images/318/DraggedImage-6.png)  \n出发19公里处是中流砥柱景点，但是因为有人不幸掉水溺死，被蓝色的铁皮围了起来，我们只好爬到旁边的小山去拍一张没有字的一面。  \n![](/images/318/DraggedImage-7.png)  \n路书上说，这将是轻松的一天，本计划6 - 8个小时的行程没找到光下午就走了六个小时，全程在修路，漫天的沙子，什么都看不见，等到松多几乎不用吃饭了，沙子加土混合的菜几乎吃饱，嗓子想干呕，又吐不出来。  \n![](/images/318/DraggedImage-8.png)  \nk4444界碑已经没有了，在漫天的黄沙中拍了4445界碑，这一路上到处是豆豆的名字，也不知道豆豆是谁  \n![](/images/318/DraggedImage-9.png)  \n下午40公里这样的烂路，整整骑了11个小时，接下来到拉萨只剩下180公里，有很多队伍计划一天骑到，我想我还是两天吧，这烂路将持续到拉萨，一天180公里不敢想象。分两天走吧，不作就不会死！\n慢慢会开始对沿途的风景疲劳，会开始想东想西，从上学时的同学老师到工作后的同事朋友，一个一个想她们的模样，和一些过往，318让我又一次恍惚，分不清昨天今天明天，生活变的只有日出和日落，赶不完的路……\n\n## Day 25  \n\n松多 - 拉萨/晴/180km/海拔3650m  \n![](/images/318/DraggedImage.png)  \n大多数人在这一天是要赶到拉萨的，我和老七商量之下，决定把路分成两天走，所以该怎么睡就怎么睡，下楼吃饭时，所有的骑友都走了，只剩下我俩的车子停在哪里……\n从松多出发，28公里的爬坡翻越米拉山，5013米，318的最后一座山，也是最高的山，海拔上升700，难度不大。\n正在修建的米拉山隧道，以后来318的骑友可以少爬很多坡了，不知是悲伤还是欢喜  \n![](/images/318/DraggedImage-1.png)  \n12点爬到垭口，四个多小时  \n![](/images/318/DraggedImage-2.png)  \n在山顶和老七吃了两块小面包补充体力，一路的缓下坡冲到墨竹工卡刚刚下午五点  \n![](/images/318/DraggedImage-3.png)  \n墨竹工卡就是我们今天的计划休息地。但天色尚早，很多在我们后面的骑友都往拉萨走了，我也难掩兴奋之情，想一鼓作气冲到拉萨！那索性就继续出发……  \n![](/images/318/DraggedImage-4.png)  \nK4567的里程碑，合影留念，过了这就是平坦的柏油路直面拉萨。  \n![](/images/318/DraggedImage-5.png)  \n我在最后冲刺的九十公里，身体状态达到了最佳，四个小时就冲到了布达拉，一举超过很多前面的骑友，在冲刺的时候整个脑海在回响这一路爬的每一座山，口中念着每一天的行程。\n进城过拉萨桥的时候，不由地流泪了，是被自己感动，22天风雨兼程318，不推车，不搭车，不抛弃，不放弃。我做到了！","slug":"journey_318","published":1,"updated":"2019-01-13T09:44:52.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d3c002wl1fqv2gms1b8","content":"<h2 id=\"写于川藏出发前\"><a href=\"#写于川藏出发前\" class=\"headerlink\" title=\"写于川藏出发前\"></a>写于川藏出发前</h2><p><img src=\"/images/318/1255460395.jpg\" alt=\"\"></p>\n<blockquote>\n<p>有些事现在不做，永远都不会去做了。</p>\n</blockquote>\n<blockquote>\n<p>318国道，东起上海人民广场，西至中国与尼泊尔边界樟木口岸友谊桥，全长5476公里，是中国最长的国道。“那些伟大的景观不在318的两旁，就在道路南北不出200公里的范围内：钱塘江、西湖、太湖、黄山、庐山、鄱阳湖、洞庭湖、九华山、神农架、恩施、张家界、峨眉山……”而进入四川，318又被称为川藏公路，“贡嘎山、海螺沟、折多山、雅拉雪山、南迦巴瓦、加拉白垒，海拔8000米以上的马卡鲁峰、卓奥友峰、珠穆朗玛峰、希夏邦马峰……还有无数的雪山和冰川在这条大道的两旁。318国道从纵横中国大地的公路网中脱颖而出，成为了一条绵延万里的景观长廊。”2006年，318国道被《中国国家地理》评为“中国景观大道”（据百度百科和维基百科）</p>\n</blockquote>\n<p>我这次的目标，就是走318国道最为壮丽的一段，成都-拉萨，川藏线。<br>为了这次旅行，从4月开始跑5km储备体能，于5月31日正式离职，收拾行囊。<br>我一直相信，真正的美景始终在路上，旅行的奇妙体验在于不可预知，在于每天早晨会在不同的地方醒来。</p>\n<p>我热爱旅行，迷恋在路上的感觉，在之前的生命里，我一直以体验不同的生活为最大乐趣。</p>\n<p>塞内加曾说：何必为部分的生活而哭泣，君不见，全部的人生都让人潸然泪下。<br>今天，就要踏上旅途，也许失败，也许艰难，也许幸福。<br>但，无论怎样，我都已准备好去享受这一切，双手合十，愿一路平安。</p>\n<p>2016/06/06 成都</p>\n<h2 id=\"成都小记\"><a href=\"#成都小记\" class=\"headerlink\" title=\"成都小记\"></a>成都小记</h2><p>这次的成都之行是一次难忘的经历，第一次住青旅的新鲜感，陌生人之间互相娴熟的聊天毫无晦涩感，喜欢这种体验。青旅的老板阿铭是我眼中的完美男人，微胖，短须，菜做的色香味，娴熟的琴技加上浑厚的嗓音，悠远的歌声中，让人容易想起旧事，他给旅舍起了个名字，比邻，天涯若比邻的寓意，邻家大哥的感觉，幽默十足。杀人游戏，露天烧烤，这里真的让我恍惚，像家的感觉。以后有机会，希望这个小栈还在，希望再次回到成都能再来这里看看。<br>￼<img src=\"/images/318/507311534.png\" alt=\"\"><br>三巷一号帮我调车的大哥，我没有机会问他的名字，也没选择他家的旅舍，我非常感谢他，萍水相逢，好人！<br>￼<img src=\"/images/318/805238010.png\" alt=\"\"><br>终于组到了队伍，七个人，因为担心一下子记不住那么多名字，我们按照年龄做了排序，我排老六，老大是甘肃人，带了队旗，写着brave heart 勇敢的心。<br>老二是惠州人，长于深圳，广东仔，86年生。<br>老三老四，来自南京，同89年生人，初步接触，老三低调，沉默寡言，曾当过武警，老四爱吹牛，爱说南京那些事儿，话痨，南吹，不算贬义词吧！<br>老五是地地道道的四川广安人，四川话说得非常好听，92年的。<br>我暂时对老七一无所知，他是最后一个加入我们队伍的，排老七是因为比还我小五个月，哈哈哈，没错终于有比我小的了，94年人。<br>￼<img src=\"/images/318/2768809826.png\" alt=\"\"><br>希望我们这支队伍能一起冲到最后，不抛弃，不放弃。一路平安。<br>出发之前的凌晨，举着手机敲下这些憋足的文字。</p>\n<p>2016/06/10 成都</p>\n<h2 id=\"Day-01\"><a href=\"#Day-01\" class=\"headerlink\" title=\"Day 01\"></a>Day 01</h2><p>成都-雅安 /小雨转阴 /150km<br>￼<img src=\"/images/318/IMG_0020.JPG\" alt=\"\"><br>出发伴随着小雨，上午60公里的缓上坡，这段路基本没有什么风景，下午雨停了，90公里的起伏路，累到爆，虽然我心里非常清楚这仅仅是开始，但川藏线真名不虚传，感谢前人留下的路书和攻略，让我们自由前行。<br>离开成都时，阿井说，川藏线上每一天都是挑战<br>。<br>我的同伴有一个四川广安的小伙，他说真佩服那些能骑到拉萨的人，忍受这种折磨，真不是简单人，我一辈子都不会忘记这一天！我说我们也想成为像他们一样不简单的人，所以我们选择了折磨和痛苦来到了他们曾经走过的路，然后他说对，要做不平凡的事！<br>老二说了一句非常经典的适合描述川藏线的话，让我非常感慨: 当你在穿山越岭的另一边，我在孤独的路上没有尽头。<br>第一天强行军150公里，老二在骑到名山就给我们打电话派车去接他了，他身体不好可以理解，我也在心底默默的跟自己说，一定不搭车，一定不推车，万事开头难，不抛弃不放弃，加油！</p>\n<p>2016/06/10 雅安</p>\n<h2 id=\"Day-02\"><a href=\"#Day-02\" class=\"headerlink\" title=\"Day 02\"></a>Day 02</h2><p>雅安-新沟 /晴 / 90km<br><img src=\"/images/318/IMG_0046.JPG\" alt=\"\"><br>经过昨晚的休息后，精神好了很多，PP也逐渐适应长时间的摩擦，早上7点起床收拾吃饭，队友要补充装备，上午在<em>雅安</em>成墨迹到9点才出发，太阳火辣辣的烤着就上路了，上午状态不错，中午11点多到达<em>天全</em>吃午饭，休整一小时后继续前行。</p>\n<p>下午有60公里的路程，谁也没想到一路的爬坡，离新沟还有10公里时体力几乎已经透支，路上遇到从名山单骑到新沟，最后3公里与我同行，一句鼓励我，激励我，很感谢他。我只是累到说一句话的力气都没有，安静，只有车轮滚滚向前，蹬踏，全世界都仿佛安静了……</p>\n<p>今天是正式从101国道切到318国道，时常会有人们从身旁划过，给你竖起大拇指，说加油！我也会回应大拇指，我理解这应该算是318的文化吧，路上遇到就会互相鼓励，互相帮助！</p>\n<p>走318让我对坚持有了重新的感悟，也对生命多了更深一层的认识，虽然我踏上这条传说中的路刚刚两天，我也知道有更多的故事个人等着我去遇见。</p>\n<p><img src=\"/images/318/IMG_0039.JPG\" alt=\"\"><br>￼ 2016/06/11 新沟</p>\n<h2 id=\"Day-03\"><a href=\"#Day-03\" class=\"headerlink\" title=\"Day 03\"></a>Day 03</h2><p>新沟-泸定 /晴 /57km<br>￼<img src=\"/images/318/IMG_0058.JPG\" alt=\"\"><br>因为今天的路程不是太多，相对第二天和第一天比较轻松一点，所以我们9点才离开新沟前往泸定，今天要爬的是川藏线第一座叫得上名字的山，先是20公里盘山公路环绕而上，让人欲仙欲死，不过我还是坚持了两不原则，不推车，不搭车，我比大部队晚出发十分钟，加上不擅长爬坡，所以也是最后到达二郎山隧道口，老二和老大在隧道口等着我，让我心里感动了一下下。<br>￼<img src=\"/images/318/IMG_0078.JPG\" alt=\"\"><br>穿过4公里的隧道，老大说饿了，我们就决定吃饭后再赶往泸定，饭后是30多公里的长坡，很爽，但是很危险，我一直让速度保持在30码以下，人年纪渐长就不敢那么冲动了，我是全队下坡最慢的，下午3点到达红色名城泸定，休整半天，洗脏衣服，出发三天来基本都是湿衣服，汗水不停的流淌，我估计按这样下去骑到拉萨，瘦个20斤不成问题。<br><img src=\"/images/318/IMG_0097.JPG\" alt=\"\"><br>下午短暂的休息和洗漱之后，和队友一起去了小学课本中的泸定桥，据说下午6点之后才不收费，大渡河的滔滔江水，让人站在桥上会眩晕，仿佛看到历史伴随着这江水滚滚而去。<br>￼<br>2016/06/12 泸定</p>\n<h2 id=\"Day-04\"><a href=\"#Day-04\" class=\"headerlink\" title=\"Day 04\"></a>Day 04</h2><p>泸定-康定 /多云 / 52km /海拔 2395m</p>\n<p>从北京到成都的那天晚上喉咙疼，第二天就咳嗽加浑身无力，到新沟时已经有所好转，到昨晚还是咳嗽到2点，早上六点就起床收拾出发了，20公里的起伏路，接着就是没完没了的爬坡，下午4点爬到康定红灯笼客栈，连给这座美丽的城市拍照的力气都没有了。</p>\n<p>老大今天也搭车了，半路被扎胎，正好给了他搭车的理由，哈哈，我是真的这么理解的，他确实爬不动了，大多数时候都是在推车，队伍中老三和老四打算骑到折多塘的，但老四下午六点才到康定，也是半路被扎胎，不过他还是坚持骑到了康定，给他点赞，他还是那么爱吹牛。</p>\n<p>我有些担心，晚上咳嗽很严重，早上起床也感觉有些轻微的感冒，明天海拔就超过3000了，真的不想离开队伍自己休息好养好再走，大家一起从成都出发，如果一起骑到拉萨该是多好的事情！</p>\n<p>希望高反不会太严重，耽误大家的时间，希望感冒咳嗽快点好，高原感冒有生命危险啊，今天早些吃药上床休息了，希望一切赶紧好起来。<br><img src=\"/images/318/IMG_0157.JPG\" alt=\"\"><br>骑318到现在一直没有精力拍照，总是在赶路赶路……心好累，辜负了那么多美景！</p>\n<p>2016/06/13 康定红灯笼客栈</p>\n<h2 id=\"Day-05\"><a href=\"#Day-05\" class=\"headerlink\" title=\"Day 05\"></a>Day 05</h2><p>康定 - 折多塘村 /晴 /17km /海拔3300m</p>\n<p>康定是座美丽的小城，跑马山我小的时候就知道，据说康定的人都会唱情歌，一问之下竟然是真的。</p>\n<p>联系了大学同学，给她发了康定的位置和跑马山的照片，告诉她我经过她的家乡，特此问候，虽然她远在上海…故乡的位置和照片应该会让人感到亲切吧。</p>\n<p>图为清晨的青山环绕的康定新城，蓝天白云和远处的雪山，好想就在这住下去…<br>￼<img src=\"/images/318/IMG_0170.JPG\" alt=\"\"><br>昨晚咳嗽有所好转，休息的也不错，还是早上6点起床，客栈老板是藏族，早餐第一次喝酥油茶，味道还可以，微咸。<br>￼<img src=\"/images/318/IMG_0184.JPG\" alt=\"\"></p>\n<p>从康定爬到折多塘村，17公里，海拔从2300上升到3300，大家决定就地休整半天，一为了适应高反，大家调整下，再也为了在折多山泡一下传说中的温泉，也是我第一次泡温泉。<br>￼<img src=\"/images/318/IMG_0197.JPG\" alt=\"\"><br>认识这是什么吗，我真的第一次见，叫日晕。<br>￼<img src=\"/images/318/IMG_0200.JPG\" alt=\"\"><br>七兄弟在藏民家的合影，房间分为汉室和藏室两种，藏室里面还放着一口棺材，把老三吓的不轻，我也胆小只好和老七一起睡了汉室。</p>\n<p>2017/06/14 折多塘村</p>\n<h2 id=\"Day-06\"><a href=\"#Day-06\" class=\"headerlink\" title=\"Day 06\"></a>Day 06</h2><p>折多塘 - 折多山 - 新都桥 /小雨，雪，阴 /58km /海拔3600</p>\n<p>晚上下了一夜的雨，很早就休息了，早上六点醒来，窗外的雨声还是没有停，老七拉开窗帘看了下，大雨。在群里询问了老大的意见，说继续休整，就继续睡去……</p>\n<p><img src=\"/images/318/DraggedImage-81.png\" alt=\"\"></p>\n<p>再醒来就是九点了，看到老四发朋友圈独自上路了，后大家商议决定，老大，二，三，五搭车翻越折多山到新都桥等我和老七，吃过早饭，我和老七就出发了。<br>十点出发，22公里，海拔上升到4298，“折多”在藏语中是弯曲的意思，写成汉语又是“折多”二字。被称为康巴第一关，折多山以西就是青藏高原的东部，真正的藏区。<br><img src=\"/images/318/DraggedImage-82.png\" alt=\"\"></p>\n<p>伴随着小雨，积雪的青山，我们以平均5码的龟速向着垭口爬行，出发一个小时后，老大他们的车就超越我们扬长而去……</p>\n<p><img src=\"/images/318/DraggedImage-83.png\" alt=\"\"></p>\n<p>青山白云间穿行，路遇77岁的老大爷同样骑川藏线，一起合影，佩服的肝肠寸断，我想22岁的年纪再没有任何理由可以阻挡我去做完这件事了吧，就是这样！</p>\n<p><img src=\"/images/318/DraggedImage-84.png\" alt=\"\"></p>\n<p>你看那飘扬的经幡，就说明垭口就要到了，折多山被我们征服了，虽然伴随着轻微的高反，心里这时是自豪的！<br>只要在路上永远都是故事，到达垭口的时候在碑前拍照，竟然遇到了同县同镇的老乡，他们是组团出游包车从成都出发，我在让队友拍照时，身旁的阿姨用普通话问我，你们是骑车的吗，你们队伍中有没有山西人呀，我说有啊，我就是山西人，接着我问她你山西的吗？山西那里的，她又说我长治的，我就用长治话跟他说我也长治的，然后她说你真的是长治的天呐，对啊，我用壶关话说我是壶关滴，然后她就更震惊的表情看着我我用壶关话说她也是壶关的，哈哈哈哈，世界原来这么小，还遇到了同镇的，于是我又切换到了标准的树掌话，哈哈，都被详细追问到了你爹在那个单位工作看看是不是认识，阿姨和大叔们问我要往哪里去，我说到拉萨，他们说你一定要注意安全啊，嘿嘿，阿姨小跑去车上取下一大包家乡的琪炒，说这个治水土不服，饿了也管饱，你带上，有谁没车上有我去给你拿，实在是推不开，都说近乡情更怯，但我真觉得离乡千万里，乡音更让情更怯，合照，依依分别，大叔还在原处感叹着乡音呐！乡音呐！<br>背井离乡多年，漂泊于外面的世界，会让人变得冷漠，是他们的热情感染了我，重拾原来家乡的人可以这么亲切…<br><img src=\"/images/318/DraggedImage-85.png\" alt=\"\"><br>康巴第一关，以后的路就是藏区了，出行时的七个人仍然不离不弃，新都桥被称为摄影家家的天堂，到处都是美景，微单依然躺在驮包里，我却没有一点想法去拍点什么……<br><img src=\"/images/318/DraggedImage-86.png\" alt=\"\"><br>入住了新都桥桐花里客栈，老板说话让人听起来非常愉快，山东汉子，青岛人，我还给他简单的来了几句青岛话，告诉他我曾经在潍坊上大学，有很多青岛的同学朋友，老板旅行过全国所有的地方，最后留在了这里，开一间小客栈，我们没有过多的交流，但从老大口里听的出这是个有故事的男人。<br><img src=\"/images/318/DraggedImage-87.png\" alt=\"\"><br>晚饭的时候看到老大发的朋友圈，是这样的:<br><img src=\"/images/318/DraggedImage-88.png\" alt=\"\"><br>78年的七尺汉子，当着我的面，真的流泪了，我看到他红了眼眶，就把头转了过去，我不喜欢这样，虽然都是性情中人，老大说当他坐着车从我和老七身边划过时，就哭了，真的后悔了。老五接着说，他那时把眼睛望向了窗外，让泪水在里面转几圈，记住放弃的味道……然后骑下去。<br>我理解他们，所有人都放弃的时候我会感觉到孤独，但选择了走318我就一定不能让自己后悔，不尝试，不尽力就放弃的后悔。</p>\n<h2 id=\"Day-07\"><a href=\"#Day-07\" class=\"headerlink\" title=\"Day 07\"></a>Day 07</h2><p>新都桥 - 高尔寺山 - 雅江 - 相克宗村 /晴 /92km /海拔3600</p>\n<p>今天从七兄弟变成了六个，老三走了，回了南京，我们也不好追问具体详细，昨晚小喝了一杯送别酒，希望老三一路顺风，晚上到达相克宗时听说他已回到了成都。<br>8点钟出发爬坡20多公里到高尔寺隧道，老二在半路高反比较严重，我们在隧道口等了一个多小时，隧道将近6公里长，因为正在修建，其中四公里没有灯，所以必须结伴前行。<br><img src=\"/images/318/DraggedImage-72.png\" alt=\"\"><br>爬山途中遇到昨天在折多山的77岁老大爷的同伴，也是70岁高龄，身体非常硬朗，重庆人，两人结伴骑过五次长途，曾环过山东半岛，其他的我给忘记了，我问他川藏线是不是他骑过最难最有挑战的，他毫不犹豫的告诉我，是的，在高原攀山越岭，太有挑战了。<br><img src=\"/images/318/DraggedImage-73.png\" alt=\"\"><br>半年之前骑行的骑友就没有这种享受了，他们要翻越4659m的高尔寺山，如果折多山被称为康巴第一关，那么高尔寺就是第二关，以前让骑行队伍分开的最多的一座山，挑战和痛苦可想而知……<br>从隧道通过后就是40公里的大长坡到雅江，一路的美景，让人心碎的美景，北京从没有过的蓝天白云，就像许少歌里唱的一样：只有青山藏在白云间，蝴蝶自由穿行在清涧。当然没看到蝴蝶，领悟精神，领悟精神！</p>\n<p><img src=\"/images/318/DraggedImage-74.png\" alt=\"\"><br>一路的长下坡伴随着大回环，我又是队伍中下坡速度控制的最慢的，下午两点钟我们到达了雅江，休息吃午饭，补充水。<br><img src=\"/images/318/DraggedImage-75.png\" alt=\"\"><br>今天的目的地是相克宗村，还有20多公里的陡坡要爬，海拔会重新上升1000多米，所以这一天真正的挑战才刚刚开始，短暂的休息过后，3点钟继续顶着烈日，迎着横风出发了……<br><img src=\"/images/318/DraggedImage-76.png\" alt=\"\"><br>景色依然美不胜收啊……<br><img src=\"/images/318/DraggedImage-77.png\" alt=\"\"><br>路上第一次出现了拉萨的标志，1608公里，我们还有很高很高的山要翻越，很长很长的坡要爬……<br><img src=\"/images/318/DraggedImage-78.png\" alt=\"\"><br>也第一次遇到了川藏公路的长长军车队伍，老七算了一下大概150多辆，我就在想为什么现在交通手段这么成熟，不派几量飞机直接运送，却要让这些汽车兵，成群结对辛辛苦苦的走这川藏线，一个小插曲吧……<br><img src=\"/images/318/DraggedImage-79.png\" alt=\"\"><br>G318的路牌，留一张。<br><img src=\"/images/318/DraggedImage-80.png\" alt=\"\"><br>从此之后，里程碑就步入3开头了，再留一张。碑上写满了骑友想说的话，碑上写不下了就在旁边的栅栏上写……<br>这个时候，相克宗也终于到了，今天的行程体力几乎拉爆了，明天迎接我们的将是川藏线以来最难的，最有挑战的一天……爬4600米的剪子弯山，再翻越卡子拉山，会在4200米的高海拔迎接几十公里的起伏路，并伴随野狗的触摸，自己到处的岗风，侧风，横风，想起来腿就软了，早点休息，早点出发吧，晚安。</p>\n<h2 id=\"Day-08\"><a href=\"#Day-08\" class=\"headerlink\" title=\"Day 08\"></a>Day 08</h2><p>相克宗村 - 剪子弯山 - 卡子拉山 - 红龙乡/雨，晴/79km/海拔4170m  </p>\n<p>被客栈老板称为最难最有挑战的一天，在清晨六点的闹钟中开始了，老大和老二估计是被老板吓到了，果断选择了搭车，14公里的爬坡到剪子弯隧道，途径天路十八弯。<br><img src=\"/images/318/DraggedImage-67.png\" alt=\"\"><br>14公里的爬坡对于刚刚出发的体力来说，易如反掌，2个小时就爬到剪子弯隧道口<br><img src=\"/images/318/DraggedImage-68.png\" alt=\"\"><br>隧道长2.2公里，黑漆漆没有灯，必须结队通过，过了隧道就到剪子弯山的垭口，之后就是在4200以上的高原骑行几十公里的起伏路，云彩好像就在头顶贴着头皮一起飞。<br><img src=\"/images/318/DraggedImage-69.png\" alt=\"\"><br>十公里后，骤云突变，漂泊大雨呼啸而来，整整三十公里的奔袭，加上一句逆风和起伏路，手脚几乎僵硬，一路都是无人区，没有补给的地方，待冲到卡子拉山脚下的日里村时，遇到了藏族的一位大叔，招呼我去他家里喝茶，我就径直跟他爬上藏式的小楼，正好是午饭的时间，喝酥油茶，吃藏餐，烤火炉，不得不感叹这淳朴的民风。休息并等队友会合，一个小时后雨几乎停了，还是不见三位队友的影子，我便开始独自翻越卡子拉山。<br><img src=\"/images/318/DraggedImage-70.png\" alt=\"\"><br>高原的骑行超级爽，第一次连续翻两座山，318醉人的景色，再也没有高反的症状，一路杀到红龙乡，超越了一路的骑友。<br><img src=\"/images/318/DraggedImage-71.png\" alt=\"\"><br>码表破600公里了，1/4的旅程已过，越过这最艰难的一天，继续一路向西。<br>那歌词怎么说的来，对，就这个feel倍儿爽……</p>\n<h2 id=\"Day-09\"><a href=\"#Day-09\" class=\"headerlink\" title=\"Day 09\"></a>Day 09</h2><p>红龙乡 - 理塘/晴/37km/海拔3960<br><img src=\"/images/318/DraggedImage-64.png\" alt=\"\"><br>因为曾喜欢仓央嘉措的诗句，所以到了理塘就一定会想起他，理塘，一个高原小城，海拔四千多米，这座“选在高空的城市”自古以来就是茶马互市上的重镇，而理塘在藏语是“平坦如铜镜的草坝”的意思，县内还有广袤无垠的毛垭大草原。因此理塘也有“世界高城”的称号。<br>所以说起理塘，就不得让人想起仓央嘉措的那首情诗：洁白的仙鹤啊，请把双翅借给我，不飞遥远的地方，只到理塘就回。<br>这首诗，把仓央嘉措和理塘紧紧联系在了一起。也因此，有很多人会认为，理塘，是仓央嘉措的故乡。其实不然，仓央嘉措一生从未到过理塘，而这个地方确实他心灵深处最伤感的地名。因为理塘，是仓央嘉措爱人卓玛的故乡。<br><img src=\"/images/318/DraggedImage-65.png\" alt=\"\"><br>放眼理塘，这座小城并不大，一条主街道走的再慢也不过个把时辰的光景。因为修路，街道略脏，但是你可以看到，天空很蓝，大朵大朵的白云凝固在这深蓝的天空中。树不多，但草原、山丘、河流，披着阳光，显得很干净很原生态。和梦中的境界一样。而这座城市中，轻而易举就能发现仓央嘉措的影子。路边有几家紧挨着的旅馆，名字大多借用了仓央嘉措的绝笔诗，大凡是仙鹤宾馆、白鹤旅馆等等。<br>从红龙乡到理塘的旅程很短很短，所以就慢下来，静静地看着这里的天，缓缓的感受这里的风景。<br><img src=\"/images/318/DraggedImage-66.png\" alt=\"\"><br>有很多想写理塘的话，可是当我真的到了这里，却不知从何写起……再找不到句子，就让情感流淌，理塘的天色有些黯淡了，独自坐在湖边，湖水泛着金光，从草原腹地浅浅的顺流而下……</p>\n<h2 id=\"Day-10\"><a href=\"#Day-10\" class=\"headerlink\" title=\"Day 10\"></a>Day 10</h2><p>理塘 - 禾尼乡/阵雨/58km/海拔4130  </p>\n<p>上午没有出发，看完了这个夏天最后一场比赛。<br>金州勇士输掉了完美赛季里的最重要的一场比赛，输掉了奥布莱恩杯，输掉了总冠军！<br>祝贺克利夫兰，2016最后的赢家，最好的球队不一定能走到最后，竞技体育，最合适的结局！<br><img src=\"/images/318/DraggedImage-60.png\" alt=\"\"><br>球赛结束后，阵雨的陪伴下，出发前往禾尼乡。<br>队伍只剩下我和老五老七，其他已经赶到巴塘休整等我们汇合。<br><img src=\"/images/318/DraggedImage-61.png\" alt=\"\"><br>三个人，三辆单车，继续在画中徜徉，笔直的318直插天际，美到让人喊出来，在喊声里告诉所有人这里的美！<br><img src=\"/images/318/DraggedImage-62.png\" alt=\"\"><br>小溪，蓝天，白云，草原。开车太快，走路太慢，骑单车，刚刚好……<br><img src=\"/images/318/DraggedImage-63.png\" alt=\"\"></p>\n<h2 id=\"Day-11\"><a href=\"#Day-11\" class=\"headerlink\" title=\"Day 11\"></a>Day 11</h2><p>禾尼乡 - 巴塘/阵雨/120km/海拔2590m  </p>\n<p><img src=\"/images/318/DraggedImage-58.png\" alt=\"\"></p>\n<p>当你骑着车子，伸出手臂，把手掌轻摊开来，和对面走来的藏民问好，击掌。相信我你会爱上这种感觉！<br>从理塘到巴塘都是宽阔的草原，翱翔的雄鹰，低飞的燕雀，还有那远处的化作斑斑点点的牦牛。<br>出发第11天，终于扎胎了，在刚刚出发的一小时后，就这么扎了！今天的路程是爬30公里的坡翻越海拔4685米的海子山，经90公里的长坡到巴塘。海拔下降将近两千米，并没有体验到传说中的醉氧。<br>第一次经历生死川藏，下午2点还倚在所波大叔家门框道平安的骑友，4点钟就倒在了往海子山的路上，生命真的这么脆弱，一瞬间，天人永相隔……<br>兄弟愿你一路走好，若有来生再圆川藏梦！<br>高原的天气多变，往往一天要淋好几场雨，往往都是出好几身臭汗……<br><img src=\"/images/318/DraggedImage-59.png\" alt=\"\"><br>出发11天了，终于要出四川了，明天就过金沙江大桥入西藏界了</p>\n<h2 id=\"Day-12\"><a href=\"#Day-12\" class=\"headerlink\" title=\"Day 12\"></a>Day 12</h2><p>巴塘 - 金沙江大桥 - 温泉山庄/晴/47km/海拔2840  </p>\n<p><img src=\"/images/318/DraggedImage-57.png\" alt=\"\"></p>\n<p>出四川了，终于出四川了！穿过金沙江大桥就是西藏界，桥中间横分川藏两界。<br>上午十点出发去邮局买明信片，盖邮戳。说到明信片和邮戳，在理塘之前都没有想到，有点遗憾，以后到拉萨的途中，每到一座城都买吧！<br>下午两点到达温泉山庄，老大已经在等候，老四独自一人翻越宗巴拉山到芒康去了，队伍如今只剩下五人，新的温泉山庄已经基本修建完毕，但还没有开始营业，以后的骑友可以体验享受了！</p>\n<h2 id=\"Day-13\"><a href=\"#Day-13\" class=\"headerlink\" title=\"Day 13\"></a>Day 13</h2><p>温泉山庄 - 宗巴拉山 - 芒康/晴/60km/海拔3920m  </p>\n<p><img src=\"/images/318/DraggedImage-55.png\" alt=\"\"></p>\n<p>痛苦的一天，转弯之后一个接一个的爬坡，还是没有尽头的路，50公里的爬坡，其中将近10公里的烂路，海拔从2800上升到4150，今天，真够累！<br><img src=\"/images/318/DraggedImage-56.png\" alt=\"\"><br>下午担心少数民族地区邮局五点下班，一路狂奔到邮局买明信片盖邮戳，芒康这个鬼地方全城都在修路。</p>\n<h2 id=\"Day-14\"><a href=\"#Day-14\" class=\"headerlink\" title=\"Day 14\"></a>Day 14</h2><p>芒康 - 拉乌山 - 如美/晴/50km/海拔2670  </p>\n<p>出城过检查站的时候，才想起昨天在邮局盖邮戳取钱时把银行卡落在了ATM机被吞了，这次旅行只带了一张卡，叫了老七一起匆匆赶到邮局时，邮局工作人员都回家午休了，下午两点半才上班，需要等一个半小时，那就等吧，在门口待了十多分钟后走过来两个姑娘是邮局的工作人员，说三点半才上班，我就着急了，老五和老大已经先爬坡往如美去了，如果等到三点半天黑前还能不能赶到如美，给两位美女说明事情和为难后，美女给相关工作人员确认了银行卡确实在机器里，然后加了微信，说拿到卡片后帮我寄回北京，感动的我快哭了，这张卡对我有特殊的意义，使用多年，实在不舍得注销。<br><img src=\"/images/318/DraggedImage-50.png\" alt=\"\"><br>事情处理完毕，立即和老七追赶他们的脚步，芒康进城出城都要翻山，进城是宗巴拉山，出城是拉乌山，望着眼前没完的盘山路，就听见老七在我的后面叹息。<br><img src=\"/images/318/DraggedImage-51.png\" alt=\"\"><br>公路的旁边就是悬崖，交警单位把报废的汽车时摆在路旁，时刻提醒着过往的路人，安全第一！老七说你拍这有啥意思，我说要拍，提醒自己，小心加小心，生命只有一次。<br><img src=\"/images/318/DraggedImage-52.png\" alt=\"\"><br>在拉乌山垭口遇到了三个骑滇藏线过来的骑友，这座山是他们目前爬过最高的海拔，聊到他们看到了梅里十三峰，真幸运，祝他们幸运。<br><img src=\"/images/318/DraggedImage-53.png\" alt=\"\"><br>从拉乌山垭口到如美是35公里的下坡，海拔从4370下降到2670，一路风景如画，路过3456的里程碑，留个纪念，上面同样涂满了来自五湖四海骑友想说的话。<br><img src=\"/images/318/DraggedImage-54.png\" alt=\"\"><br>如美小镇跨越澜沧江，到达时还不到五点，老大和老五又搭车了，从撞烂的汽车的地方就搭了，他们坐车到达一刻钟我和老七就到了，我本打算时间尚早再爬十公里山路到教授山庄为明日翻越觉巴山做准备，但是老大说腿软，那就住下吧！<br>顺便洗臭袜子，全汗味的衣服……</p>\n<h2 id=\"Day-15\"><a href=\"#Day-15\" class=\"headerlink\" title=\"Day 15\"></a>Day 15</h2><p>如美 - 觉巴山 - 容许兵站/晴/54km/海拔4020m<br><img src=\"/images/318/DraggedImage-45.png\" alt=\"\"><br>你是否站在过1300米的高处眺望过大地？是什么感觉？觉巴山被当地人称为绝望山，其实海拔并不是很高3911，但是足够征服一个人对山的所有理解。<br><img src=\"/images/318/DraggedImage-46.png\" alt=\"\"><br>出如美到觉巴山垭口26公里的陡坡，海拔从2670上升到3911，九点出发，两点到垭口，5升水，半块压缩饼干，累到说不出话来，只能张开嗓子，干呕两声……<br><img src=\"/images/318/DraggedImage-47.png\" alt=\"\"><br>当站在山顶回望来时的路，我是真的佩服自己，佩服这条线。老大在出发后十公里处终于坚持不住选择了搭车。<br><img src=\"/images/318/DraggedImage-48.png\" alt=\"\"><br>早上出门时，后车轮刹车有点松，调了一下，待到山顶下坡时，发生了问题，后刹刹不住，幸好下坡直有十多公里，前刹还好，下到登巴村时老五和老大又搭车走了，还好有老七陪伴，我已经几乎竭力，还有13公里的爬坡到容许兵站，为明天东达山做准备。<br><img src=\"/images/318/DraggedImage-49.png\" alt=\"\"><br>晚上休息的客栈老板车技超高，高中毕业后就一直玩户外，拿的奖状贴满了客栈餐厅的墙壁，菜做的一级水准，帮我调了刹车和变速，学了好几招调车的方法，等回北京我打算找家车店，周末休息时，去免费帮人调车多学点技能啊哈哈。</p>\n<h2 id=\"Day-16\"><a href=\"#Day-16\" class=\"headerlink\" title=\"Day 16\"></a>Day 16</h2><p>容许兵站 - 东达山 - 左贡/晴/62km/海拔3810m<br><img src=\"/images/318/DraggedImage-42.png\" alt=\"\"><br>东达山，川藏线两座5000米大山之一，难度在于高海拔，坡度平缓，26公里海拔上升1000米，<br>翻过东达山就表示行程已经过半，接下来到达拉萨只剩下四座大山。<br><img src=\"/images/318/DraggedImage-43.png\" alt=\"\"><br>过东达到左贡，如果没有高反就是很轻松的行程，老七在半路高反严重，休息吃药后才继续出发，我最早到达垭口，在垭口等队友将近两个小时。行程太慢，15号出发的队伍都已经追上我们，买了10号拉萨到西宁的机票，川藏之行结束顺路去七月的青海湖，约了一圈好友，大家都没时间，那就我自己吧……<br><img src=\"/images/318/DraggedImage-44.png\" alt=\"\"><br>我只是从未如此想去一个地方。</p>\n<h2 id=\"Day-17\"><a href=\"#Day-17\" class=\"headerlink\" title=\"Day 17\"></a>Day 17</h2><p>左贡 - 邦达/晴，雨/107km 海拔4130m  </p>\n<p><img src=\"/images/318/DraggedImage-41.png\" alt=\"\"><br>西藏的天气是什么样的呢，一言不合就下雨，刚穿上雨衣雨就停，脱完了雨再下，折磨，折磨！<br>今天没有山，100多公里的起伏路，川藏线骑习惯了，平路就当是下坡，一般的上坡就当是平路。<br>累，就写这点吧…</p>\n<h2 id=\"Day-18\"><a href=\"#Day-18\" class=\"headerlink\" title=\"Day 18\"></a>Day 18</h2><p>邦达 - 业拉山 - 怒江72拐 - 八宿/晴/95km/海拔3250<br><img src=\"/images/318/DraggedImage-34.png\" alt=\"\"><br>再出发，三人行，老大又搭车！<br><img src=\"/images/318/DraggedImage-35.png\" alt=\"\"><br>垭口回望来时的路，邦达小镇依稀可见。<br><img src=\"/images/318/DraggedImage-36.png\" alt=\"\"><br>业拉山，海拔4658，已经变的没什么挑战。<br><img src=\"/images/318/DraggedImage-37.png\" alt=\"\"><br>怒江天路72拐，巍峨壮观，身临其境，心惊胆寒！在这里摔车的朋友，一个接一个。老七也摔了，不过问题不大，我肯定不会，我下坡最慢了。<br><img src=\"/images/318/DraggedImage-38.png\" alt=\"\"><br>再看一眼怒江，汹涌着，嘶吼着。天生脾气就不好！<br><img src=\"/images/318/DraggedImage-39.png\" alt=\"\"><br>下了天路72拐，就是30公里的上坡到休息地，前14公里荒无人烟，早上没做准备带干粮，坚持到半路遇见一个能在水浒中才有的凉亭，一碗泡面下肚，立马就过岗，哈哈。<br><img src=\"/images/318/DraggedImage-40.png\" alt=\"\"><br>14公里后，三人坐下每人来了一瓶啤酒，喝完我就腿软了，然后席地而睡休息了一个小时。<br>半路遇到一个开车的大哥非要送我一瓶红牛，我拍拍胸脯告诉他我可以，出发至今带了一罐红牛一直没喝，放在驮包里，我只想靠坚持和毅力去翻越每一座山，每一段旅程。</p>\n<h2 id=\"Day-19\"><a href=\"#Day-19\" class=\"headerlink\" title=\"Day 19\"></a>Day 19</h2><p>八宿 - 安久拉山 - 然乌/晴/90km/海拔3850<br><img src=\"/images/318/DraggedImage-29.png\" alt=\"\"><br>昨晚晚饭时听到几个来自山西晋城的大哥说今天的路程，68公里上坡到安久拉山垭口，22公里起伏路到然乌，他们说过了今天就好了，五星难度，以后的路只是时间问题。<br><img src=\"/images/318/DraggedImage-30.png\" alt=\"\"><br>真正踏上今天的旅程，我们怀着忐忑的心，但是却是休闲骑，直到被一个个晚出发的队伍超越，下午遇到三个纯徒得驴友，互相鼓励，他们已记不起早上是从哪里出发。<br><img src=\"/images/318/DraggedImage-31.png\" alt=\"\"><br>下午六点，我和老七终于爬到安久拉山垭口<br><img src=\"/images/318/DraggedImage-32.png\" alt=\"\"><br>这时老大电话响起，已经定好然乌湖旁边的湖景房。<br><img src=\"/images/318/DraggedImage-33.png\" alt=\"\"><br>傍晚的然乌湖，湖风煦煦，雪山倒映在湖中，我独自坐在湖边感受着这份难得的安静。</p>\n<h2 id=\"Day-20\"><a href=\"#Day-20\" class=\"headerlink\" title=\"Day 20\"></a>Day 20</h2><p>然乌 - 波密/雨/132km/海拔2700<br><img src=\"/images/318/DraggedImage-24.png\" alt=\"\"><br>伴随着小雨，告别美丽的然乌湖，短暂的休整让我们再次出发！今天的行程是132公里的缓下坡和起伏路，海拔将从3850下降到2700，也将步入物产丰富林芝地区。<br><img src=\"/images/318/DraggedImage-25.png\" alt=\"\"><br>进入林芝，以后的景色也都会变得郁郁葱葱～<br><img src=\"/images/318/DraggedImage-26.png\" alt=\"\"><br>不起眼的4000里程碑，又被路过的骑友涂满了各种想说的话，这回没有了栅栏，拉萨越来越近，心情变得急促，我说拉萨不是目的，享受的是在路上……<br><img src=\"/images/318/DraggedImage-27.png\" alt=\"\"><br>路遇生灵，我在4000公路碑拍照时就一直跟着我，前爪受伤严重，特别可怜！喂了一袋压缩饼干，它让我想起陪伴童年时光的那条小黑。希望它一切都好～<br><img src=\"/images/318/DraggedImage-28.png\" alt=\"\"><br>今天的行程是132公里的冒雨穿越，什么防雨措施都成了摆设，十个小时的雨，浑身通透……<br>波密是座美丽的小城，被称为藏王故里，冰川之乡，干净的街道，整齐的建筑，该是沿途看到最繁华最有特色的地方了，一天的雨中穿梭后，大家的衣服浸湿，队伍计划在此休整一天后再向通麦出发。</p>\n<h2 id=\"七月，你好\"><a href=\"#七月，你好\" class=\"headerlink\" title=\"七月，你好\"></a>七月，你好</h2><p><img src=\"/images/318/DraggedImage-23.png\" alt=\"\"><br>岁月如歌，弹唱着盛夏的炎热，六月走过，七月流火，送走了半年苍凉。<br>七月，你好。你是一个半年的开始，你是一个半年的结束。我在时光里穿梭，忘却了日历的轮廓，那密密麻麻的数字，原来是错落排列的日出和日落。<br>2015年6月，2000公里的呼伦贝尔穿越。<br>2016年6月，2000公里的川藏南线挑战。<br>……<br>用车轮丈量大地，体会生命的意义，享受在路上的感觉。追寻倒映在水中的蓝天白云，攀在山顶望见绵延不绝的高山。平日的浮躁与忙碌，总是冲淡我们对美好事物的追求。<br>我们都曾有梦想居住的地方。在依旧有炊烟的村庄，山水亮丽得如同梦里的笑容，每条小路清秀得像一句诗歌。白天浩瀚的蔚蓝、海边架起的小木屋、在阳光跳跃的草原，躺下，自己就是一片湖。<br>千篇一律的生活中，需要一趟说走就走的旅行。“有些事现在不做，也许一辈子都不会做了”。一句简简单单的话，不知击中过多少颗青春不羁的心。只是任何时候，除了向往自由，战胜现实，我们必须知道的是：直面自己、找到通往内心的路。<br>这一季，走过风花雪月，路过倾国倾城。下一季，故地重游，看尽云卷云舒，花开花落。</p>\n<h2 id=\"Day-21\"><a href=\"#Day-21\" class=\"headerlink\" title=\"Day 21\"></a>Day 21</h2><p>波密 - 通麦 - 拉月村/阴/116km/海拔2320m  </p>\n<p><img src=\"/images/318/DraggedImage-17.png\" alt=\"\"><br>波密，就在波密，剩下的哥四个终于统一了发型，本来是约定拉萨一起剃光，提前执行了，我跟老大说，我18岁的时候打死都不会搞这个发型。而现在，从良了，只觉得舒服就好，反正怎么着也都没有女朋友……<br><img src=\"/images/318/DraggedImage-18.png\" alt=\"\"><br>计划之外，在波密休整了两天，原计划休息一天，第二天出发通麦，晚上就下起了雨，早上醒来时仍然没有停的意思，询问大家都说下雨不出发就又果断睡去了。<br><img src=\"/images/318/DraggedImage-19.png\" alt=\"\"><br>查看了未来几天的天气后，于是昨天晚上下定决心，今天下雹子也要走，因为已经提前买了十号拉萨飞西宁的机票，都是眼泪，我是下雨也打算出发的，但奈何队友都不走，一个人雨天路上太危险。<br>今天计划的目的地是通麦，我曾在新浪的\\&lt;胖哥试车>节目的西部穿越之旅里见识过传说中的通麦天险，从波密出发到通麦90公里的起伏路，海拔下降700米，40公里在修路，远超山西未实现村村通工程前的石头泥巴路，路上的骑友举着相机说，这才是318的味道，我路过，回一句，那就好好享受……<br>想说的是队伍只剩下了我和老七，老大和老五在早上醒来后再次选择了搭车到八一，从波密到八一300多公里的路，也就意味着我和老七三天才能到。或许那个时候他们早就又坐车到拉萨了吧……<br><img src=\"/images/318/DraggedImage-20.png\" alt=\"\"><br>刚刚建成的通麦大桥，看胖哥节目的时候还没有他，那时应该正在修建，胖哥在节目里说，等大桥通车，以后过通麦的朋友就幸福了，果然，我幸福了，但也意味着再见不到通麦天险和单边放行的通麦铁板桥。<br><img src=\"/images/318/DraggedImage-21.png\" alt=\"\"><br>到通麦是刚刚下午四点，天色尚早，体力尚充沛，补充水后，我和老七商量下决定往前赶路到排龙乡后面的拉月村，这样如果努力一点的话，可以把三天的行程合并成两天，明天直接杀到八一。<br><img src=\"/images/318/DraggedImage-22.png\" alt=\"\"><br>走在我前面的老七的背影，很感谢他，在所有人都放弃的时候，他没有放弃，陪着我从成都到现在，从未搭过车，做到了用车轮丈量大地的承诺，也因为有他，318对我来说，不显得那么孤单。</p>\n<h2 id=\"Day-22\"><a href=\"#Day-22\" class=\"headerlink\" title=\"Day 22\"></a>Day 22</h2><p>拉月村 - 鲁朗 - 八一/雨/114km/海拔3000<br><img src=\"/images/318/DraggedImage-14.png\" alt=\"\"><br>70公里的爬坡，海拔上升两千多米，第一次挑战在下午体力即将耗尽的时候翻山。太酸爽！这便是三天的路两天赶完的代价。<br><img src=\"/images/318/DraggedImage-15.png\" alt=\"\"><br>在这条线的倒数第二座山，色季拉山的垭口，我给老大打电话，他正在往拉萨的车上，还剩30公里，真的只剩下了我和老七相依为命！<br>出发时的七个人只剩下两个了，这个时候不用说什么坚持之类的云云，我和老七都知道，我们一定会骑完，百分之一的人能真正骑完川藏南线，我们即将做到。<br><img src=\"/images/318/DraggedImage-16.png\" alt=\"\"><br>淋了一天的雨，晚上九点半才到林芝市（原八一镇），318目前为止最大的城市，我说这是大城市！浑身只剩两块银元，和老七满大街的找取款机，取钱吃过饭到住的地方已近11点。我什么都不想说，沿途的风景再美，也抵不住我想尽快到拉萨的心。</p>\n<h2 id=\"Day-23\"><a href=\"#Day-23\" class=\"headerlink\" title=\"Day 23\"></a>Day 23</h2><p>八一 - 工布江达/雨/132km/海拔3420<br><img src=\"/images/318/DraggedImage-10.png\" alt=\"\"><br>不知道我和老七是对自己的体力逐渐有了自信还是，反正总是最晚出发，每天都是我催他起床。一觉睡到自然醒，吃饭，洗车，墨迹墨迹就中午。<br><img src=\"/images/318/DraggedImage-11.png\" alt=\"\"><br>一路沿着尼洋河走，景色优美让人心情分外愉悦，下午三点在百巴镇吃午饭。路过k4321留念<br><img src=\"/images/318/DraggedImage-12.png\" alt=\"\"><br>下午八点到达工布江达，路况较好，所以130公里难度对现在的身体已经够不成太大的挑战，只是中途被浇了好几场雨，鞋子湿了个通透，很酸爽。林芝地区的天气太善变……<br><img src=\"/images/318/DraggedImage-13.png\" alt=\"\"></p>\n<h2 id=\"Day-24\"><a href=\"#Day-24\" class=\"headerlink\" title=\"Day 24\"></a>Day 24</h2><p>工布江达 - 松多/晴/95km/海拔4200m<br><img src=\"/images/318/DraggedImage-6.png\" alt=\"\"><br>出发19公里处是中流砥柱景点，但是因为有人不幸掉水溺死，被蓝色的铁皮围了起来，我们只好爬到旁边的小山去拍一张没有字的一面。<br><img src=\"/images/318/DraggedImage-7.png\" alt=\"\"><br>路书上说，这将是轻松的一天，本计划6 - 8个小时的行程没找到光下午就走了六个小时，全程在修路，漫天的沙子，什么都看不见，等到松多几乎不用吃饭了，沙子加土混合的菜几乎吃饱，嗓子想干呕，又吐不出来。<br><img src=\"/images/318/DraggedImage-8.png\" alt=\"\"><br>k4444界碑已经没有了，在漫天的黄沙中拍了4445界碑，这一路上到处是豆豆的名字，也不知道豆豆是谁<br><img src=\"/images/318/DraggedImage-9.png\" alt=\"\"><br>下午40公里这样的烂路，整整骑了11个小时，接下来到拉萨只剩下180公里，有很多队伍计划一天骑到，我想我还是两天吧，这烂路将持续到拉萨，一天180公里不敢想象。分两天走吧，不作就不会死！<br>慢慢会开始对沿途的风景疲劳，会开始想东想西，从上学时的同学老师到工作后的同事朋友，一个一个想她们的模样，和一些过往，318让我又一次恍惚，分不清昨天今天明天，生活变的只有日出和日落，赶不完的路……</p>\n<h2 id=\"Day-25\"><a href=\"#Day-25\" class=\"headerlink\" title=\"Day 25\"></a>Day 25</h2><p>松多 - 拉萨/晴/180km/海拔3650m<br><img src=\"/images/318/DraggedImage.png\" alt=\"\"><br>大多数人在这一天是要赶到拉萨的，我和老七商量之下，决定把路分成两天走，所以该怎么睡就怎么睡，下楼吃饭时，所有的骑友都走了，只剩下我俩的车子停在哪里……<br>从松多出发，28公里的爬坡翻越米拉山，5013米，318的最后一座山，也是最高的山，海拔上升700，难度不大。<br>正在修建的米拉山隧道，以后来318的骑友可以少爬很多坡了，不知是悲伤还是欢喜<br><img src=\"/images/318/DraggedImage-1.png\" alt=\"\"><br>12点爬到垭口，四个多小时<br><img src=\"/images/318/DraggedImage-2.png\" alt=\"\"><br>在山顶和老七吃了两块小面包补充体力，一路的缓下坡冲到墨竹工卡刚刚下午五点<br><img src=\"/images/318/DraggedImage-3.png\" alt=\"\"><br>墨竹工卡就是我们今天的计划休息地。但天色尚早，很多在我们后面的骑友都往拉萨走了，我也难掩兴奋之情，想一鼓作气冲到拉萨！那索性就继续出发……<br><img src=\"/images/318/DraggedImage-4.png\" alt=\"\"><br>K4567的里程碑，合影留念，过了这就是平坦的柏油路直面拉萨。<br><img src=\"/images/318/DraggedImage-5.png\" alt=\"\"><br>我在最后冲刺的九十公里，身体状态达到了最佳，四个小时就冲到了布达拉，一举超过很多前面的骑友，在冲刺的时候整个脑海在回响这一路爬的每一座山，口中念着每一天的行程。<br>进城过拉萨桥的时候，不由地流泪了，是被自己感动，22天风雨兼程318，不推车，不搭车，不抛弃，不放弃。我做到了！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写于川藏出发前\"><a href=\"#写于川藏出发前\" class=\"headerlink\" title=\"写于川藏出发前\"></a>写于川藏出发前</h2><p><img src=\"/images/318/1255460395.jpg\" alt=\"\"></p>\n<blockquote>\n<p>有些事现在不做，永远都不会去做了。</p>\n</blockquote>\n<blockquote>\n<p>318国道，东起上海人民广场，西至中国与尼泊尔边界樟木口岸友谊桥，全长5476公里，是中国最长的国道。“那些伟大的景观不在318的两旁，就在道路南北不出200公里的范围内：钱塘江、西湖、太湖、黄山、庐山、鄱阳湖、洞庭湖、九华山、神农架、恩施、张家界、峨眉山……”而进入四川，318又被称为川藏公路，“贡嘎山、海螺沟、折多山、雅拉雪山、南迦巴瓦、加拉白垒，海拔8000米以上的马卡鲁峰、卓奥友峰、珠穆朗玛峰、希夏邦马峰……还有无数的雪山和冰川在这条大道的两旁。318国道从纵横中国大地的公路网中脱颖而出，成为了一条绵延万里的景观长廊。”2006年，318国道被《中国国家地理》评为“中国景观大道”（据百度百科和维基百科）</p>\n</blockquote>\n<p>我这次的目标，就是走318国道最为壮丽的一段，成都-拉萨，川藏线。<br>为了这次旅行，从4月开始跑5km储备体能，于5月31日正式离职，收拾行囊。<br>我一直相信，真正的美景始终在路上，旅行的奇妙体验在于不可预知，在于每天早晨会在不同的地方醒来。</p>\n<p>我热爱旅行，迷恋在路上的感觉，在之前的生命里，我一直以体验不同的生活为最大乐趣。</p>\n<p>塞内加曾说：何必为部分的生活而哭泣，君不见，全部的人生都让人潸然泪下。<br>今天，就要踏上旅途，也许失败，也许艰难，也许幸福。<br>但，无论怎样，我都已准备好去享受这一切，双手合十，愿一路平安。</p>\n<p>2016/06/06 成都</p>\n<h2 id=\"成都小记\"><a href=\"#成都小记\" class=\"headerlink\" title=\"成都小记\"></a>成都小记</h2><p>这次的成都之行是一次难忘的经历，第一次住青旅的新鲜感，陌生人之间互相娴熟的聊天毫无晦涩感，喜欢这种体验。青旅的老板阿铭是我眼中的完美男人，微胖，短须，菜做的色香味，娴熟的琴技加上浑厚的嗓音，悠远的歌声中，让人容易想起旧事，他给旅舍起了个名字，比邻，天涯若比邻的寓意，邻家大哥的感觉，幽默十足。杀人游戏，露天烧烤，这里真的让我恍惚，像家的感觉。以后有机会，希望这个小栈还在，希望再次回到成都能再来这里看看。<br>￼<img src=\"/images/318/507311534.png\" alt=\"\"><br>三巷一号帮我调车的大哥，我没有机会问他的名字，也没选择他家的旅舍，我非常感谢他，萍水相逢，好人！<br>￼<img src=\"/images/318/805238010.png\" alt=\"\"><br>终于组到了队伍，七个人，因为担心一下子记不住那么多名字，我们按照年龄做了排序，我排老六，老大是甘肃人，带了队旗，写着brave heart 勇敢的心。<br>老二是惠州人，长于深圳，广东仔，86年生。<br>老三老四，来自南京，同89年生人，初步接触，老三低调，沉默寡言，曾当过武警，老四爱吹牛，爱说南京那些事儿，话痨，南吹，不算贬义词吧！<br>老五是地地道道的四川广安人，四川话说得非常好听，92年的。<br>我暂时对老七一无所知，他是最后一个加入我们队伍的，排老七是因为比还我小五个月，哈哈哈，没错终于有比我小的了，94年人。<br>￼<img src=\"/images/318/2768809826.png\" alt=\"\"><br>希望我们这支队伍能一起冲到最后，不抛弃，不放弃。一路平安。<br>出发之前的凌晨，举着手机敲下这些憋足的文字。</p>\n<p>2016/06/10 成都</p>\n<h2 id=\"Day-01\"><a href=\"#Day-01\" class=\"headerlink\" title=\"Day 01\"></a>Day 01</h2><p>成都-雅安 /小雨转阴 /150km<br>￼<img src=\"/images/318/IMG_0020.JPG\" alt=\"\"><br>出发伴随着小雨，上午60公里的缓上坡，这段路基本没有什么风景，下午雨停了，90公里的起伏路，累到爆，虽然我心里非常清楚这仅仅是开始，但川藏线真名不虚传，感谢前人留下的路书和攻略，让我们自由前行。<br>离开成都时，阿井说，川藏线上每一天都是挑战<br>。<br>我的同伴有一个四川广安的小伙，他说真佩服那些能骑到拉萨的人，忍受这种折磨，真不是简单人，我一辈子都不会忘记这一天！我说我们也想成为像他们一样不简单的人，所以我们选择了折磨和痛苦来到了他们曾经走过的路，然后他说对，要做不平凡的事！<br>老二说了一句非常经典的适合描述川藏线的话，让我非常感慨: 当你在穿山越岭的另一边，我在孤独的路上没有尽头。<br>第一天强行军150公里，老二在骑到名山就给我们打电话派车去接他了，他身体不好可以理解，我也在心底默默的跟自己说，一定不搭车，一定不推车，万事开头难，不抛弃不放弃，加油！</p>\n<p>2016/06/10 雅安</p>\n<h2 id=\"Day-02\"><a href=\"#Day-02\" class=\"headerlink\" title=\"Day 02\"></a>Day 02</h2><p>雅安-新沟 /晴 / 90km<br><img src=\"/images/318/IMG_0046.JPG\" alt=\"\"><br>经过昨晚的休息后，精神好了很多，PP也逐渐适应长时间的摩擦，早上7点起床收拾吃饭，队友要补充装备，上午在<em>雅安</em>成墨迹到9点才出发，太阳火辣辣的烤着就上路了，上午状态不错，中午11点多到达<em>天全</em>吃午饭，休整一小时后继续前行。</p>\n<p>下午有60公里的路程，谁也没想到一路的爬坡，离新沟还有10公里时体力几乎已经透支，路上遇到从名山单骑到新沟，最后3公里与我同行，一句鼓励我，激励我，很感谢他。我只是累到说一句话的力气都没有，安静，只有车轮滚滚向前，蹬踏，全世界都仿佛安静了……</p>\n<p>今天是正式从101国道切到318国道，时常会有人们从身旁划过，给你竖起大拇指，说加油！我也会回应大拇指，我理解这应该算是318的文化吧，路上遇到就会互相鼓励，互相帮助！</p>\n<p>走318让我对坚持有了重新的感悟，也对生命多了更深一层的认识，虽然我踏上这条传说中的路刚刚两天，我也知道有更多的故事个人等着我去遇见。</p>\n<p><img src=\"/images/318/IMG_0039.JPG\" alt=\"\"><br>￼ 2016/06/11 新沟</p>\n<h2 id=\"Day-03\"><a href=\"#Day-03\" class=\"headerlink\" title=\"Day 03\"></a>Day 03</h2><p>新沟-泸定 /晴 /57km<br>￼<img src=\"/images/318/IMG_0058.JPG\" alt=\"\"><br>因为今天的路程不是太多，相对第二天和第一天比较轻松一点，所以我们9点才离开新沟前往泸定，今天要爬的是川藏线第一座叫得上名字的山，先是20公里盘山公路环绕而上，让人欲仙欲死，不过我还是坚持了两不原则，不推车，不搭车，我比大部队晚出发十分钟，加上不擅长爬坡，所以也是最后到达二郎山隧道口，老二和老大在隧道口等着我，让我心里感动了一下下。<br>￼<img src=\"/images/318/IMG_0078.JPG\" alt=\"\"><br>穿过4公里的隧道，老大说饿了，我们就决定吃饭后再赶往泸定，饭后是30多公里的长坡，很爽，但是很危险，我一直让速度保持在30码以下，人年纪渐长就不敢那么冲动了，我是全队下坡最慢的，下午3点到达红色名城泸定，休整半天，洗脏衣服，出发三天来基本都是湿衣服，汗水不停的流淌，我估计按这样下去骑到拉萨，瘦个20斤不成问题。<br><img src=\"/images/318/IMG_0097.JPG\" alt=\"\"><br>下午短暂的休息和洗漱之后，和队友一起去了小学课本中的泸定桥，据说下午6点之后才不收费，大渡河的滔滔江水，让人站在桥上会眩晕，仿佛看到历史伴随着这江水滚滚而去。<br>￼<br>2016/06/12 泸定</p>\n<h2 id=\"Day-04\"><a href=\"#Day-04\" class=\"headerlink\" title=\"Day 04\"></a>Day 04</h2><p>泸定-康定 /多云 / 52km /海拔 2395m</p>\n<p>从北京到成都的那天晚上喉咙疼，第二天就咳嗽加浑身无力，到新沟时已经有所好转，到昨晚还是咳嗽到2点，早上六点就起床收拾出发了，20公里的起伏路，接着就是没完没了的爬坡，下午4点爬到康定红灯笼客栈，连给这座美丽的城市拍照的力气都没有了。</p>\n<p>老大今天也搭车了，半路被扎胎，正好给了他搭车的理由，哈哈，我是真的这么理解的，他确实爬不动了，大多数时候都是在推车，队伍中老三和老四打算骑到折多塘的，但老四下午六点才到康定，也是半路被扎胎，不过他还是坚持骑到了康定，给他点赞，他还是那么爱吹牛。</p>\n<p>我有些担心，晚上咳嗽很严重，早上起床也感觉有些轻微的感冒，明天海拔就超过3000了，真的不想离开队伍自己休息好养好再走，大家一起从成都出发，如果一起骑到拉萨该是多好的事情！</p>\n<p>希望高反不会太严重，耽误大家的时间，希望感冒咳嗽快点好，高原感冒有生命危险啊，今天早些吃药上床休息了，希望一切赶紧好起来。<br><img src=\"/images/318/IMG_0157.JPG\" alt=\"\"><br>骑318到现在一直没有精力拍照，总是在赶路赶路……心好累，辜负了那么多美景！</p>\n<p>2016/06/13 康定红灯笼客栈</p>\n<h2 id=\"Day-05\"><a href=\"#Day-05\" class=\"headerlink\" title=\"Day 05\"></a>Day 05</h2><p>康定 - 折多塘村 /晴 /17km /海拔3300m</p>\n<p>康定是座美丽的小城，跑马山我小的时候就知道，据说康定的人都会唱情歌，一问之下竟然是真的。</p>\n<p>联系了大学同学，给她发了康定的位置和跑马山的照片，告诉她我经过她的家乡，特此问候，虽然她远在上海…故乡的位置和照片应该会让人感到亲切吧。</p>\n<p>图为清晨的青山环绕的康定新城，蓝天白云和远处的雪山，好想就在这住下去…<br>￼<img src=\"/images/318/IMG_0170.JPG\" alt=\"\"><br>昨晚咳嗽有所好转，休息的也不错，还是早上6点起床，客栈老板是藏族，早餐第一次喝酥油茶，味道还可以，微咸。<br>￼<img src=\"/images/318/IMG_0184.JPG\" alt=\"\"></p>\n<p>从康定爬到折多塘村，17公里，海拔从2300上升到3300，大家决定就地休整半天，一为了适应高反，大家调整下，再也为了在折多山泡一下传说中的温泉，也是我第一次泡温泉。<br>￼<img src=\"/images/318/IMG_0197.JPG\" alt=\"\"><br>认识这是什么吗，我真的第一次见，叫日晕。<br>￼<img src=\"/images/318/IMG_0200.JPG\" alt=\"\"><br>七兄弟在藏民家的合影，房间分为汉室和藏室两种，藏室里面还放着一口棺材，把老三吓的不轻，我也胆小只好和老七一起睡了汉室。</p>\n<p>2017/06/14 折多塘村</p>\n<h2 id=\"Day-06\"><a href=\"#Day-06\" class=\"headerlink\" title=\"Day 06\"></a>Day 06</h2><p>折多塘 - 折多山 - 新都桥 /小雨，雪，阴 /58km /海拔3600</p>\n<p>晚上下了一夜的雨，很早就休息了，早上六点醒来，窗外的雨声还是没有停，老七拉开窗帘看了下，大雨。在群里询问了老大的意见，说继续休整，就继续睡去……</p>\n<p><img src=\"/images/318/DraggedImage-81.png\" alt=\"\"></p>\n<p>再醒来就是九点了，看到老四发朋友圈独自上路了，后大家商议决定，老大，二，三，五搭车翻越折多山到新都桥等我和老七，吃过早饭，我和老七就出发了。<br>十点出发，22公里，海拔上升到4298，“折多”在藏语中是弯曲的意思，写成汉语又是“折多”二字。被称为康巴第一关，折多山以西就是青藏高原的东部，真正的藏区。<br><img src=\"/images/318/DraggedImage-82.png\" alt=\"\"></p>\n<p>伴随着小雨，积雪的青山，我们以平均5码的龟速向着垭口爬行，出发一个小时后，老大他们的车就超越我们扬长而去……</p>\n<p><img src=\"/images/318/DraggedImage-83.png\" alt=\"\"></p>\n<p>青山白云间穿行，路遇77岁的老大爷同样骑川藏线，一起合影，佩服的肝肠寸断，我想22岁的年纪再没有任何理由可以阻挡我去做完这件事了吧，就是这样！</p>\n<p><img src=\"/images/318/DraggedImage-84.png\" alt=\"\"></p>\n<p>你看那飘扬的经幡，就说明垭口就要到了，折多山被我们征服了，虽然伴随着轻微的高反，心里这时是自豪的！<br>只要在路上永远都是故事，到达垭口的时候在碑前拍照，竟然遇到了同县同镇的老乡，他们是组团出游包车从成都出发，我在让队友拍照时，身旁的阿姨用普通话问我，你们是骑车的吗，你们队伍中有没有山西人呀，我说有啊，我就是山西人，接着我问她你山西的吗？山西那里的，她又说我长治的，我就用长治话跟他说我也长治的，然后她说你真的是长治的天呐，对啊，我用壶关话说我是壶关滴，然后她就更震惊的表情看着我我用壶关话说她也是壶关的，哈哈哈哈，世界原来这么小，还遇到了同镇的，于是我又切换到了标准的树掌话，哈哈，都被详细追问到了你爹在那个单位工作看看是不是认识，阿姨和大叔们问我要往哪里去，我说到拉萨，他们说你一定要注意安全啊，嘿嘿，阿姨小跑去车上取下一大包家乡的琪炒，说这个治水土不服，饿了也管饱，你带上，有谁没车上有我去给你拿，实在是推不开，都说近乡情更怯，但我真觉得离乡千万里，乡音更让情更怯，合照，依依分别，大叔还在原处感叹着乡音呐！乡音呐！<br>背井离乡多年，漂泊于外面的世界，会让人变得冷漠，是他们的热情感染了我，重拾原来家乡的人可以这么亲切…<br><img src=\"/images/318/DraggedImage-85.png\" alt=\"\"><br>康巴第一关，以后的路就是藏区了，出行时的七个人仍然不离不弃，新都桥被称为摄影家家的天堂，到处都是美景，微单依然躺在驮包里，我却没有一点想法去拍点什么……<br><img src=\"/images/318/DraggedImage-86.png\" alt=\"\"><br>入住了新都桥桐花里客栈，老板说话让人听起来非常愉快，山东汉子，青岛人，我还给他简单的来了几句青岛话，告诉他我曾经在潍坊上大学，有很多青岛的同学朋友，老板旅行过全国所有的地方，最后留在了这里，开一间小客栈，我们没有过多的交流，但从老大口里听的出这是个有故事的男人。<br><img src=\"/images/318/DraggedImage-87.png\" alt=\"\"><br>晚饭的时候看到老大发的朋友圈，是这样的:<br><img src=\"/images/318/DraggedImage-88.png\" alt=\"\"><br>78年的七尺汉子，当着我的面，真的流泪了，我看到他红了眼眶，就把头转了过去，我不喜欢这样，虽然都是性情中人，老大说当他坐着车从我和老七身边划过时，就哭了，真的后悔了。老五接着说，他那时把眼睛望向了窗外，让泪水在里面转几圈，记住放弃的味道……然后骑下去。<br>我理解他们，所有人都放弃的时候我会感觉到孤独，但选择了走318我就一定不能让自己后悔，不尝试，不尽力就放弃的后悔。</p>\n<h2 id=\"Day-07\"><a href=\"#Day-07\" class=\"headerlink\" title=\"Day 07\"></a>Day 07</h2><p>新都桥 - 高尔寺山 - 雅江 - 相克宗村 /晴 /92km /海拔3600</p>\n<p>今天从七兄弟变成了六个，老三走了，回了南京，我们也不好追问具体详细，昨晚小喝了一杯送别酒，希望老三一路顺风，晚上到达相克宗时听说他已回到了成都。<br>8点钟出发爬坡20多公里到高尔寺隧道，老二在半路高反比较严重，我们在隧道口等了一个多小时，隧道将近6公里长，因为正在修建，其中四公里没有灯，所以必须结伴前行。<br><img src=\"/images/318/DraggedImage-72.png\" alt=\"\"><br>爬山途中遇到昨天在折多山的77岁老大爷的同伴，也是70岁高龄，身体非常硬朗，重庆人，两人结伴骑过五次长途，曾环过山东半岛，其他的我给忘记了，我问他川藏线是不是他骑过最难最有挑战的，他毫不犹豫的告诉我，是的，在高原攀山越岭，太有挑战了。<br><img src=\"/images/318/DraggedImage-73.png\" alt=\"\"><br>半年之前骑行的骑友就没有这种享受了，他们要翻越4659m的高尔寺山，如果折多山被称为康巴第一关，那么高尔寺就是第二关，以前让骑行队伍分开的最多的一座山，挑战和痛苦可想而知……<br>从隧道通过后就是40公里的大长坡到雅江，一路的美景，让人心碎的美景，北京从没有过的蓝天白云，就像许少歌里唱的一样：只有青山藏在白云间，蝴蝶自由穿行在清涧。当然没看到蝴蝶，领悟精神，领悟精神！</p>\n<p><img src=\"/images/318/DraggedImage-74.png\" alt=\"\"><br>一路的长下坡伴随着大回环，我又是队伍中下坡速度控制的最慢的，下午两点钟我们到达了雅江，休息吃午饭，补充水。<br><img src=\"/images/318/DraggedImage-75.png\" alt=\"\"><br>今天的目的地是相克宗村，还有20多公里的陡坡要爬，海拔会重新上升1000多米，所以这一天真正的挑战才刚刚开始，短暂的休息过后，3点钟继续顶着烈日，迎着横风出发了……<br><img src=\"/images/318/DraggedImage-76.png\" alt=\"\"><br>景色依然美不胜收啊……<br><img src=\"/images/318/DraggedImage-77.png\" alt=\"\"><br>路上第一次出现了拉萨的标志，1608公里，我们还有很高很高的山要翻越，很长很长的坡要爬……<br><img src=\"/images/318/DraggedImage-78.png\" alt=\"\"><br>也第一次遇到了川藏公路的长长军车队伍，老七算了一下大概150多辆，我就在想为什么现在交通手段这么成熟，不派几量飞机直接运送，却要让这些汽车兵，成群结对辛辛苦苦的走这川藏线，一个小插曲吧……<br><img src=\"/images/318/DraggedImage-79.png\" alt=\"\"><br>G318的路牌，留一张。<br><img src=\"/images/318/DraggedImage-80.png\" alt=\"\"><br>从此之后，里程碑就步入3开头了，再留一张。碑上写满了骑友想说的话，碑上写不下了就在旁边的栅栏上写……<br>这个时候，相克宗也终于到了，今天的行程体力几乎拉爆了，明天迎接我们的将是川藏线以来最难的，最有挑战的一天……爬4600米的剪子弯山，再翻越卡子拉山，会在4200米的高海拔迎接几十公里的起伏路，并伴随野狗的触摸，自己到处的岗风，侧风，横风，想起来腿就软了，早点休息，早点出发吧，晚安。</p>\n<h2 id=\"Day-08\"><a href=\"#Day-08\" class=\"headerlink\" title=\"Day 08\"></a>Day 08</h2><p>相克宗村 - 剪子弯山 - 卡子拉山 - 红龙乡/雨，晴/79km/海拔4170m  </p>\n<p>被客栈老板称为最难最有挑战的一天，在清晨六点的闹钟中开始了，老大和老二估计是被老板吓到了，果断选择了搭车，14公里的爬坡到剪子弯隧道，途径天路十八弯。<br><img src=\"/images/318/DraggedImage-67.png\" alt=\"\"><br>14公里的爬坡对于刚刚出发的体力来说，易如反掌，2个小时就爬到剪子弯隧道口<br><img src=\"/images/318/DraggedImage-68.png\" alt=\"\"><br>隧道长2.2公里，黑漆漆没有灯，必须结队通过，过了隧道就到剪子弯山的垭口，之后就是在4200以上的高原骑行几十公里的起伏路，云彩好像就在头顶贴着头皮一起飞。<br><img src=\"/images/318/DraggedImage-69.png\" alt=\"\"><br>十公里后，骤云突变，漂泊大雨呼啸而来，整整三十公里的奔袭，加上一句逆风和起伏路，手脚几乎僵硬，一路都是无人区，没有补给的地方，待冲到卡子拉山脚下的日里村时，遇到了藏族的一位大叔，招呼我去他家里喝茶，我就径直跟他爬上藏式的小楼，正好是午饭的时间，喝酥油茶，吃藏餐，烤火炉，不得不感叹这淳朴的民风。休息并等队友会合，一个小时后雨几乎停了，还是不见三位队友的影子，我便开始独自翻越卡子拉山。<br><img src=\"/images/318/DraggedImage-70.png\" alt=\"\"><br>高原的骑行超级爽，第一次连续翻两座山，318醉人的景色，再也没有高反的症状，一路杀到红龙乡，超越了一路的骑友。<br><img src=\"/images/318/DraggedImage-71.png\" alt=\"\"><br>码表破600公里了，1/4的旅程已过，越过这最艰难的一天，继续一路向西。<br>那歌词怎么说的来，对，就这个feel倍儿爽……</p>\n<h2 id=\"Day-09\"><a href=\"#Day-09\" class=\"headerlink\" title=\"Day 09\"></a>Day 09</h2><p>红龙乡 - 理塘/晴/37km/海拔3960<br><img src=\"/images/318/DraggedImage-64.png\" alt=\"\"><br>因为曾喜欢仓央嘉措的诗句，所以到了理塘就一定会想起他，理塘，一个高原小城，海拔四千多米，这座“选在高空的城市”自古以来就是茶马互市上的重镇，而理塘在藏语是“平坦如铜镜的草坝”的意思，县内还有广袤无垠的毛垭大草原。因此理塘也有“世界高城”的称号。<br>所以说起理塘，就不得让人想起仓央嘉措的那首情诗：洁白的仙鹤啊，请把双翅借给我，不飞遥远的地方，只到理塘就回。<br>这首诗，把仓央嘉措和理塘紧紧联系在了一起。也因此，有很多人会认为，理塘，是仓央嘉措的故乡。其实不然，仓央嘉措一生从未到过理塘，而这个地方确实他心灵深处最伤感的地名。因为理塘，是仓央嘉措爱人卓玛的故乡。<br><img src=\"/images/318/DraggedImage-65.png\" alt=\"\"><br>放眼理塘，这座小城并不大，一条主街道走的再慢也不过个把时辰的光景。因为修路，街道略脏，但是你可以看到，天空很蓝，大朵大朵的白云凝固在这深蓝的天空中。树不多，但草原、山丘、河流，披着阳光，显得很干净很原生态。和梦中的境界一样。而这座城市中，轻而易举就能发现仓央嘉措的影子。路边有几家紧挨着的旅馆，名字大多借用了仓央嘉措的绝笔诗，大凡是仙鹤宾馆、白鹤旅馆等等。<br>从红龙乡到理塘的旅程很短很短，所以就慢下来，静静地看着这里的天，缓缓的感受这里的风景。<br><img src=\"/images/318/DraggedImage-66.png\" alt=\"\"><br>有很多想写理塘的话，可是当我真的到了这里，却不知从何写起……再找不到句子，就让情感流淌，理塘的天色有些黯淡了，独自坐在湖边，湖水泛着金光，从草原腹地浅浅的顺流而下……</p>\n<h2 id=\"Day-10\"><a href=\"#Day-10\" class=\"headerlink\" title=\"Day 10\"></a>Day 10</h2><p>理塘 - 禾尼乡/阵雨/58km/海拔4130  </p>\n<p>上午没有出发，看完了这个夏天最后一场比赛。<br>金州勇士输掉了完美赛季里的最重要的一场比赛，输掉了奥布莱恩杯，输掉了总冠军！<br>祝贺克利夫兰，2016最后的赢家，最好的球队不一定能走到最后，竞技体育，最合适的结局！<br><img src=\"/images/318/DraggedImage-60.png\" alt=\"\"><br>球赛结束后，阵雨的陪伴下，出发前往禾尼乡。<br>队伍只剩下我和老五老七，其他已经赶到巴塘休整等我们汇合。<br><img src=\"/images/318/DraggedImage-61.png\" alt=\"\"><br>三个人，三辆单车，继续在画中徜徉，笔直的318直插天际，美到让人喊出来，在喊声里告诉所有人这里的美！<br><img src=\"/images/318/DraggedImage-62.png\" alt=\"\"><br>小溪，蓝天，白云，草原。开车太快，走路太慢，骑单车，刚刚好……<br><img src=\"/images/318/DraggedImage-63.png\" alt=\"\"></p>\n<h2 id=\"Day-11\"><a href=\"#Day-11\" class=\"headerlink\" title=\"Day 11\"></a>Day 11</h2><p>禾尼乡 - 巴塘/阵雨/120km/海拔2590m  </p>\n<p><img src=\"/images/318/DraggedImage-58.png\" alt=\"\"></p>\n<p>当你骑着车子，伸出手臂，把手掌轻摊开来，和对面走来的藏民问好，击掌。相信我你会爱上这种感觉！<br>从理塘到巴塘都是宽阔的草原，翱翔的雄鹰，低飞的燕雀，还有那远处的化作斑斑点点的牦牛。<br>出发第11天，终于扎胎了，在刚刚出发的一小时后，就这么扎了！今天的路程是爬30公里的坡翻越海拔4685米的海子山，经90公里的长坡到巴塘。海拔下降将近两千米，并没有体验到传说中的醉氧。<br>第一次经历生死川藏，下午2点还倚在所波大叔家门框道平安的骑友，4点钟就倒在了往海子山的路上，生命真的这么脆弱，一瞬间，天人永相隔……<br>兄弟愿你一路走好，若有来生再圆川藏梦！<br>高原的天气多变，往往一天要淋好几场雨，往往都是出好几身臭汗……<br><img src=\"/images/318/DraggedImage-59.png\" alt=\"\"><br>出发11天了，终于要出四川了，明天就过金沙江大桥入西藏界了</p>\n<h2 id=\"Day-12\"><a href=\"#Day-12\" class=\"headerlink\" title=\"Day 12\"></a>Day 12</h2><p>巴塘 - 金沙江大桥 - 温泉山庄/晴/47km/海拔2840  </p>\n<p><img src=\"/images/318/DraggedImage-57.png\" alt=\"\"></p>\n<p>出四川了，终于出四川了！穿过金沙江大桥就是西藏界，桥中间横分川藏两界。<br>上午十点出发去邮局买明信片，盖邮戳。说到明信片和邮戳，在理塘之前都没有想到，有点遗憾，以后到拉萨的途中，每到一座城都买吧！<br>下午两点到达温泉山庄，老大已经在等候，老四独自一人翻越宗巴拉山到芒康去了，队伍如今只剩下五人，新的温泉山庄已经基本修建完毕，但还没有开始营业，以后的骑友可以体验享受了！</p>\n<h2 id=\"Day-13\"><a href=\"#Day-13\" class=\"headerlink\" title=\"Day 13\"></a>Day 13</h2><p>温泉山庄 - 宗巴拉山 - 芒康/晴/60km/海拔3920m  </p>\n<p><img src=\"/images/318/DraggedImage-55.png\" alt=\"\"></p>\n<p>痛苦的一天，转弯之后一个接一个的爬坡，还是没有尽头的路，50公里的爬坡，其中将近10公里的烂路，海拔从2800上升到4150，今天，真够累！<br><img src=\"/images/318/DraggedImage-56.png\" alt=\"\"><br>下午担心少数民族地区邮局五点下班，一路狂奔到邮局买明信片盖邮戳，芒康这个鬼地方全城都在修路。</p>\n<h2 id=\"Day-14\"><a href=\"#Day-14\" class=\"headerlink\" title=\"Day 14\"></a>Day 14</h2><p>芒康 - 拉乌山 - 如美/晴/50km/海拔2670  </p>\n<p>出城过检查站的时候，才想起昨天在邮局盖邮戳取钱时把银行卡落在了ATM机被吞了，这次旅行只带了一张卡，叫了老七一起匆匆赶到邮局时，邮局工作人员都回家午休了，下午两点半才上班，需要等一个半小时，那就等吧，在门口待了十多分钟后走过来两个姑娘是邮局的工作人员，说三点半才上班，我就着急了，老五和老大已经先爬坡往如美去了，如果等到三点半天黑前还能不能赶到如美，给两位美女说明事情和为难后，美女给相关工作人员确认了银行卡确实在机器里，然后加了微信，说拿到卡片后帮我寄回北京，感动的我快哭了，这张卡对我有特殊的意义，使用多年，实在不舍得注销。<br><img src=\"/images/318/DraggedImage-50.png\" alt=\"\"><br>事情处理完毕，立即和老七追赶他们的脚步，芒康进城出城都要翻山，进城是宗巴拉山，出城是拉乌山，望着眼前没完的盘山路，就听见老七在我的后面叹息。<br><img src=\"/images/318/DraggedImage-51.png\" alt=\"\"><br>公路的旁边就是悬崖，交警单位把报废的汽车时摆在路旁，时刻提醒着过往的路人，安全第一！老七说你拍这有啥意思，我说要拍，提醒自己，小心加小心，生命只有一次。<br><img src=\"/images/318/DraggedImage-52.png\" alt=\"\"><br>在拉乌山垭口遇到了三个骑滇藏线过来的骑友，这座山是他们目前爬过最高的海拔，聊到他们看到了梅里十三峰，真幸运，祝他们幸运。<br><img src=\"/images/318/DraggedImage-53.png\" alt=\"\"><br>从拉乌山垭口到如美是35公里的下坡，海拔从4370下降到2670，一路风景如画，路过3456的里程碑，留个纪念，上面同样涂满了来自五湖四海骑友想说的话。<br><img src=\"/images/318/DraggedImage-54.png\" alt=\"\"><br>如美小镇跨越澜沧江，到达时还不到五点，老大和老五又搭车了，从撞烂的汽车的地方就搭了，他们坐车到达一刻钟我和老七就到了，我本打算时间尚早再爬十公里山路到教授山庄为明日翻越觉巴山做准备，但是老大说腿软，那就住下吧！<br>顺便洗臭袜子，全汗味的衣服……</p>\n<h2 id=\"Day-15\"><a href=\"#Day-15\" class=\"headerlink\" title=\"Day 15\"></a>Day 15</h2><p>如美 - 觉巴山 - 容许兵站/晴/54km/海拔4020m<br><img src=\"/images/318/DraggedImage-45.png\" alt=\"\"><br>你是否站在过1300米的高处眺望过大地？是什么感觉？觉巴山被当地人称为绝望山，其实海拔并不是很高3911，但是足够征服一个人对山的所有理解。<br><img src=\"/images/318/DraggedImage-46.png\" alt=\"\"><br>出如美到觉巴山垭口26公里的陡坡，海拔从2670上升到3911，九点出发，两点到垭口，5升水，半块压缩饼干，累到说不出话来，只能张开嗓子，干呕两声……<br><img src=\"/images/318/DraggedImage-47.png\" alt=\"\"><br>当站在山顶回望来时的路，我是真的佩服自己，佩服这条线。老大在出发后十公里处终于坚持不住选择了搭车。<br><img src=\"/images/318/DraggedImage-48.png\" alt=\"\"><br>早上出门时，后车轮刹车有点松，调了一下，待到山顶下坡时，发生了问题，后刹刹不住，幸好下坡直有十多公里，前刹还好，下到登巴村时老五和老大又搭车走了，还好有老七陪伴，我已经几乎竭力，还有13公里的爬坡到容许兵站，为明天东达山做准备。<br><img src=\"/images/318/DraggedImage-49.png\" alt=\"\"><br>晚上休息的客栈老板车技超高，高中毕业后就一直玩户外，拿的奖状贴满了客栈餐厅的墙壁，菜做的一级水准，帮我调了刹车和变速，学了好几招调车的方法，等回北京我打算找家车店，周末休息时，去免费帮人调车多学点技能啊哈哈。</p>\n<h2 id=\"Day-16\"><a href=\"#Day-16\" class=\"headerlink\" title=\"Day 16\"></a>Day 16</h2><p>容许兵站 - 东达山 - 左贡/晴/62km/海拔3810m<br><img src=\"/images/318/DraggedImage-42.png\" alt=\"\"><br>东达山，川藏线两座5000米大山之一，难度在于高海拔，坡度平缓，26公里海拔上升1000米，<br>翻过东达山就表示行程已经过半，接下来到达拉萨只剩下四座大山。<br><img src=\"/images/318/DraggedImage-43.png\" alt=\"\"><br>过东达到左贡，如果没有高反就是很轻松的行程，老七在半路高反严重，休息吃药后才继续出发，我最早到达垭口，在垭口等队友将近两个小时。行程太慢，15号出发的队伍都已经追上我们，买了10号拉萨到西宁的机票，川藏之行结束顺路去七月的青海湖，约了一圈好友，大家都没时间，那就我自己吧……<br><img src=\"/images/318/DraggedImage-44.png\" alt=\"\"><br>我只是从未如此想去一个地方。</p>\n<h2 id=\"Day-17\"><a href=\"#Day-17\" class=\"headerlink\" title=\"Day 17\"></a>Day 17</h2><p>左贡 - 邦达/晴，雨/107km 海拔4130m  </p>\n<p><img src=\"/images/318/DraggedImage-41.png\" alt=\"\"><br>西藏的天气是什么样的呢，一言不合就下雨，刚穿上雨衣雨就停，脱完了雨再下，折磨，折磨！<br>今天没有山，100多公里的起伏路，川藏线骑习惯了，平路就当是下坡，一般的上坡就当是平路。<br>累，就写这点吧…</p>\n<h2 id=\"Day-18\"><a href=\"#Day-18\" class=\"headerlink\" title=\"Day 18\"></a>Day 18</h2><p>邦达 - 业拉山 - 怒江72拐 - 八宿/晴/95km/海拔3250<br><img src=\"/images/318/DraggedImage-34.png\" alt=\"\"><br>再出发，三人行，老大又搭车！<br><img src=\"/images/318/DraggedImage-35.png\" alt=\"\"><br>垭口回望来时的路，邦达小镇依稀可见。<br><img src=\"/images/318/DraggedImage-36.png\" alt=\"\"><br>业拉山，海拔4658，已经变的没什么挑战。<br><img src=\"/images/318/DraggedImage-37.png\" alt=\"\"><br>怒江天路72拐，巍峨壮观，身临其境，心惊胆寒！在这里摔车的朋友，一个接一个。老七也摔了，不过问题不大，我肯定不会，我下坡最慢了。<br><img src=\"/images/318/DraggedImage-38.png\" alt=\"\"><br>再看一眼怒江，汹涌着，嘶吼着。天生脾气就不好！<br><img src=\"/images/318/DraggedImage-39.png\" alt=\"\"><br>下了天路72拐，就是30公里的上坡到休息地，前14公里荒无人烟，早上没做准备带干粮，坚持到半路遇见一个能在水浒中才有的凉亭，一碗泡面下肚，立马就过岗，哈哈。<br><img src=\"/images/318/DraggedImage-40.png\" alt=\"\"><br>14公里后，三人坐下每人来了一瓶啤酒，喝完我就腿软了，然后席地而睡休息了一个小时。<br>半路遇到一个开车的大哥非要送我一瓶红牛，我拍拍胸脯告诉他我可以，出发至今带了一罐红牛一直没喝，放在驮包里，我只想靠坚持和毅力去翻越每一座山，每一段旅程。</p>\n<h2 id=\"Day-19\"><a href=\"#Day-19\" class=\"headerlink\" title=\"Day 19\"></a>Day 19</h2><p>八宿 - 安久拉山 - 然乌/晴/90km/海拔3850<br><img src=\"/images/318/DraggedImage-29.png\" alt=\"\"><br>昨晚晚饭时听到几个来自山西晋城的大哥说今天的路程，68公里上坡到安久拉山垭口，22公里起伏路到然乌，他们说过了今天就好了，五星难度，以后的路只是时间问题。<br><img src=\"/images/318/DraggedImage-30.png\" alt=\"\"><br>真正踏上今天的旅程，我们怀着忐忑的心，但是却是休闲骑，直到被一个个晚出发的队伍超越，下午遇到三个纯徒得驴友，互相鼓励，他们已记不起早上是从哪里出发。<br><img src=\"/images/318/DraggedImage-31.png\" alt=\"\"><br>下午六点，我和老七终于爬到安久拉山垭口<br><img src=\"/images/318/DraggedImage-32.png\" alt=\"\"><br>这时老大电话响起，已经定好然乌湖旁边的湖景房。<br><img src=\"/images/318/DraggedImage-33.png\" alt=\"\"><br>傍晚的然乌湖，湖风煦煦，雪山倒映在湖中，我独自坐在湖边感受着这份难得的安静。</p>\n<h2 id=\"Day-20\"><a href=\"#Day-20\" class=\"headerlink\" title=\"Day 20\"></a>Day 20</h2><p>然乌 - 波密/雨/132km/海拔2700<br><img src=\"/images/318/DraggedImage-24.png\" alt=\"\"><br>伴随着小雨，告别美丽的然乌湖，短暂的休整让我们再次出发！今天的行程是132公里的缓下坡和起伏路，海拔将从3850下降到2700，也将步入物产丰富林芝地区。<br><img src=\"/images/318/DraggedImage-25.png\" alt=\"\"><br>进入林芝，以后的景色也都会变得郁郁葱葱～<br><img src=\"/images/318/DraggedImage-26.png\" alt=\"\"><br>不起眼的4000里程碑，又被路过的骑友涂满了各种想说的话，这回没有了栅栏，拉萨越来越近，心情变得急促，我说拉萨不是目的，享受的是在路上……<br><img src=\"/images/318/DraggedImage-27.png\" alt=\"\"><br>路遇生灵，我在4000公路碑拍照时就一直跟着我，前爪受伤严重，特别可怜！喂了一袋压缩饼干，它让我想起陪伴童年时光的那条小黑。希望它一切都好～<br><img src=\"/images/318/DraggedImage-28.png\" alt=\"\"><br>今天的行程是132公里的冒雨穿越，什么防雨措施都成了摆设，十个小时的雨，浑身通透……<br>波密是座美丽的小城，被称为藏王故里，冰川之乡，干净的街道，整齐的建筑，该是沿途看到最繁华最有特色的地方了，一天的雨中穿梭后，大家的衣服浸湿，队伍计划在此休整一天后再向通麦出发。</p>\n<h2 id=\"七月，你好\"><a href=\"#七月，你好\" class=\"headerlink\" title=\"七月，你好\"></a>七月，你好</h2><p><img src=\"/images/318/DraggedImage-23.png\" alt=\"\"><br>岁月如歌，弹唱着盛夏的炎热，六月走过，七月流火，送走了半年苍凉。<br>七月，你好。你是一个半年的开始，你是一个半年的结束。我在时光里穿梭，忘却了日历的轮廓，那密密麻麻的数字，原来是错落排列的日出和日落。<br>2015年6月，2000公里的呼伦贝尔穿越。<br>2016年6月，2000公里的川藏南线挑战。<br>……<br>用车轮丈量大地，体会生命的意义，享受在路上的感觉。追寻倒映在水中的蓝天白云，攀在山顶望见绵延不绝的高山。平日的浮躁与忙碌，总是冲淡我们对美好事物的追求。<br>我们都曾有梦想居住的地方。在依旧有炊烟的村庄，山水亮丽得如同梦里的笑容，每条小路清秀得像一句诗歌。白天浩瀚的蔚蓝、海边架起的小木屋、在阳光跳跃的草原，躺下，自己就是一片湖。<br>千篇一律的生活中，需要一趟说走就走的旅行。“有些事现在不做，也许一辈子都不会做了”。一句简简单单的话，不知击中过多少颗青春不羁的心。只是任何时候，除了向往自由，战胜现实，我们必须知道的是：直面自己、找到通往内心的路。<br>这一季，走过风花雪月，路过倾国倾城。下一季，故地重游，看尽云卷云舒，花开花落。</p>\n<h2 id=\"Day-21\"><a href=\"#Day-21\" class=\"headerlink\" title=\"Day 21\"></a>Day 21</h2><p>波密 - 通麦 - 拉月村/阴/116km/海拔2320m  </p>\n<p><img src=\"/images/318/DraggedImage-17.png\" alt=\"\"><br>波密，就在波密，剩下的哥四个终于统一了发型，本来是约定拉萨一起剃光，提前执行了，我跟老大说，我18岁的时候打死都不会搞这个发型。而现在，从良了，只觉得舒服就好，反正怎么着也都没有女朋友……<br><img src=\"/images/318/DraggedImage-18.png\" alt=\"\"><br>计划之外，在波密休整了两天，原计划休息一天，第二天出发通麦，晚上就下起了雨，早上醒来时仍然没有停的意思，询问大家都说下雨不出发就又果断睡去了。<br><img src=\"/images/318/DraggedImage-19.png\" alt=\"\"><br>查看了未来几天的天气后，于是昨天晚上下定决心，今天下雹子也要走，因为已经提前买了十号拉萨飞西宁的机票，都是眼泪，我是下雨也打算出发的，但奈何队友都不走，一个人雨天路上太危险。<br>今天计划的目的地是通麦，我曾在新浪的\\&lt;胖哥试车>节目的西部穿越之旅里见识过传说中的通麦天险，从波密出发到通麦90公里的起伏路，海拔下降700米，40公里在修路，远超山西未实现村村通工程前的石头泥巴路，路上的骑友举着相机说，这才是318的味道，我路过，回一句，那就好好享受……<br>想说的是队伍只剩下了我和老七，老大和老五在早上醒来后再次选择了搭车到八一，从波密到八一300多公里的路，也就意味着我和老七三天才能到。或许那个时候他们早就又坐车到拉萨了吧……<br><img src=\"/images/318/DraggedImage-20.png\" alt=\"\"><br>刚刚建成的通麦大桥，看胖哥节目的时候还没有他，那时应该正在修建，胖哥在节目里说，等大桥通车，以后过通麦的朋友就幸福了，果然，我幸福了，但也意味着再见不到通麦天险和单边放行的通麦铁板桥。<br><img src=\"/images/318/DraggedImage-21.png\" alt=\"\"><br>到通麦是刚刚下午四点，天色尚早，体力尚充沛，补充水后，我和老七商量下决定往前赶路到排龙乡后面的拉月村，这样如果努力一点的话，可以把三天的行程合并成两天，明天直接杀到八一。<br><img src=\"/images/318/DraggedImage-22.png\" alt=\"\"><br>走在我前面的老七的背影，很感谢他，在所有人都放弃的时候，他没有放弃，陪着我从成都到现在，从未搭过车，做到了用车轮丈量大地的承诺，也因为有他，318对我来说，不显得那么孤单。</p>\n<h2 id=\"Day-22\"><a href=\"#Day-22\" class=\"headerlink\" title=\"Day 22\"></a>Day 22</h2><p>拉月村 - 鲁朗 - 八一/雨/114km/海拔3000<br><img src=\"/images/318/DraggedImage-14.png\" alt=\"\"><br>70公里的爬坡，海拔上升两千多米，第一次挑战在下午体力即将耗尽的时候翻山。太酸爽！这便是三天的路两天赶完的代价。<br><img src=\"/images/318/DraggedImage-15.png\" alt=\"\"><br>在这条线的倒数第二座山，色季拉山的垭口，我给老大打电话，他正在往拉萨的车上，还剩30公里，真的只剩下了我和老七相依为命！<br>出发时的七个人只剩下两个了，这个时候不用说什么坚持之类的云云，我和老七都知道，我们一定会骑完，百分之一的人能真正骑完川藏南线，我们即将做到。<br><img src=\"/images/318/DraggedImage-16.png\" alt=\"\"><br>淋了一天的雨，晚上九点半才到林芝市（原八一镇），318目前为止最大的城市，我说这是大城市！浑身只剩两块银元，和老七满大街的找取款机，取钱吃过饭到住的地方已近11点。我什么都不想说，沿途的风景再美，也抵不住我想尽快到拉萨的心。</p>\n<h2 id=\"Day-23\"><a href=\"#Day-23\" class=\"headerlink\" title=\"Day 23\"></a>Day 23</h2><p>八一 - 工布江达/雨/132km/海拔3420<br><img src=\"/images/318/DraggedImage-10.png\" alt=\"\"><br>不知道我和老七是对自己的体力逐渐有了自信还是，反正总是最晚出发，每天都是我催他起床。一觉睡到自然醒，吃饭，洗车，墨迹墨迹就中午。<br><img src=\"/images/318/DraggedImage-11.png\" alt=\"\"><br>一路沿着尼洋河走，景色优美让人心情分外愉悦，下午三点在百巴镇吃午饭。路过k4321留念<br><img src=\"/images/318/DraggedImage-12.png\" alt=\"\"><br>下午八点到达工布江达，路况较好，所以130公里难度对现在的身体已经够不成太大的挑战，只是中途被浇了好几场雨，鞋子湿了个通透，很酸爽。林芝地区的天气太善变……<br><img src=\"/images/318/DraggedImage-13.png\" alt=\"\"></p>\n<h2 id=\"Day-24\"><a href=\"#Day-24\" class=\"headerlink\" title=\"Day 24\"></a>Day 24</h2><p>工布江达 - 松多/晴/95km/海拔4200m<br><img src=\"/images/318/DraggedImage-6.png\" alt=\"\"><br>出发19公里处是中流砥柱景点，但是因为有人不幸掉水溺死，被蓝色的铁皮围了起来，我们只好爬到旁边的小山去拍一张没有字的一面。<br><img src=\"/images/318/DraggedImage-7.png\" alt=\"\"><br>路书上说，这将是轻松的一天，本计划6 - 8个小时的行程没找到光下午就走了六个小时，全程在修路，漫天的沙子，什么都看不见，等到松多几乎不用吃饭了，沙子加土混合的菜几乎吃饱，嗓子想干呕，又吐不出来。<br><img src=\"/images/318/DraggedImage-8.png\" alt=\"\"><br>k4444界碑已经没有了，在漫天的黄沙中拍了4445界碑，这一路上到处是豆豆的名字，也不知道豆豆是谁<br><img src=\"/images/318/DraggedImage-9.png\" alt=\"\"><br>下午40公里这样的烂路，整整骑了11个小时，接下来到拉萨只剩下180公里，有很多队伍计划一天骑到，我想我还是两天吧，这烂路将持续到拉萨，一天180公里不敢想象。分两天走吧，不作就不会死！<br>慢慢会开始对沿途的风景疲劳，会开始想东想西，从上学时的同学老师到工作后的同事朋友，一个一个想她们的模样，和一些过往，318让我又一次恍惚，分不清昨天今天明天，生活变的只有日出和日落，赶不完的路……</p>\n<h2 id=\"Day-25\"><a href=\"#Day-25\" class=\"headerlink\" title=\"Day 25\"></a>Day 25</h2><p>松多 - 拉萨/晴/180km/海拔3650m<br><img src=\"/images/318/DraggedImage.png\" alt=\"\"><br>大多数人在这一天是要赶到拉萨的，我和老七商量之下，决定把路分成两天走，所以该怎么睡就怎么睡，下楼吃饭时，所有的骑友都走了，只剩下我俩的车子停在哪里……<br>从松多出发，28公里的爬坡翻越米拉山，5013米，318的最后一座山，也是最高的山，海拔上升700，难度不大。<br>正在修建的米拉山隧道，以后来318的骑友可以少爬很多坡了，不知是悲伤还是欢喜<br><img src=\"/images/318/DraggedImage-1.png\" alt=\"\"><br>12点爬到垭口，四个多小时<br><img src=\"/images/318/DraggedImage-2.png\" alt=\"\"><br>在山顶和老七吃了两块小面包补充体力，一路的缓下坡冲到墨竹工卡刚刚下午五点<br><img src=\"/images/318/DraggedImage-3.png\" alt=\"\"><br>墨竹工卡就是我们今天的计划休息地。但天色尚早，很多在我们后面的骑友都往拉萨走了，我也难掩兴奋之情，想一鼓作气冲到拉萨！那索性就继续出发……<br><img src=\"/images/318/DraggedImage-4.png\" alt=\"\"><br>K4567的里程碑，合影留念，过了这就是平坦的柏油路直面拉萨。<br><img src=\"/images/318/DraggedImage-5.png\" alt=\"\"><br>我在最后冲刺的九十公里，身体状态达到了最佳，四个小时就冲到了布达拉，一举超过很多前面的骑友，在冲刺的时候整个脑海在回响这一路爬的每一座山，口中念着每一天的行程。<br>进城过拉萨桥的时候，不由地流泪了，是被自己感动，22天风雨兼程318，不推车，不搭车，不抛弃，不放弃。我做到了！</p>\n"},{"title":"突然就走到了西藏","date":"2016-05-24T02:01:47.000Z","_content":"\n## 突然就走到了西藏\n\n![突然就走到了西藏](/images/read/read_trjzdlxz.jpg)\n>“只要你行走，就能与你生命中的真相相遇。”——陈坤\n\n相信很多朋友看过陈坤的影视作品，知晓他是一名演员，小的时候也磕磕绊绊看过他《金粉世家》《像雾像雨又像风》等荧屏作品。\n\n这里要说的是陈坤有一本书，书名叫《突然就走到了西藏》，很短，十个章节。我是几乎一口气看完的。书里记录了陈坤带领十名大学生志愿者行走西藏过程中，对生命的点滴感悟。穿插了他成名前后生活中的小故事。应该是一本带有自传色彩的书，应该也是一个在世间行走的人对生命和心灵的旁白，你可以读到他的挣扎，他的茫然和转化。\n\n在书里，的的确确能看到陈坤的真诚，并且看到他乐意分享旅程中和过去生活中的故事，以及自己的心路历程。书没有预先想象得那样肤浅。文笔一般，会让人感觉到偏执，但也能感受到字里行间的正面力量。同样很感动陈坤愿意分享他的年少时光，以及对待亲人和友人的态度，和他作为一个儿子，一个朋友以及一个父亲的时候，面对多种人生角色变换时，自己的感受。我想该是值得一读的吧，抵不上好书，是一个人的成长的心路写实。\n\n2016/05/24 北京","source":"_posts/read-trjzdlxz.md","raw":"---\ntitle: 突然就走到了西藏\ndate: 2016-05-24 10:01:47\ntags: [Readed]\ncategories: Readed\n---\n\n## 突然就走到了西藏\n\n![突然就走到了西藏](/images/read/read_trjzdlxz.jpg)\n>“只要你行走，就能与你生命中的真相相遇。”——陈坤\n\n相信很多朋友看过陈坤的影视作品，知晓他是一名演员，小的时候也磕磕绊绊看过他《金粉世家》《像雾像雨又像风》等荧屏作品。\n\n这里要说的是陈坤有一本书，书名叫《突然就走到了西藏》，很短，十个章节。我是几乎一口气看完的。书里记录了陈坤带领十名大学生志愿者行走西藏过程中，对生命的点滴感悟。穿插了他成名前后生活中的小故事。应该是一本带有自传色彩的书，应该也是一个在世间行走的人对生命和心灵的旁白，你可以读到他的挣扎，他的茫然和转化。\n\n在书里，的的确确能看到陈坤的真诚，并且看到他乐意分享旅程中和过去生活中的故事，以及自己的心路历程。书没有预先想象得那样肤浅。文笔一般，会让人感觉到偏执，但也能感受到字里行间的正面力量。同样很感动陈坤愿意分享他的年少时光，以及对待亲人和友人的态度，和他作为一个儿子，一个朋友以及一个父亲的时候，面对多种人生角色变换时，自己的感受。我想该是值得一读的吧，抵不上好书，是一个人的成长的心路写实。\n\n2016/05/24 北京","slug":"read-trjzdlxz","published":1,"updated":"2019-01-13T09:51:15.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjquq0d3e002zl1fq1bat6m60","content":"<h2 id=\"突然就走到了西藏\"><a href=\"#突然就走到了西藏\" class=\"headerlink\" title=\"突然就走到了西藏\"></a>突然就走到了西藏</h2><p><img src=\"/images/read/read_trjzdlxz.jpg\" alt=\"突然就走到了西藏\"></p>\n<blockquote>\n<p>“只要你行走，就能与你生命中的真相相遇。”——陈坤</p>\n</blockquote>\n<p>相信很多朋友看过陈坤的影视作品，知晓他是一名演员，小的时候也磕磕绊绊看过他《金粉世家》《像雾像雨又像风》等荧屏作品。</p>\n<p>这里要说的是陈坤有一本书，书名叫《突然就走到了西藏》，很短，十个章节。我是几乎一口气看完的。书里记录了陈坤带领十名大学生志愿者行走西藏过程中，对生命的点滴感悟。穿插了他成名前后生活中的小故事。应该是一本带有自传色彩的书，应该也是一个在世间行走的人对生命和心灵的旁白，你可以读到他的挣扎，他的茫然和转化。</p>\n<p>在书里，的的确确能看到陈坤的真诚，并且看到他乐意分享旅程中和过去生活中的故事，以及自己的心路历程。书没有预先想象得那样肤浅。文笔一般，会让人感觉到偏执，但也能感受到字里行间的正面力量。同样很感动陈坤愿意分享他的年少时光，以及对待亲人和友人的态度，和他作为一个儿子，一个朋友以及一个父亲的时候，面对多种人生角色变换时，自己的感受。我想该是值得一读的吧，抵不上好书，是一个人的成长的心路写实。</p>\n<p>2016/05/24 北京</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"突然就走到了西藏\"><a href=\"#突然就走到了西藏\" class=\"headerlink\" title=\"突然就走到了西藏\"></a>突然就走到了西藏</h2><p><img src=\"/images/read/read_trjzdlxz.jpg\" alt=\"突然就走到了西藏\"></p>\n<blockquote>\n<p>“只要你行走，就能与你生命中的真相相遇。”——陈坤</p>\n</blockquote>\n<p>相信很多朋友看过陈坤的影视作品，知晓他是一名演员，小的时候也磕磕绊绊看过他《金粉世家》《像雾像雨又像风》等荧屏作品。</p>\n<p>这里要说的是陈坤有一本书，书名叫《突然就走到了西藏》，很短，十个章节。我是几乎一口气看完的。书里记录了陈坤带领十名大学生志愿者行走西藏过程中，对生命的点滴感悟。穿插了他成名前后生活中的小故事。应该是一本带有自传色彩的书，应该也是一个在世间行走的人对生命和心灵的旁白，你可以读到他的挣扎，他的茫然和转化。</p>\n<p>在书里，的的确确能看到陈坤的真诚，并且看到他乐意分享旅程中和过去生活中的故事，以及自己的心路历程。书没有预先想象得那样肤浅。文笔一般，会让人感觉到偏执，但也能感受到字里行间的正面力量。同样很感动陈坤愿意分享他的年少时光，以及对待亲人和友人的态度，和他作为一个儿子，一个朋友以及一个父亲的时候，面对多种人生角色变换时，自己的感受。我想该是值得一读的吧，抵不上好书，是一个人的成长的心路写实。</p>\n<p>2016/05/24 北京</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjquq0d1y0007l1fqs7uubg6c","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d27000fl1fq68tsd404"},{"post_id":"cjquq0d1n0001l1fqgimzw2u3","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2a000kl1fqigntu50t"},{"post_id":"cjquq0d200008l1fqnv5xlcfo","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2c000nl1fqo2mb6mvw"},{"post_id":"cjquq0d23000cl1fqb89j0t36","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2e000ql1fq6kgedvd6"},{"post_id":"cjquq0d1s0003l1fqzuyhnn8d","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2f000tl1fqz1d8rqlz"},{"post_id":"cjquq0d29000jl1fqeaqd7uc8","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2g000yl1fqi1jp88yd"},{"post_id":"cjquq0d1x0006l1fqdi7885do","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2i0011l1fqup7iv4d4"},{"post_id":"cjquq0d2b000ml1fqikbl55hx","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2j0016l1fqtg44pke4"},{"post_id":"cjquq0d2e000sl1fq09oj4fj6","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d2l0018l1fqgm3gdiqt"},{"post_id":"cjquq0d2k0017l1fqrn8rbwkc","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d2p001fl1fqej7vy2wp"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d2s001ll1fq7vd8yp43"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d2t001pl1fquv8xu4bj"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d2v001sl1fqts9gvs96"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d2y001xl1fqpbtadv2y"},{"post_id":"cjquq0d2o001el1fq4emiehud","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d2z0020l1fqym8iiz1e"},{"post_id":"cjquq0d2o001el1fq4emiehud","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d310024l1fqgm6zil9g"},{"post_id":"cjquq0d2q001jl1fq0k207idv","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d320026l1fqxr7sp0qx"},{"post_id":"cjquq0d2q001jl1fq0k207idv","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d330028l1fq0qgb3o1g"},{"post_id":"cjquq0d2d000pl1fq0pmsisae","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d35002cl1fqjsjwxk0o"},{"post_id":"cjquq0d2d000pl1fq0pmsisae","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d36002gl1fqi68gynxo"},{"post_id":"cjquq0d2r001kl1fq7i1tilts","category_id":"cjquq0d1u0004l1fqok6nqd7g","_id":"cjquq0d37002kl1fqnq900vix"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d39002ol1fql8b68ovd"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3a002rl1fqlzv8u9yz"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3c002ul1fq0jbbojsw"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3e002xl1fqhk4oudgx"},{"post_id":"cjquq0d2u001rl1fqlpfang1i","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3f0031l1fq8ob97h1s"},{"post_id":"cjquq0d2u001rl1fqlpfang1i","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3g0034l1fq2ez4m0so"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3g0037l1fqhtjxjnrp"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3g003al1fqunqy1qp4"},{"post_id":"cjquq0d2g000xl1fq42k8a86j","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3h003dl1fqm5i9yg0j"},{"post_id":"cjquq0d2g000xl1fq42k8a86j","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3h003fl1fqh32mtv3w"},{"post_id":"cjquq0d2y001zl1fq2o7m4jwe","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3i003il1fqtlktxjov"},{"post_id":"cjquq0d300022l1fqbqs2t7uj","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3i003kl1fqt5mrky5p"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3i003nl1fqv32a5pip"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3i003pl1fq7f0m6dt8"},{"post_id":"cjquq0d330027l1fqg3rw45hj","category_id":"cjquq0d35002dl1fqb6ke03af","_id":"cjquq0d3j003rl1fqsyio5x2l"},{"post_id":"cjquq0d34002al1fqlsg4ln4n","category_id":"cjquq0d35002dl1fqb6ke03af","_id":"cjquq0d3j003sl1fqmu01pe6g"},{"post_id":"cjquq0d39002ql1fqnxlc2e64","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3j003ul1fqr60wlsqd"},{"post_id":"cjquq0d39002ql1fqnxlc2e64","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3k003wl1fqj9veme3w"},{"post_id":"cjquq0d3a002sl1fq9b1uo16w","category_id":"cjquq0d2f000ul1fq8p8sn7gt","_id":"cjquq0d3k003zl1fqibjcg3qr"},{"post_id":"cjquq0d3a002sl1fq9b1uo16w","category_id":"cjquq0d2m001al1fqpnrr1tby","_id":"cjquq0d3k0041l1fq9dby44ic"},{"post_id":"cjquq0d35002el1fq75xw9hbs","category_id":"cjquq0d35002dl1fqb6ke03af","_id":"cjquq0d3l0044l1fqr1z8mij5"},{"post_id":"cjquq0d3e002zl1fq1bat6m60","category_id":"cjquq0d35002dl1fqb6ke03af","_id":"cjquq0d3l0045l1fqu3yoic4k"},{"post_id":"cjquq0d36002il1fqzjzlma7j","category_id":"cjquq0d3f0030l1fqlfonqeb9","_id":"cjquq0d3m0047l1fqg4m79vu0"},{"post_id":"cjquq0d38002ll1fq2qei44x3","category_id":"cjquq0d3f0030l1fqlfonqeb9","_id":"cjquq0d3m0048l1fq775oynpk"},{"post_id":"cjquq0d3c002wl1fqv2gms1b8","category_id":"cjquq0d3h003cl1fqdle6axf9","_id":"cjquq0d3m0049l1fqkkhck6bq"}],"PostTag":[{"post_id":"cjquq0d1y0007l1fqs7uubg6c","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d23000bl1fqc4l39wvy"},{"post_id":"cjquq0d1n0001l1fqgimzw2u3","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d25000dl1fqm71symwm"},{"post_id":"cjquq0d200008l1fqnv5xlcfo","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d29000il1fqua31p586"},{"post_id":"cjquq0d23000cl1fqb89j0t36","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2b000ll1fqqsxel8dv"},{"post_id":"cjquq0d1s0003l1fqzuyhnn8d","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2d000ol1fqmdogtksu"},{"post_id":"cjquq0d29000jl1fqeaqd7uc8","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2e000rl1fq2ip6zsq8"},{"post_id":"cjquq0d1x0006l1fqdi7885do","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2g000wl1fquu0488mq"},{"post_id":"cjquq0d2b000ml1fqikbl55hx","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2h000zl1fqjik0x2uz"},{"post_id":"cjquq0d2e000sl1fq09oj4fj6","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2i0012l1fqapc0s2a5"},{"post_id":"cjquq0d2d000pl1fq0pmsisae","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d2o001dl1fqlt63vnng"},{"post_id":"cjquq0d2d000pl1fq0pmsisae","tag_id":"cjquq0d2j0015l1fq4rb7cx3b","_id":"cjquq0d2p001gl1fqsflal7e8"},{"post_id":"cjquq0d2g000xl1fq42k8a86j","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d2u001ql1fqt9ls80i7"},{"post_id":"cjquq0d2g000xl1fq42k8a86j","tag_id":"cjquq0d2p001il1fqdrruvymi","_id":"cjquq0d2v001ul1fq2eicvi4f"},{"post_id":"cjquq0d2r001kl1fq7i1tilts","tag_id":"cjquq0d1w0005l1fqreul2pvt","_id":"cjquq0d2y001yl1fqptp12hwz"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d35002bl1fq1qlvpqe6"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d36002fl1fqp1zgnu97"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","tag_id":"cjquq0d2w001vl1fqlkdzzdfz","_id":"cjquq0d37002jl1fqkwadkipz"},{"post_id":"cjquq0d2h0010l1fq4t1zezpl","tag_id":"cjquq0d300023l1fq74vi9mvy","_id":"cjquq0d39002nl1fqaqd1uw7o"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3e002yl1fqpfpvq6ct"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3f0032l1fqjgseul4q"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","tag_id":"cjquq0d36002hl1fq3tbka3cr","_id":"cjquq0d3g0035l1fqm313cyy2"},{"post_id":"cjquq0d2i0013l1fqrnwjr2pp","tag_id":"cjquq0d39002pl1fqr6cqrvzz","_id":"cjquq0d3g0038l1fqbvfc0rxr"},{"post_id":"cjquq0d3a002sl1fq9b1uo16w","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3h003bl1fqe1t01va7"},{"post_id":"cjquq0d3a002sl1fq9b1uo16w","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3h003el1fq8u8nduqk"},{"post_id":"cjquq0d2k0017l1fqrn8rbwkc","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3i003hl1fqsr17q91b"},{"post_id":"cjquq0d2k0017l1fqrn8rbwkc","tag_id":"cjquq0d36002hl1fq3tbka3cr","_id":"cjquq0d3i003jl1fqdtznvlga"},{"post_id":"cjquq0d2k0017l1fqrn8rbwkc","tag_id":"cjquq0d3f0033l1fq95xna2xg","_id":"cjquq0d3i003ml1fqzrpxx3bq"},{"post_id":"cjquq0d2k0017l1fqrn8rbwkc","tag_id":"cjquq0d3g0039l1fqmawpg7wa","_id":"cjquq0d3i003ol1fqg10d2twv"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3j003vl1fqml5m23h5"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3k003xl1fq0gdxzu1w"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","tag_id":"cjquq0d3i003ll1fq6dyiqvkk","_id":"cjquq0d3k0040l1fquu241krj"},{"post_id":"cjquq0d2l0019l1fqivjiw3cu","tag_id":"cjquq0d3j003ql1fqbrmjt761","_id":"cjquq0d3k0042l1fqg0ii626y"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3n004bl1fq0x67ckkd"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3n004cl1fqjglf7ryb"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","tag_id":"cjquq0d36002hl1fq3tbka3cr","_id":"cjquq0d3o004el1fq983p0tmv"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","tag_id":"cjquq0d3k0043l1fqapd2j3c6","_id":"cjquq0d3o004fl1fq4qme1j9d"},{"post_id":"cjquq0d2n001cl1fqdp6o729v","tag_id":"cjquq0d3m0046l1fq9mv1offf","_id":"cjquq0d3o004hl1fq01jowdg3"},{"post_id":"cjquq0d2o001el1fq4emiehud","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3p004jl1fqclg32rvt"},{"post_id":"cjquq0d2o001el1fq4emiehud","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3p004kl1fqiz7h3dgf"},{"post_id":"cjquq0d2o001el1fq4emiehud","tag_id":"cjquq0d3o004dl1fqmiuc84qn","_id":"cjquq0d3p004ml1fqffsw0i88"},{"post_id":"cjquq0d2o001el1fq4emiehud","tag_id":"cjquq0d3o004gl1fqrz9zisbm","_id":"cjquq0d3p004nl1fquie6vaa4"},{"post_id":"cjquq0d2q001jl1fq0k207idv","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3q004pl1fq0ndsohgn"},{"post_id":"cjquq0d2q001jl1fq0k207idv","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3q004ql1fq50l11r4y"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3q004sl1fqh6g03zk4"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3q004tl1fqfhm87kkz"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","tag_id":"cjquq0d3i003ll1fq6dyiqvkk","_id":"cjquq0d3r004vl1fq1af3f0qc"},{"post_id":"cjquq0d2t001ol1fqggtnlq8y","tag_id":"cjquq0d3p004ol1fqdu7xmln0","_id":"cjquq0d3r004wl1fq3706k6i6"},{"post_id":"cjquq0d2u001rl1fqlpfang1i","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3r004yl1fqo7eqzhak"},{"post_id":"cjquq0d2u001rl1fqlpfang1i","tag_id":"cjquq0d3i003ll1fq6dyiqvkk","_id":"cjquq0d3r004zl1fq93sg2k9h"},{"post_id":"cjquq0d2u001rl1fqlpfang1i","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3s0051l1fq8o61k57x"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3s0052l1fq073pv0tk"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3s0054l1fqegoje9il"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","tag_id":"cjquq0d3i003ll1fq6dyiqvkk","_id":"cjquq0d3s0055l1fq4c9yijmt"},{"post_id":"cjquq0d2w001wl1fqxjgjot8h","tag_id":"cjquq0d3r004xl1fqyex9707l","_id":"cjquq0d3t0057l1fqla2n61pv"},{"post_id":"cjquq0d2y001zl1fq2o7m4jwe","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3t0058l1fqy9kgxmjl"},{"post_id":"cjquq0d2y001zl1fq2o7m4jwe","tag_id":"cjquq0d3r0050l1fqsiyrsz52","_id":"cjquq0d3t005al1fq4nj6rr77"},{"post_id":"cjquq0d300022l1fqbqs2t7uj","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3t005bl1fqsjnb7ck9"},{"post_id":"cjquq0d300022l1fqbqs2t7uj","tag_id":"cjquq0d36002hl1fq3tbka3cr","_id":"cjquq0d3t005cl1fqrxd2rw4b"},{"post_id":"cjquq0d300022l1fqbqs2t7uj","tag_id":"cjquq0d3t0056l1fqb75eq6mu","_id":"cjquq0d3u005el1fqtydu0m27"},{"post_id":"cjquq0d330027l1fqg3rw45hj","tag_id":"cjquq0d3t0059l1fq5670zv22","_id":"cjquq0d3u005fl1fqhc3f4vs1"},{"post_id":"cjquq0d34002al1fqlsg4ln4n","tag_id":"cjquq0d3t0059l1fq5670zv22","_id":"cjquq0d3u005hl1fqdtssa1hv"},{"post_id":"cjquq0d35002el1fq75xw9hbs","tag_id":"cjquq0d3t0059l1fq5670zv22","_id":"cjquq0d3v005jl1fq16qb7fzn"},{"post_id":"cjquq0d36002il1fqzjzlma7j","tag_id":"cjquq0d3v005il1fqngc8kbqa","_id":"cjquq0d3v005ll1fqpnh18fmf"},{"post_id":"cjquq0d38002ll1fq2qei44x3","tag_id":"cjquq0d3v005il1fqngc8kbqa","_id":"cjquq0d3w005nl1fqpaf6szs7"},{"post_id":"cjquq0d39002ql1fqnxlc2e64","tag_id":"cjquq0d2f000vl1fq6eby6dx0","_id":"cjquq0d3w005pl1fqtt88wuia"},{"post_id":"cjquq0d39002ql1fqnxlc2e64","tag_id":"cjquq0d2s001nl1fqwuuus9rt","_id":"cjquq0d3w005ql1fqukf0xuf4"},{"post_id":"cjquq0d39002ql1fqnxlc2e64","tag_id":"cjquq0d3w005ml1fqrwjz0j4a","_id":"cjquq0d3x005sl1fq4uru4mfq"},{"post_id":"cjquq0d3c002wl1fqv2gms1b8","tag_id":"cjquq0d3w005ol1fqm8hvgzci","_id":"cjquq0d3x005tl1fqqztm23uw"},{"post_id":"cjquq0d3e002zl1fq1bat6m60","tag_id":"cjquq0d3t0059l1fq5670zv22","_id":"cjquq0d3x005ul1fqadenfkkd"}],"Tag":[{"name":"Daily","_id":"cjquq0d1w0005l1fqreul2pvt"},{"name":"iOS","_id":"cjquq0d2f000vl1fq6eby6dx0"},{"name":"Category","_id":"cjquq0d2j0015l1fq4rb7cx3b"},{"name":"keywords","_id":"cjquq0d2p001il1fqdrruvymi"},{"name":"Objc","_id":"cjquq0d2s001nl1fqwuuus9rt"},{"name":"KVC","_id":"cjquq0d2w001vl1fqlkdzzdfz"},{"name":"KVO","_id":"cjquq0d300023l1fq74vi9mvy"},{"name":"Network","_id":"cjquq0d36002hl1fq3tbka3cr"},{"name":"NSURLSession","_id":"cjquq0d39002pl1fqr6cqrvzz"},{"name":"Http","_id":"cjquq0d3f0033l1fq95xna2xg"},{"name":"Https","_id":"cjquq0d3g0039l1fqmawpg7wa"},{"name":"Thread","_id":"cjquq0d3i003ll1fq6dyiqvkk"},{"name":"NSThread","_id":"cjquq0d3j003ql1fqbrmjt761"},{"name":"NSURLRequest","_id":"cjquq0d3k0043l1fqapd2j3c6"},{"name":"NSURLResponse","_id":"cjquq0d3m0046l1fq9mv1offf"},{"name":"RunLoop","_id":"cjquq0d3o004dl1fqmiuc84qn"},{"name":"AutoreleasePool","_id":"cjquq0d3o004gl1fqrz9zisbm"},{"name":"GCD","_id":"cjquq0d3p004ol1fqdu7xmln0"},{"name":"NSOperation","_id":"cjquq0d3r004xl1fqyex9707l"},{"name":"UITableView","_id":"cjquq0d3r0050l1fqsiyrsz52"},{"name":"WebView","_id":"cjquq0d3t0056l1fqb75eq6mu"},{"name":"Readed","_id":"cjquq0d3t0059l1fq5670zv22"},{"name":"Xcode","_id":"cjquq0d3v005il1fqngc8kbqa"},{"name":"Block","_id":"cjquq0d3w005ml1fqrwjz0j4a"},{"name":"Jurney","_id":"cjquq0d3w005ol1fqm8hvgzci"}]}}